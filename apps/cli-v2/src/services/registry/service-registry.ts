/**
 * Service Registry Implementation
 * 
 * Central registry for managing service templates and definitions.
 * 
 * @author Backend Expert Agent
 * @since 2025-01-03
 */

import { consola } from 'consola';
import fs from 'fs-extra';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

import type { IServiceRegistry, ServiceTemplate, ServiceType } from '../../types/index.js';
import { ServiceTemplateSchema } from '../../types/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export class ServiceRegistry implements IServiceRegistry {
  private templates: Map<string, ServiceTemplate> = new Map();
  private initialized = false;
  private templatesPath: string;

  constructor() {
    // Service templates are stored in src/services/templates/definitions
    this.templatesPath = path.join(__dirname, '../templates/definitions');
  }

  async initialize(): Promise<void> {
    if (this.initialized) return;

    consola.debug('Initializing service registry...');

    try {
      await this.loadServiceTemplates();
      this.initialized = true;
      consola.debug(`Service registry initialized with ${this.templates.size} templates`);
    } catch (error) {
      consola.error('Failed to initialize service registry:', error);
      throw new Error('Service registry initialization failed');
    }
  }

  async getTemplate(type: ServiceType | string, provider: string): Promise<ServiceTemplate | null> {
    const key = `${type}:${provider}`;
    return this.templates.get(key) || null;
  }

  async listTemplates(type?: ServiceType | string): Promise<ServiceTemplate[]> {
    const templates = Array.from(this.templates.values());
    
    if (type) {
      return templates.filter(t => t.type === type);
    }
    
    return templates;
  }

  async registerTemplate(template: ServiceTemplate): Promise<void> {
    // Validate template
    const result = ServiceTemplateSchema.safeParse(template);
    if (!result.success) {
      throw new Error(`Invalid template: ${result.error.message}`);
    }

    const key = `${template.type}:${template.provider}`;
    this.templates.set(key, template);
    
    consola.debug(`Registered template: ${key}`);
  }

  private async loadServiceTemplates(): Promise<void> {
    // Create templates directory if it doesn't exist
    await fs.ensureDir(this.templatesPath);

    // Load built-in templates
    await this.loadBuiltInTemplates();

    // Load custom templates from JSON files
    const files = await fs.readdir(this.templatesPath);
    const jsonFiles = files.filter(f => f.endsWith('.json'));

    for (const file of jsonFiles) {
      try {
        const filePath = path.join(this.templatesPath, file);
        const content = await fs.readJson(filePath);
        
        // Validate and register template
        const result = ServiceTemplateSchema.safeParse(content);
        if (result.success) {
          await this.registerTemplate(result.data);
        } else {
          consola.warn(`Invalid template in ${file}:`, result.error.message);
        }
      } catch (error) {
        consola.warn(`Failed to load template ${file}:`, error);
      }
    }
  }

  private async loadBuiltInTemplates(): Promise<void> {
    // Built-in templates for common services
    const builtInTemplates: ServiceTemplate[] = [
      // Frontend Framework Services
      {
        name: 'nextjs',
        type: 'frontend',
        provider: 'vercel',
        version: '14.0.0',
        description: 'React framework with hybrid SSR/SSG and full-stack capabilities',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'next.config.js',
            template: `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['localhost'],
  },
  experimental: {
    serverActions: true,
  },
}

module.exports = nextConfig
`
          },
          {
            type: 'file-create',
            target: 'src/app/layout.tsx',
            template: `import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/page.tsx',
            template: `export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1 className="text-4xl font-bold">Welcome to Next.js!</h1>
    </main>
  )
}
`
          },
          {
            type: 'dependency',
            packages: {
              'next': '^14.0.0',
              'react': '^18.0.0',
              'react-dom': '^18.0.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              '@types/react': '^18.0.0',
              '@types/react-dom': '^18.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://nextjs.org/docs',
        complexity: 'medium',
        tags: ['react', 'ssr', 'ssg', 'full-stack', 'vercel']
      },
      {
        name: 'nuxt',
        type: 'frontend',
        provider: 'nuxt',
        version: '3.0.0',
        description: 'Vue.js framework with SSR, SSG, and full-stack capabilities',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'nuxt.config.ts',
            template: `export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
  ],
  css: ['~/assets/css/main.css'],
  typescript: {
    strict: true
  }
})
`
          },
          {
            type: 'file-create',
            target: 'app.vue',
            template: `<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
`
          },
          {
            type: 'file-create',
            target: 'pages/index.vue',
            template: `<template>
  <div class="min-h-screen flex items-center justify-center">
    <h1 class="text-4xl font-bold">Welcome to Nuxt 3!</h1>
  </div>
</template>

<script setup lang="ts">
// Page meta
useHead({
  title: 'Home',
  meta: [
    { name: 'description', content: 'Welcome to Nuxt 3' }
  ]
})
</script>
`
          },
          {
            type: 'dependency',
            packages: {
              'nuxt': '^3.0.0',
              'vue': '^3.0.0',
              'vue-router': '^4.0.0'
            },
            devDependencies: {
              '@nuxt/devtools': 'latest',
              '@nuxtjs/tailwindcss': '^6.0.0',
              '@pinia/nuxt': '^0.5.0'
            }
          }
        ],
        documentation: 'https://nuxt.com/docs',
        complexity: 'medium',
        tags: ['vue', 'ssr', 'ssg', 'full-stack', 'nitro']
      },
      {
        name: 'sveltekit',
        type: 'frontend',
        provider: 'svelte',
        version: '2.0.0',
        description: 'Svelte app framework with SSR and filesystem-based routing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'svelte.config.js',
            template: `import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),
  kit: {
    adapter: adapter()
  }
};

export default config;
`
          },
          {
            type: 'file-create',
            target: 'src/routes/+layout.svelte',
            template: `<script>
  import '../app.css';
</script>

<slot />
`
          },
          {
            type: 'file-create',
            target: 'src/routes/+page.svelte',
            template: `<script lang="ts">
  import { onMount } from 'svelte';
  
  let message = 'Welcome to SvelteKit!';
</script>

<main class="min-h-screen flex items-center justify-center">
  <h1 class="text-4xl font-bold">{message}</h1>
</main>
`
          },
          {
            type: 'dependency',
            packages: {
              '@sveltejs/kit': '^2.0.0',
              'svelte': '^4.0.0'
            },
            devDependencies: {
              '@sveltejs/adapter-auto': '^3.0.0',
              '@sveltejs/vite-plugin-svelte': '^3.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://kit.svelte.dev/docs',
        complexity: 'medium',
        tags: ['svelte', 'ssr', 'ssg', 'vite', 'filesystem-routing']
      },
      {
        name: 'react',
        type: 'frontend',
        provider: 'facebook',
        version: '18.0.0',
        description: 'A JavaScript library for building user interfaces',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/App.tsx',
            template: `import React, { useState } from 'react';
import './App.css';

function App() {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <header className="App-header">
        <h1>Welcome to React!</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>
          Increment
        </button>
      </header>
    </div>
  );
}

export default App;
`
          },
          {
            type: 'file-create',
            target: 'src/main.tsx',
            template: `import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
`
          },
          {
            type: 'dependency',
            packages: {
              'react': '^18.0.0',
              'react-dom': '^18.0.0'
            },
            devDependencies: {
              '@types/react': '^18.0.0',
              '@types/react-dom': '^18.0.0',
              '@vitejs/plugin-react': '^4.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://react.dev/',
        complexity: 'low',
        tags: ['react', 'spa', 'ui-library', 'component-based']
      },
      {
        name: 'vue',
        type: 'frontend',
        provider: 'vue',
        version: '3.0.0',
        description: 'The progressive JavaScript framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/App.vue',
            template: `<template>
  <div id="app">
    <h1>{{ message }}</h1>
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const message = ref('Welcome to Vue 3!')
const count = ref(0)

const increment = () => {
  count.value++
}
</script>

<style scoped>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  text-align: center;
  margin-top: 60px;
}
</style>
`
          },
          {
            type: 'file-create',
            target: 'src/main.ts',
            template: `import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app')
`
          },
          {
            type: 'dependency',
            packages: {
              'vue': '^3.0.0'
            },
            devDependencies: {
              '@vitejs/plugin-vue': '^4.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0',
              'vue-tsc': '^1.0.0'
            }
          }
        ],
        documentation: 'https://vuejs.org/guide/',
        complexity: 'low',
        tags: ['vue', 'spa', 'progressive', 'reactive']
      },
      {
        name: 'angular',
        type: 'frontend',
        provider: 'google',
        version: '17.0.0',
        description: 'Platform for building mobile and desktop web applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'angular.json',
            template: `{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/app",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "assets": ["src/favicon.ico", "src/assets"],
            "styles": ["src/styles.css"],
            "scripts": []
          }
        }
      }
    }
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/app.component.ts',
            template: `import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class="container">
      <h1>Welcome to {{ title }}!</h1>
      <p>Count: {{ count }}</p>
      <button (click)="increment()">Increment</button>
    </div>
  \`,
  styles: [\`
    .container {
      text-align: center;
      padding: 50px;
    }
  \`]
})
export class AppComponent {
  title = 'Angular';
  count = 0;

  increment() {
    this.count++;
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@angular/animations': '^17.0.0',
              '@angular/common': '^17.0.0',
              '@angular/compiler': '^17.0.0',
              '@angular/core': '^17.0.0',
              '@angular/forms': '^17.0.0',
              '@angular/platform-browser': '^17.0.0',
              '@angular/platform-browser-dynamic': '^17.0.0',
              '@angular/router': '^17.0.0',
              'rxjs': '^7.0.0',
              'tslib': '^2.0.0',
              'zone.js': '^0.14.0'
            },
            devDependencies: {
              '@angular-devkit/build-angular': '^17.0.0',
              '@angular/cli': '^17.0.0',
              '@angular/compiler-cli': '^17.0.0',
              'typescript': '~5.2.0'
            }
          }
        ],
        documentation: 'https://angular.io/docs',
        complexity: 'high',
        tags: ['angular', 'typescript', 'enterprise', 'full-framework']
      },

      // Backend Framework Services
      {
        name: 'hono',
        type: 'backend',
        provider: 'hono',
        version: '3.0.0',
        description: 'Ultrafast web framework for the Edge',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/index.ts',
            template: `import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { prettyJSON } from 'hono/pretty-json'

const app = new Hono()

// Middleware
app.use('*', logger())
app.use('*', cors())
app.use('*', prettyJSON())

// Routes
app.get('/', (c) => {
  return c.json({ message: 'Welcome to Hono!' })
})

app.get('/api/users', (c) => {
  return c.json({ users: [] })
})

app.post('/api/users', async (c) => {
  const body = await c.req.json()
  return c.json({ user: body }, 201)
})

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import { serve } from '@hono/node-server'
import app from './index'

const port = 3000
console.log(\`Server is running on port \${port}\`)

serve({
  fetch: app.fetch,
  port
})
`
          },
          {
            type: 'dependency',
            packages: {
              'hono': '^3.0.0',
              '@hono/node-server': '^1.0.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              'tsx': '^4.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://hono.dev/',
        complexity: 'low',
        tags: ['edge', 'fast', 'lightweight', 'web-framework']
      },
      {
        name: 'express',
        type: 'backend',
        provider: 'express',
        version: '4.18.0',
        description: 'Fast, unopinionated, minimalist web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import express, { Express, Request, Response } from 'express'
import cors from 'cors'
import helmet from 'helmet'
import morgan from 'morgan'
import { errorHandler } from './middleware/errorHandler'

const app: Express = express()

// Middleware
app.use(helmet())
app.use(cors())
app.use(morgan('dev'))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// Routes
app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Welcome to Express!' })
})

app.get('/api/users', (req: Request, res: Response) => {
  res.json({ users: [] })
})

app.post('/api/users', (req: Request, res: Response) => {
  const user = req.body
  res.status(201).json({ user })
})

// Error handling
app.use(errorHandler)

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import app from './app'
import dotenv from 'dotenv'

dotenv.config()

const PORT = process.env.PORT || 3000

app.listen(PORT, () => {
  console.log(\`Server is running on port \${PORT}\`)
})
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/errorHandler.ts',
            template: `import { Request, Response, NextFunction } from 'express'

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error(err.stack)
  res.status(500).json({
    message: 'Something went wrong!',
    error: process.env.NODE_ENV === 'production' ? {} : err
  })
}
`
          },
          {
            type: 'dependency',
            packages: {
              'express': '^4.18.0',
              'cors': '^2.8.5',
              'helmet': '^7.0.0',
              'morgan': '^1.10.0',
              'dotenv': '^16.0.0'
            },
            devDependencies: {
              '@types/express': '^4.17.0',
              '@types/cors': '^2.8.0',
              '@types/morgan': '^1.9.0',
              '@types/node': '^20.0.0',
              'nodemon': '^3.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://expressjs.com/',
        complexity: 'low',
        tags: ['nodejs', 'web-framework', 'rest-api', 'traditional']
      },
      {
        name: 'fastify',
        type: 'backend',
        provider: 'fastify',
        version: '4.0.0',
        description: 'Fast and low overhead web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import Fastify from 'fastify'
import cors from '@fastify/cors'
import helmet from '@fastify/helmet'
import { TypeBoxTypeProvider } from '@fastify/type-provider-typebox'
import { Type } from '@sinclair/typebox'

const fastify = Fastify({
  logger: true
}).withTypeProvider<TypeBoxTypeProvider>()

// Register plugins
fastify.register(cors)
fastify.register(helmet)

// Schemas
const UserSchema = Type.Object({
  id: Type.String(),
  name: Type.String(),
  email: Type.String({ format: 'email' })
})

// Routes
fastify.get('/', async (request, reply) => {
  return { message: 'Welcome to Fastify!' }
})

fastify.get('/api/users', {
  schema: {
    response: {
      200: Type.Array(UserSchema)
    }
  }
}, async (request, reply) => {
  return []
})

fastify.post('/api/users', {
  schema: {
    body: Type.Omit(UserSchema, ['id']),
    response: {
      201: UserSchema
    }
  }
}, async (request, reply) => {
  const user = {
    id: crypto.randomUUID(),
    ...request.body
  }
  reply.code(201).send(user)
})

export default fastify
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import fastify from './app'

const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' })
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}

start()
`
          },
          {
            type: 'dependency',
            packages: {
              'fastify': '^4.0.0',
              '@fastify/cors': '^8.0.0',
              '@fastify/helmet': '^11.0.0',
              '@fastify/type-provider-typebox': '^3.0.0',
              '@sinclair/typebox': '^0.31.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              'tsx': '^4.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://www.fastify.io/',
        complexity: 'medium',
        tags: ['nodejs', 'fast', 'schema-based', 'typescript']
      },
      {
        name: 'nestjs',
        type: 'backend',
        provider: 'nestjs',
        version: '10.0.0',
        description: 'Progressive Node.js framework for building efficient and scalable server-side applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/main.ts',
            template: `import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Global pipes
  app.useGlobalPipes(new ValidationPipe());
  
  // Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('API Documentation')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('users')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);
  
  await app.listen(3000);
}
bootstrap();
`
          },
          {
            type: 'file-create',
            target: 'src/app.module.ts',
            template: `import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
`
          },
          {
            type: 'file-create',
            target: 'src/users/users.controller.ts',
            template: `import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiOperation({ summary: 'Create user' })
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all users' })
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get user by id' })
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update user' })
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(id, updateUserDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete user' })
  remove(@Param('id') id: string) {
    return this.usersService.remove(id);
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@nestjs/common': '^10.0.0',
              '@nestjs/core': '^10.0.0',
              '@nestjs/platform-express': '^10.0.0',
              '@nestjs/swagger': '^7.0.0',
              'class-transformer': '^0.5.0',
              'class-validator': '^0.14.0',
              'reflect-metadata': '^0.1.0',
              'rxjs': '^7.0.0'
            },
            devDependencies: {
              '@nestjs/cli': '^10.0.0',
              '@nestjs/schematics': '^10.0.0',
              '@nestjs/testing': '^10.0.0',
              '@types/node': '^20.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://nestjs.com/',
        complexity: 'high',
        tags: ['nodejs', 'typescript', 'enterprise', 'decorators', 'dependency-injection']
      },
      {
        name: 'koa',
        type: 'backend',
        provider: 'koa',
        version: '2.0.0',
        description: 'Next generation web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import Koa from 'koa'
import Router from '@koa/router'
import bodyParser from 'koa-bodyparser'
import cors from '@koa/cors'
import logger from 'koa-logger'
import helmet from 'koa-helmet'

const app = new Koa()
const router = new Router()

// Middleware
app.use(helmet())
app.use(cors())
app.use(logger())
app.use(bodyParser())

// Error handling
app.use(async (ctx, next) => {
  try {
    await next()
  } catch (err: any) {
    ctx.status = err.status || 500
    ctx.body = {
      message: err.message,
      error: process.env.NODE_ENV === 'production' ? {} : err
    }
  }
})

// Routes
router.get('/', (ctx) => {
  ctx.body = { message: 'Welcome to Koa!' }
})

router.get('/api/users', (ctx) => {
  ctx.body = { users: [] }
})

router.post('/api/users', (ctx) => {
  const user = ctx.request.body
  ctx.status = 201
  ctx.body = { user }
})

app.use(router.routes()).use(router.allowedMethods())

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import app from './app'

const PORT = process.env.PORT || 3000

app.listen(PORT, () => {
  console.log(\`Server is running on port \${PORT}\`)
})
`
          },
          {
            type: 'dependency',
            packages: {
              'koa': '^2.0.0',
              '@koa/router': '^12.0.0',
              '@koa/cors': '^5.0.0',
              'koa-bodyparser': '^4.0.0',
              'koa-helmet': '^7.0.0',
              'koa-logger': '^3.0.0'
            },
            devDependencies: {
              '@types/koa': '^2.0.0',
              '@types/koa__router': '^12.0.0',
              '@types/koa-bodyparser': '^4.0.0',
              '@types/koa-logger': '^3.0.0',
              '@types/node': '^20.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://koajs.com/',
        complexity: 'medium',
        tags: ['nodejs', 'async', 'middleware', 'minimalist']
      },

      // Authentication
      {
        name: 'better-auth',
        type: 'auth',
        provider: 'better-auth',
        version: '1.0.0',
        description: 'Modern authentication library for TypeScript',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth.ts',
            template: `import { betterAuth } from 'better-auth';
import { prismaAdapter } from '@better-auth/prisma-adapter';
import { prisma } from './prisma';

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: '{{database}}'
  }),
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: {{config.requireEmailVerification}}
  },
  socialProviders: {
    {{#if config.providers.google}}
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!
    },
    {{/if}}
    {{#if config.providers.github}}
    github: {
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!
    }
    {{/if}}
  }
});

export type Auth = typeof auth;`,
            priority: 100
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "better-auth": "^1.0.0",
    "@better-auth/prisma-adapter": "^1.0.0"
  }
}`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'BETTER_AUTH_SECRET',
            description: 'Secret key for Better Auth',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'BETTER_AUTH_URL',
            description: 'URL for Better Auth',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          }
        ],
        dependencies: [
          {
            serviceType: 'database',
            required: true
          }
        ],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Configure authentication providers in .env file'
          },
          {
            type: 'command',
            description: 'Generate Prisma schema for auth tables',
            command: 'npx prisma generate'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: ['postgresql', 'mysql', 'sqlite'],
        platforms: ['web'],
        tags: ['authentication', 'security', 'user-management']
      },

      // Database - PostgreSQL
      {
        name: 'postgresql',
        type: 'database',
        provider: 'postgresql',
        version: '16.0.0',
        description: 'PostgreSQL database with Prisma ORM',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'PostgreSQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'postgresql://user:password@localhost:5432/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up PostgreSQL database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'orm', 'prisma']
      },

      // Database - MySQL
      {
        name: 'mysql',
        type: 'database',
        provider: 'mysql',
        version: '8.0.0',
        description: 'MySQL relational database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'MySQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mysql://user:password@localhost:3306/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up MySQL database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'mysql', 'orm', 'prisma']
      },

      // Database - MongoDB
      {
        name: 'mongodb',
        type: 'database',
        provider: 'mongodb',
        version: '7.0.0',
        description: 'MongoDB NoSQL database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/mongodb.ts',
            template: `import { MongoClient, Db, Collection } from 'mongodb';

const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const dbName = process.env.MONGODB_DB || 'myapp';

let cachedClient: MongoClient | null = null;
let cachedDb: Db | null = null;

export async function connectToDatabase(): Promise<{ client: MongoClient; db: Db }> {
  if (cachedClient && cachedDb) {
    return { client: cachedClient, db: cachedDb };
  }

  const client = new MongoClient(uri);
  await client.connect();

  const db = client.db(dbName);

  cachedClient = client;
  cachedDb = db;

  return { client, db };
}

export async function getCollection<T>(collectionName: string): Promise<Collection<T>> {
  const { db } = await connectToDatabase();
  return db.collection<T>(collectionName);
}

// Helper functions
export async function findOne<T>(collection: string, query: any): Promise<T | null> {
  const col = await getCollection<T>(collection);
  return col.findOne(query);
}

export async function findMany<T>(collection: string, query: any = {}, options: any = {}): Promise<T[]> {
  const col = await getCollection<T>(collection);
  return col.find(query, options).toArray();
}

export async function insertOne<T>(collection: string, document: T): Promise<string> {
  const col = await getCollection<T>(collection);
  const result = await col.insertOne(document as any);
  return result.insertedId.toString();
}

export async function updateOne<T>(collection: string, query: any, update: any): Promise<boolean> {
  const col = await getCollection<T>(collection);
  const result = await col.updateOne(query, { $set: update });
  return result.modifiedCount > 0;
}

export async function deleteOne(collection: string, query: any): Promise<boolean> {
  const col = await getCollection<any>(collection);
  const result = await col.deleteOne(query);
  return result.deletedCount > 0;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/models/User.ts',
            template: `import { ObjectId } from 'mongodb';
import { findOne, insertOne, updateOne } from '@/lib/mongodb';

export interface User {
  _id?: ObjectId;
  email: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
}

export class UserModel {
  static collection = 'users';

  static async findById(id: string): Promise<User | null> {
    return findOne<User>(this.collection, { _id: new ObjectId(id) });
  }

  static async findByEmail(email: string): Promise<User | null> {
    return findOne<User>(this.collection, { email });
  }

  static async create(data: Omit<User, '_id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    const user: User = {
      ...data,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const id = await insertOne(this.collection, user);
    return { ...user, _id: new ObjectId(id) };
  }

  static async update(id: string, data: Partial<User>): Promise<boolean> {
    return updateOne(this.collection, 
      { _id: new ObjectId(id) }, 
      { ...data, updatedAt: new Date() }
    );
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "mongodb": "^6.0.0"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mongodb://localhost:27017'
          },
          {
            name: 'MONGODB_DB',
            description: 'MongoDB database name',
            required: true,
            type: 'string',
            defaultValue: 'myapp'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MongoDB database and update MONGODB_URI'
          },
          {
            type: 'manual',
            description: 'Create indexes for optimal performance'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'nosql', 'mongodb', 'document-store']
      },

      // Database - SQLite
      {
        name: 'sqlite',
        type: 'database',
        provider: 'sqlite',
        version: '3.0.0',
        description: 'SQLite embedded database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'SQLite database file path',
            required: true,
            type: 'string',
            defaultValue: 'file:./dev.db'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'command',
            description: 'Push database schema',
            command: 'npx prisma db push'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'sqlite', 'embedded', 'orm', 'prisma']
      },

      // Database - SQL Server
      {
        name: 'sqlserver',
        type: 'database',
        provider: 'microsoft',
        version: '2022',
        description: 'Microsoft SQL Server database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'SQL Server connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'sqlserver://localhost:1433;database=mydb;user=sa;password=YourPassword;encrypt=true;trustServerCertificate=true'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up SQL Server database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'sqlserver', 'mssql', 'microsoft', 'orm', 'prisma']
      },

      // ORM - Prisma (standalone)
      {
        name: 'prisma',
        type: 'orm',
        provider: 'prisma',
        version: '5.0.0',
        description: 'Next-generation Node.js and TypeScript ORM',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Change this based on your database
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export * from '@prisma/client';`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0",
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:migrate:create": "prisma migrate dev --create-only",
    "db:migrate:deploy": "prisma migrate deploy",
    "db:push": "prisma db push",
    "db:seed": "tsx prisma/seed.ts",
    "db:studio": "prisma studio",
    "db:reset": "prisma migrate reset"
  }
}`,
            priority: 80
          },
          {
            type: 'file-create',
            target: 'prisma/seed.ts',
            template: `import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create sample users
  const user1 = await prisma.user.upsert({
    where: { email: 'alice@example.com' },
    update: {},
    create: {
      email: 'alice@example.com',
      name: 'Alice',
      posts: {
        create: [
          {
            title: 'My first post',
            content: 'This is my first post content',
            published: true
          }
        ]
      }
    }
  });

  const user2 = await prisma.user.upsert({
    where: { email: 'bob@example.com' },
    update: {},
    create: {
      email: 'bob@example.com',
      name: 'Bob',
      posts: {
        create: [
          {
            title: 'Hello World',
            content: 'This is my hello world post',
            published: true
          }
        ]
      }
    }
  });

  console.log({ user1, user2 });
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });`,
            priority: 85
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'Database connection string',
            required: true,
            type: 'url',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Configure your database connection in .env'
          },
          {
            type: 'command',
            description: 'Run initial migration',
            command: 'npx prisma migrate dev --name init'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite', 'sqlserver', 'mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'prisma', 'typescript', 'sql']
      },

      // ORM - Drizzle
      {
        name: 'drizzle',
        type: 'orm',
        provider: 'drizzle-team',
        version: '0.29.0',
        description: 'TypeScript ORM with SQL-like experience',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/db/schema.ts',
            template: `import { pgTable, serial, text, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: text('name'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 255 }).notNull(),
  content: text('content'),
  published: boolean('published').default(false).notNull(),
  authorId: serial('author_id').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts)
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id]
  })
}));

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/db/index.ts',
            template: `import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

const connectionString = process.env.DATABASE_URL!;
const sql = postgres(connectionString);

export const db = drizzle(sql, { schema });

export * from './schema';`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'drizzle.config.ts',
            template: `import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema.ts',
  out: './drizzle',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  verbose: true,
  strict: true,
} satisfies Config;`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "drizzle-orm": "^0.29.0",
    "postgres": "^3.4.0"
  },
  "devDependencies": {
    "drizzle-kit": "^0.20.0",
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:generate": "drizzle-kit generate:pg",
    "db:push": "drizzle-kit push:pg",
    "db:drop": "drizzle-kit drop",
    "db:pull": "drizzle-kit introspect:pg",
    "db:studio": "drizzle-kit studio",
    "db:check": "drizzle-kit check:pg"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'PostgreSQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'postgresql://user:password@localhost:5432/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate SQL migrations',
            command: 'npm run db:generate'
          },
          {
            type: 'command',
            description: 'Push schema to database',
            command: 'npm run db:push'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'drizzle', 'typescript', 'sql']
      },

      // ORM - TypeORM
      {
        name: 'typeorm',
        type: 'orm',
        provider: 'typeorm',
        version: '0.3.0',
        description: 'TypeScript ORM for SQL and NoSQL databases',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/entities/User.ts',
            template: `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';
import { Post } from './Post';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column({ nullable: true })
  name: string;

  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/entities/Post.ts',
            template: `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column({ type: 'text', nullable: true })
  content: string;

  @Column({ default: false })
  published: boolean;

  @ManyToOne(() => User, (user) => user.posts, { nullable: true })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Column({ nullable: true })
  authorId: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/data-source.ts',
            template: `import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from './entities/User';
import { Post } from './entities/Post';

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  username: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_NAME || 'mydb',
  synchronize: process.env.NODE_ENV === 'development',
  logging: process.env.NODE_ENV === 'development',
  entities: [User, Post],
  migrations: ['src/migrations/*.ts'],
  subscribers: [],
});

// Initialize connection
export async function initializeDatabase() {
  try {
    await AppDataSource.initialize();
    console.log('Data Source has been initialized!');
  } catch (err) {
    console.error('Error during Data Source initialization:', err);
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "typeorm": "^0.3.0",
    "reflect-metadata": "^0.1.13",
    "pg": "^8.11.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "typeorm": "typeorm-ts-node-commonjs",
    "db:create": "typeorm migration:create",
    "db:generate": "typeorm migration:generate -d src/data-source.ts",
    "db:run": "typeorm migration:run -d src/data-source.ts",
    "db:revert": "typeorm migration:revert -d src/data-source.ts",
    "db:drop": "typeorm schema:drop -d src/data-source.ts",
    "db:sync": "typeorm schema:sync -d src/data-source.ts"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DB_HOST',
            description: 'Database host',
            required: true,
            type: 'string',
            defaultValue: 'localhost'
          },
          {
            name: 'DB_PORT',
            description: 'Database port',
            required: true,
            type: 'number',
            defaultValue: '5432'
          },
          {
            name: 'DB_USER',
            description: 'Database user',
            required: true,
            type: 'string'
          },
          {
            name: 'DB_PASSWORD',
            description: 'Database password',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'DB_NAME',
            description: 'Database name',
            required: true,
            type: 'string'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'manual',
            description: 'Configure database connection in .env'
          },
          {
            type: 'command',
            description: 'Run migrations',
            command: 'npm run db:run'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite', 'sqlserver', 'mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'typeorm', 'typescript', 'decorators']
      },

      // ORM - Mongoose (for MongoDB)
      {
        name: 'mongoose',
        type: 'orm',
        provider: 'mongoose',
        version: '8.0.0',
        description: 'MongoDB object modeling for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/models/User.ts',
            template: `import { Schema, model, Document } from 'mongoose';

export interface IUser extends Document {
  email: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true
    },
    name: {
      type: String,
      trim: true
    }
  },
  {
    timestamps: true
  }
);

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });

// Virtual for user's full info
userSchema.virtual('displayName').get(function() {
  return this.name || this.email;
});

// Instance methods
userSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.__v;
  return obj;
};

export const User = model<IUser>('User', userSchema);`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/models/Post.ts',
            template: `import { Schema, model, Document, Types } from 'mongoose';

export interface IPost extends Document {
  title: string;
  content?: string;
  published: boolean;
  author?: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const postSchema = new Schema<IPost>(
  {
    title: {
      type: String,
      required: true,
      trim: true
    },
    content: {
      type: String
    },
    published: {
      type: Boolean,
      default: false
    },
    author: {
      type: Schema.Types.ObjectId,
      ref: 'User'
    }
  },
  {
    timestamps: true
  }
);

// Indexes
postSchema.index({ title: 'text', content: 'text' });
postSchema.index({ author: 1, createdAt: -1 });
postSchema.index({ published: 1 });

// Virtual for excerpt
postSchema.virtual('excerpt').get(function() {
  if (!this.content) return '';
  return this.content.substring(0, 150) + '...';
});

// Pre-save middleware
postSchema.pre('save', function(next) {
  // Add any pre-save logic here
  next();
});

export const Post = model<IPost>('Post', postSchema);`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/mongoose.ts',
            template: `import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/myapp';

/**
 * Global is used here to maintain a cached connection across hot reloads
 * in development. This prevents connections growing exponentially
 * during API Route usage.
 */
declare global {
  var mongoose: {
    conn: typeof mongoose | null;
    promise: Promise<typeof mongoose> | null;
  };
}

let cached = global.mongoose || { conn: null, promise: null };

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

export async function connectDB() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default connectDB;`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "mongoose": "^8.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:seed": "tsx src/scripts/seed.ts"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mongodb://localhost:27017/myapp'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'manual',
            description: 'Ensure MongoDB is running'
          },
          {
            type: 'manual',
            description: 'Configure connection string in .env'
          }
        ],
        frameworks: [],
        databases: ['mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'odm', 'database', 'mongodb', 'mongoose', 'nosql']
      },

      // Payments - Stripe
      {
        name: 'stripe',
        type: 'payments',
        provider: 'stripe',
        version: '16.0.0',
        description: 'Stripe payment processing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/stripe.ts',
            template: `import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-12-18.acacia',
  typescript: true
});

export async function createCheckoutSession(params: {
  priceId: string;
  customerId?: string;
  successUrl: string;
  cancelUrl: string;
}) {
  return stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    line_items: [{
      price: params.priceId,
      quantity: 1
    }],
    mode: 'subscription',
    success_url: params.successUrl,
    cancel_url: params.cancelUrl,
    customer: params.customerId
  });
}

export async function createCustomer(params: {
  email: string;
  name?: string;
}) {
  return stripe.customers.create({
    email: params.email,
    name: params.name
  });
}`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "stripe": "^16.0.0"
  }
}`,
            priority: 75
          }
        ],
        envVariables: [
          {
            name: 'STRIPE_SECRET_KEY',
            description: 'Stripe secret key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'STRIPE_PUBLISHABLE_KEY',
            description: 'Stripe publishable key',
            required: true,
            type: 'string'
          },
          {
            name: 'STRIPE_WEBHOOK_SECRET',
            description: 'Stripe webhook secret',
            required: false,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Stripe account and add API keys to .env'
          },
          {
            type: 'manual',
            description: 'Configure Stripe webhooks for subscription events'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['payments', 'billing', 'subscriptions', 'stripe']
      },

      // Email - Resend
      {
        name: 'resend',
        type: 'email',
        provider: 'resend',
        version: '3.0.0',
        description: 'Modern email API for developers',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/email.ts',
            template: `import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY!);

export async function sendEmail({
  to,
  subject,
  html,
  text,
  from = process.env.EMAIL_FROM || 'noreply@example.com'
}: {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
}) {
  try {
    const { data, error } = await resend.emails.send({
      from,
      to,
      subject,
      html,
      text
    });

    if (error) {
      console.error('Email send error:', error);
      throw error;
    }

    return data;
  } catch (error) {
    console.error('Failed to send email:', error);
    throw error;
  }
}

export async function sendWelcomeEmail(email: string, name: string) {
  return sendEmail({
    to: email,
    subject: 'Welcome to {{name}}!',
    html: \`
      <h1>Welcome, \${name}!</h1>
      <p>Thanks for signing up. We're excited to have you on board.</p>
    \`
  });
}`,
            priority: 70,
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "resend": "^3.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'RESEND_API_KEY',
            description: 'Resend API key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'EMAIL_FROM',
            description: 'Default from email address',
            required: false,
            type: 'string',
            defaultValue: 'noreply@example.com'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Sign up for Resend and get your API key'
          },
          {
            type: 'manual',
            description: 'Verify your domain in Resend dashboard'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['email', 'transactional', 'notifications']
      },

      // Analytics - PostHog
      {
        name: 'posthog',
        type: 'analytics',
        provider: 'posthog',
        version: '1.0.0',
        description: 'Open-source product analytics',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/analytics.ts',
            template: `import posthog from 'posthog-js';

let posthogClient: ReturnType<typeof posthog.init> | null = null;

export function initAnalytics() {
  if (typeof window === 'undefined') return;
  if (posthogClient) return posthogClient;

  posthogClient = posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
    api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST || 'https://app.posthog.com',
    loaded: (posthog) => {
      if (process.env.NODE_ENV === 'development') posthog.debug();
    }
  });

  return posthogClient;
}

export function trackEvent(event: string, properties?: Record<string, any>) {
  if (!posthogClient) initAnalytics();
  posthogClient?.capture(event, properties);
}

export function identifyUser(userId: string, properties?: Record<string, any>) {
  if (!posthogClient) initAnalytics();
  posthogClient?.identify(userId, properties);
}

export function resetUser() {
  if (!posthogClient) initAnalytics();
  posthogClient?.reset();
}`,
            priority: 60
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "posthog-js": "^1.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_POSTHOG_KEY',
            description: 'PostHog project API key',
            required: true,
            type: 'string',
            sensitive: false
          },
          {
            name: 'NEXT_PUBLIC_POSTHOG_HOST',
            description: 'PostHog API host',
            required: false,
            type: 'url',
            defaultValue: 'https://app.posthog.com'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create a PostHog account and get your project API key'
          },
          {
            type: 'manual',
            description: 'Initialize analytics in your app entry point'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'react', 'vue'],
        databases: [],
        platforms: ['web'],
        tags: ['analytics', 'tracking', 'product-analytics']
      },

      // Monitoring - Sentry
      {
        name: 'sentry',
        type: 'monitoring',
        provider: 'sentry',
        version: '7.0.0',
        description: 'Error tracking and performance monitoring',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/monitoring.ts',
            template: `import * as Sentry from '@sentry/nextjs';

export function initSentry() {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    debug: process.env.NODE_ENV === 'development',
    integrations: [
      new Sentry.BrowserTracing(),
      new Sentry.Replay({
        maskAllText: false,
        blockAllMedia: false
      })
    ],
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0
  });
}

export function captureError(error: Error, context?: Record<string, any>) {
  Sentry.captureException(error, {
    extra: context
  });
}

export function captureMessage(message: string, level: 'info' | 'warning' | 'error' = 'info') {
  Sentry.captureMessage(message, level);
}

export function setUser(user: { id: string; email?: string; username?: string }) {
  Sentry.setUser(user);
}

export function clearUser() {
  Sentry.setUser(null);
}`,
            priority: 50
          },
          {
            type: 'file-create',
            target: 'sentry.client.config.ts',
            template: `import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: false,
  replaysOnErrorSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  integrations: [
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
});`,
            priority: 50
          },
          {
            type: 'file-create',
            target: 'sentry.server.config.ts',
            template: `import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: false,
});`,
            priority: 50
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "@sentry/nextjs": "^7.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'SENTRY_DSN',
            description: 'Sentry Data Source Name',
            required: true,
            type: 'url',
            sensitive: true
          },
          {
            name: 'SENTRY_ORG',
            description: 'Sentry organization slug',
            required: false,
            type: 'string'
          },
          {
            name: 'SENTRY_PROJECT',
            description: 'Sentry project slug',
            required: false,
            type: 'string'
          },
          {
            name: 'SENTRY_AUTH_TOKEN',
            description: 'Sentry authentication token for source maps',
            required: false,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create a Sentry account and project'
          },
          {
            type: 'manual',
            description: 'Configure Sentry in your next.config.js'
          },
          {
            type: 'command',
            description: 'Install Sentry wizard',
            command: 'npx @sentry/wizard@latest -i nextjs'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['monitoring', 'error-tracking', 'performance', 'observability']
      },

      // Cache - Redis
      {
        name: 'redis',
        type: 'cache',
        provider: 'redis',
        version: '4.0.0',
        description: 'In-memory data structure store',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/cache.ts',
            template: `import { createClient } from 'redis';

let redisClient: ReturnType<typeof createClient> | null = null;

export async function getRedisClient() {
  if (redisClient) return redisClient;

  redisClient = createClient({
    url: process.env.REDIS_URL
  });

  redisClient.on('error', (err) => console.error('Redis Client Error', err));
  
  await redisClient.connect();
  
  return redisClient;
}

export async function cacheGet<T>(key: string): Promise<T | null> {
  try {
    const client = await getRedisClient();
    const value = await client.get(key);
    return value ? JSON.parse(value) : null;
  } catch (error) {
    console.error('Cache get error:', error);
    return null;
  }
}

export async function cacheSet(
  key: string, 
  value: any, 
  expirationSeconds?: number
): Promise<void> {
  try {
    const client = await getRedisClient();
    const stringValue = JSON.stringify(value);
    
    if (expirationSeconds) {
      await client.setEx(key, expirationSeconds, stringValue);
    } else {
      await client.set(key, stringValue);
    }
  } catch (error) {
    console.error('Cache set error:', error);
  }
}

export async function cacheDelete(key: string): Promise<void> {
  try {
    const client = await getRedisClient();
    await client.del(key);
  } catch (error) {
    console.error('Cache delete error:', error);
  }
}

export async function cacheFlush(): Promise<void> {
  try {
    const client = await getRedisClient();
    await client.flushAll();
  } catch (error) {
    console.error('Cache flush error:', error);
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "redis": "^4.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'REDIS_URL',
            description: 'Redis connection URL',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'redis://localhost:6379'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Redis server locally or use a cloud service'
          },
          {
            type: 'manual',
            description: 'Update REDIS_URL with your connection string'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['cache', 'redis', 'performance', 'session-store']
      },

      // Storage - AWS S3
      {
        name: 'aws-s3',
        type: 'storage',
        provider: 's3',
        version: '3.0.0',
        description: 'AWS S3 object storage',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/storage.ts',
            template: `import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  }
});

const BUCKET_NAME = process.env.S3_BUCKET_NAME!;

export async function uploadFile(
  key: string,
  body: Buffer | Uint8Array | string,
  contentType?: string
) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: body,
    ContentType: contentType
  });

  return s3Client.send(command);
}

export async function getFile(key: string) {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return s3Client.send(command);
}

export async function deleteFile(key: string) {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return s3Client.send(command);
}

export async function getSignedUploadUrl(
  key: string,
  expiresIn: number = 3600
) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return getSignedUrl(s3Client, command, { expiresIn });
}

export async function getSignedDownloadUrl(
  key: string,
  expiresIn: number = 3600
) {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return getSignedUrl(s3Client, command, { expiresIn });
}`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/s3-request-presigner": "^3.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'AWS_ACCESS_KEY_ID',
            description: 'AWS Access Key ID',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'AWS_SECRET_ACCESS_KEY',
            description: 'AWS Secret Access Key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'AWS_REGION',
            description: 'AWS Region',
            required: false,
            type: 'string',
            defaultValue: 'us-east-1'
          },
          {
            name: 'S3_BUCKET_NAME',
            description: 'S3 Bucket Name',
            required: true,
            type: 'string'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create an S3 bucket in AWS Console'
          },
          {
            type: 'manual',
            description: 'Create IAM user with S3 access and get credentials'
          },
          {
            type: 'manual',
            description: 'Configure CORS settings for your S3 bucket if needed'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['storage', 's3', 'aws', 'files', 'uploads']
      },

      // Storage - Cloudinary
      {
        name: 'cloudinary',
        type: 'storage',
        provider: 'cloudinary',
        version: '2.0.0',
        description: 'Cloudinary image and video management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/cloudinary.ts',
            template: `import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

export async function uploadImage(
  filePath: string,
  options?: {
    folder?: string;
    publicId?: string;
    transformation?: any[];
  }
) {
  return cloudinary.uploader.upload(filePath, {
    folder: options?.folder || 'uploads',
    public_id: options?.publicId,
    transformation: options?.transformation
  });
}

export async function uploadVideo(
  filePath: string,
  options?: {
    folder?: string;
    publicId?: string;
    transformation?: any[];
  }
) {
  return cloudinary.uploader.upload(filePath, {
    resource_type: 'video',
    folder: options?.folder || 'videos',
    public_id: options?.publicId,
    transformation: options?.transformation
  });
}

export async function deleteAsset(publicId: string, resourceType: 'image' | 'video' = 'image') {
  return cloudinary.uploader.destroy(publicId, {
    resource_type: resourceType
  });
}

export function getOptimizedUrl(
  publicId: string,
  options?: {
    width?: number;
    height?: number;
    quality?: number | 'auto';
    format?: string | 'auto';
    crop?: string;
  }
) {
  return cloudinary.url(publicId, {
    width: options?.width,
    height: options?.height,
    quality: options?.quality || 'auto',
    format: options?.format || 'auto',
    crop: options?.crop || 'limit',
    secure: true
  });
}

export function getVideoThumbnail(publicId: string, options?: any) {
  return cloudinary.url(publicId, {
    resource_type: 'video',
    transformation: [
      { width: options?.width || 400, crop: 'limit' },
      { start_offset: options?.offset || '0' }
    ]
  });
}`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "cloudinary": "^2.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'CLOUDINARY_CLOUD_NAME',
            description: 'Cloudinary Cloud Name',
            required: true,
            type: 'string'
          },
          {
            name: 'CLOUDINARY_API_KEY',
            description: 'Cloudinary API Key',
            required: true,
            type: 'string'
          },
          {
            name: 'CLOUDINARY_API_SECRET',
            description: 'Cloudinary API Secret',
            required: true,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Sign up for Cloudinary and get your credentials'
          },
          {
            type: 'manual',
            description: 'Configure upload presets in Cloudinary dashboard'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['storage', 'cloudinary', 'images', 'video', 'media']
      },

      // Queue - BullMQ
      {
        name: 'bullmq',
        type: 'queue',
        provider: 'bullmq',
        version: '5.0.0',
        description: 'BullMQ job queue with Redis backend',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/queue.ts',
            template: `import { Queue, Worker, QueueEvents } from 'bullmq';
import { Redis } from 'ioredis';

const connection = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  maxRetriesPerRequest: null
});

// Define queue names
export const QUEUE_NAMES = {
  EMAIL: 'email',
  IMAGE_PROCESSING: 'image-processing',
  DATA_IMPORT: 'data-import',
  NOTIFICATIONS: 'notifications'
} as const;

// Create queues
export const emailQueue = new Queue(QUEUE_NAMES.EMAIL, { connection });
export const imageQueue = new Queue(QUEUE_NAMES.IMAGE_PROCESSING, { connection });
export const dataQueue = new Queue(QUEUE_NAMES.DATA_IMPORT, { connection });
export const notificationQueue = new Queue(QUEUE_NAMES.NOTIFICATIONS, { connection });

// Queue events for monitoring
export const emailQueueEvents = new QueueEvents(QUEUE_NAMES.EMAIL, { connection });
export const imageQueueEvents = new QueueEvents(QUEUE_NAMES.IMAGE_PROCESSING, { connection });

// Helper function to add job with defaults
export async function addJob<T>(
  queue: Queue,
  name: string,
  data: T,
  options?: {
    delay?: number;
    attempts?: number;
    backoff?: { type: 'exponential' | 'fixed'; delay: number };
    removeOnComplete?: boolean | number;
    removeOnFail?: boolean | number;
  }
) {
  return queue.add(name, data, {
    attempts: options?.attempts || 3,
    backoff: options?.backoff || { type: 'exponential', delay: 2000 },
    removeOnComplete: options?.removeOnComplete ?? 100,
    removeOnFail: options?.removeOnFail ?? 50,
    delay: options?.delay
  });
}

// Get queue metrics
export async function getQueueMetrics(queue: Queue) {
  const [waiting, active, completed, failed, delayed, paused] = await Promise.all([
    queue.getWaitingCount(),
    queue.getActiveCount(),
    queue.getCompletedCount(),
    queue.getFailedCount(),
    queue.getDelayedCount(),
    queue.getPausedCount()
  ]);

  return {
    waiting,
    active,
    completed,
    failed,
    delayed,
    paused,
    total: waiting + active + delayed + paused
  };
}

// Clean old jobs
export async function cleanQueue(queue: Queue, grace: number = 3600000) {
  await queue.clean(grace, 100, 'completed');
  await queue.clean(grace, 100, 'failed');
}`,
            priority: 80
          },
          {
            type: 'file-create',
            target: 'src/workers/email.worker.ts',
            template: `import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { QUEUE_NAMES } from '../lib/queue.js';
// Import your email service
// import { sendEmail } from '../lib/email.js';

const connection = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  maxRetriesPerRequest: null
});

export const emailWorker = new Worker(
  QUEUE_NAMES.EMAIL,
  async (job: Job) => {
    const { to, subject, html, text } = job.data;
    
    console.log(\`Processing email job \${job.id}: \${subject} to \${to}\`);
    
    // Send email using your email service
    // await sendEmail({ to, subject, html, text });
    
    // Simulate email sending
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return { sent: true, timestamp: new Date() };
  },
  {
    connection,
    concurrency: 5,
    limiter: {
      max: 10,
      duration: 1000 // Max 10 jobs per second
    }
  }
);

emailWorker.on('completed', (job) => {
  console.log(\`Email job \${job.id} completed\`);
});

emailWorker.on('failed', (job, err) => {
  console.error(\`Email job \${job?.id} failed:\`, err);
});

console.log('Email worker started');`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "bullmq": "^5.0.0",
    "ioredis": "^5.0.0"
  },
  "scripts": {
    "worker:email": "tsx src/workers/email.worker.ts",
    "workers": "concurrently \\"npm:worker:*\\""
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'REDIS_URL',
            description: 'Redis connection URL for BullMQ',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'redis://localhost:6379'
          }
        ],
        dependencies: [
          {
            serviceType: 'cache',
            provider: 'redis',
            required: true
          }
        ],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Ensure Redis is running for BullMQ'
          },
          {
            type: 'manual',
            description: 'Create additional workers for other queues as needed'
          },
          {
            type: 'command',
            description: 'Install concurrently for running multiple workers',
            command: 'npm install -D concurrently'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['queue', 'jobs', 'background', 'bullmq', 'redis']
      },

      // Realtime - Socket.io
      {
        name: 'socket.io',
        type: 'realtime',
        provider: 'socket.io',
        version: '4.0.0',
        description: 'Socket.io for real-time bidirectional communication',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/socket-server.ts',
            template: `import { Server } from 'socket.io';
import { createServer } from 'http';
import type { Server as HTTPServer } from 'http';
import type { Express } from 'express';

let io: Server | null = null;

export function initializeSocketServer(
  app?: Express,
  httpServer?: HTTPServer
) {
  const server = httpServer || createServer(app);
  
  io = new Server(server, {
    cors: {
      origin: process.env.CLIENT_URL || 'http://localhost:3000',
      credentials: true
    },
    transports: ['websocket', 'polling']
  });

  io.on('connection', (socket) => {
    console.log(\`Client connected: \${socket.id}\`);

    // Join user to their personal room
    socket.on('join-room', (roomId: string) => {
      socket.join(roomId);
      console.log(\`Socket \${socket.id} joined room \${roomId}\`);
    });

    // Leave room
    socket.on('leave-room', (roomId: string) => {
      socket.leave(roomId);
      console.log(\`Socket \${socket.id} left room \${roomId}\`);
    });

    // Handle messages
    socket.on('message', async (data: {
      room: string;
      message: string;
      userId: string;
    }) => {
      // Broadcast to room
      io?.to(data.room).emit('new-message', {
        id: Date.now().toString(),
        message: data.message,
        userId: data.userId,
        timestamp: new Date()
      });
    });

    // Handle typing indicators
    socket.on('typing', (data: { room: string; userId: string }) => {
      socket.to(data.room).emit('user-typing', {
        userId: data.userId,
        typing: true
      });
    });

    socket.on('stop-typing', (data: { room: string; userId: string }) => {
      socket.to(data.room).emit('user-typing', {
        userId: data.userId,
        typing: false
      });
    });

    // Handle presence
    socket.on('user-online', (userId: string) => {
      socket.broadcast.emit('user-status', {
        userId,
        status: 'online'
      });
    });

    socket.on('disconnect', () => {
      console.log(\`Client disconnected: \${socket.id}\`);
    });
  });

  return { server, io };
}

// Helper functions for server-side emissions
export function emitToRoom(room: string, event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.to(room).emit(event, data);
}

export function emitToUser(userId: string, event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.to(\`user:\${userId}\`).emit(event, data);
}

export function broadcastToAll(event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.emit(event, data);
}

export { io };`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/lib/socket-client.ts',
            template: `import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;

export function initializeSocket(userId?: string) {
  if (socket?.connected) {
    return socket;
  }

  socket = io(process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:3001', {
    transports: ['websocket', 'polling'],
    autoConnect: true
  });

  socket.on('connect', () => {
    console.log('Connected to socket server');
    
    if (userId) {
      socket?.emit('user-online', userId);
      socket?.emit('join-room', \`user:\${userId}\`);
    }
  });

  socket.on('disconnect', () => {
    console.log('Disconnected from socket server');
  });

  socket.on('error', (error) => {
    console.error('Socket error:', error);
  });

  return socket;
}

export function joinRoom(roomId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('join-room', roomId);
}

export function leaveRoom(roomId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('leave-room', roomId);
}

export function sendMessage(room: string, message: string, userId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('message', { room, message, userId });
}

export function startTyping(room: string, userId: string) {
  if (!socket?.connected) return;
  socket.emit('typing', { room, userId });
}

export function stopTyping(room: string, userId: string) {
  if (!socket?.connected) return;
  socket.emit('stop-typing', { room, userId });
}

export function onMessage(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('new-message', callback);
}

export function onUserTyping(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('user-typing', callback);
}

export function onUserStatus(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('user-status', callback);
}

export function disconnectSocket() {
  if (socket) {
    socket.disconnect();
    socket = null;
  }
}

export { socket };`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "socket.io": "^4.0.0",
    "socket.io-client": "^4.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'SOCKET_PORT',
            description: 'Port for Socket.io server',
            required: false,
            type: 'number',
            defaultValue: '3001'
          },
          {
            name: 'CLIENT_URL',
            description: 'Client URL for CORS',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          },
          {
            name: 'NEXT_PUBLIC_SOCKET_URL',
            description: 'Socket server URL for client',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:3001'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Socket.io server (standalone or with your HTTP server)'
          },
          {
            type: 'manual',
            description: 'Configure authentication middleware for Socket.io'
          },
          {
            type: 'manual',
            description: 'Implement room-based logic for your use case'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express'],
        databases: [],
        platforms: ['web'],
        tags: ['realtime', 'websocket', 'socket.io', 'chat', 'notifications']
      },

      // Realtime - Pusher
      {
        name: 'pusher',
        type: 'realtime',
        provider: 'pusher',
        version: '5.0.0',
        description: 'Pusher Channels for real-time features',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/pusher-server.ts',
            template: `import Pusher from 'pusher';

export const pusherServer = new Pusher({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.NEXT_PUBLIC_PUSHER_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  useTLS: true
});

// Trigger an event to a channel
export async function triggerEvent(
  channel: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(channel, event, data);
}

// Trigger to multiple channels
export async function triggerBatch(
  channels: string[],
  event: string,
  data: any
) {
  return pusherServer.trigger(channels, event, data);
}

// Trigger to a private channel
export async function triggerPrivate(
  userId: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(\`private-user-\${userId}\`, event, data);
}

// Trigger to a presence channel
export async function triggerPresence(
  channelName: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(\`presence-\${channelName}\`, event, data);
}

// Authenticate private/presence channels
export function authenticateChannel(
  socketId: string,
  channel: string,
  presenceData?: {
    user_id: string;
    user_info?: Record<string, any>;
  }
) {
  if (channel.startsWith('presence-') && presenceData) {
    return pusherServer.authorizeChannel(socketId, channel, presenceData);
  }
  
  return pusherServer.authorizeChannel(socketId, channel);
}

// Get channel info
export async function getChannelInfo(channel: string) {
  return pusherServer.get({
    path: \`/channels/\${channel}\`,
    params: { info: 'subscription_count,user_count' }
  });
}

// Get all channels
export async function getChannels() {
  return pusherServer.get({
    path: '/channels',
    params: {}
  });
}`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/lib/pusher-client.ts',
            template: `import Pusher from 'pusher-js';

let pusherClient: Pusher | null = null;

export function initializePusher(userId?: string) {
  if (pusherClient) {
    return pusherClient;
  }

  pusherClient = new Pusher(process.env.NEXT_PUBLIC_PUSHER_KEY!, {
    cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
    authEndpoint: '/api/pusher/auth',
    auth: {
      params: { user_id: userId }
    }
  });

  // Enable logging in development
  if (process.env.NODE_ENV === 'development') {
    Pusher.logToConsole = true;
  }

  return pusherClient;
}

export function subscribeToChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(channelName);
}

export function subscribeToPrivateChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(\`private-\${channelName}\`);
}

export function subscribeToPresenceChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(\`presence-\${channelName}\`);
}

export function unsubscribe(channelName: string) {
  if (!pusherClient) return;
  
  pusherClient.unsubscribe(channelName);
}

export function bind(channel: any, event: string, callback: (data: any) => void) {
  channel.bind(event, callback);
}

export function unbind(channel: any, event: string, callback?: (data: any) => void) {
  if (callback) {
    channel.unbind(event, callback);
  } else {
    channel.unbind(event);
  }
}

export function disconnect() {
  if (pusherClient) {
    pusherClient.disconnect();
    pusherClient = null;
  }
}

// Hook for React
export function usePusherEvent(
  channelName: string,
  eventName: string,
  callback: (data: any) => void
) {
  if (typeof window === 'undefined') return;
  
  const channel = subscribeToChannel(channelName);
  
  // Subscribe to event
  bind(channel, eventName, callback);
  
  // Cleanup
  return () => {
    unbind(channel, eventName, callback);
    unsubscribe(channelName);
  };
}

export { pusherClient };`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "pusher": "^5.0.0",
    "pusher-js": "^8.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'PUSHER_APP_ID',
            description: 'Pusher App ID',
            required: true,
            type: 'string'
          },
          {
            name: 'PUSHER_SECRET',
            description: 'Pusher Secret',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'NEXT_PUBLIC_PUSHER_KEY',
            description: 'Pusher Key (public)',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_PUSHER_CLUSTER',
            description: 'Pusher Cluster',
            required: true,
            type: 'string',
            defaultValue: 'eu'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Pusher account and app at pusher.com'
          },
          {
            type: 'manual',
            description: 'Create API endpoint for channel authentication (/api/pusher/auth)'
          },
          {
            type: 'manual',
            description: 'Implement presence channel logic if needed'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['realtime', 'pusher', 'websocket', 'channels', 'presence']
      },

      // CMS - Strapi
      {
        name: 'strapi',
        type: 'cms',
        provider: 'strapi',
        version: '4.0.0',
        description: 'Leading open-source headless CMS',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/strapi.ts',
            template: `import axios from 'axios';

const strapiUrl = process.env.STRAPI_URL || 'http://localhost:1337';
const strapiToken = process.env.STRAPI_API_TOKEN;

const strapiClient = axios.create({
  baseURL: \`\${strapiUrl}/api\`,
  headers: {
    'Authorization': \`Bearer \${strapiToken}\`,
    'Content-Type': 'application/json'
  }
});

export interface StrapiResponse<T> {
  data: T;
  meta: {
    pagination?: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

export async function getEntries<T>(
  contentType: string,
  params?: Record<string, any>
): Promise<StrapiResponse<T[]>> {
  const response = await strapiClient.get(\`/\${contentType}\`, { params });
  return response.data;
}

export async function getEntry<T>(
  contentType: string,
  id: string | number,
  params?: Record<string, any>
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.get(\`/\${contentType}/\${id}\`, { params });
  return response.data;
}

export async function createEntry<T>(
  contentType: string,
  data: any
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.post(\`/\${contentType}\`, { data });
  return response.data;
}

export async function updateEntry<T>(
  contentType: string,
  id: string | number,
  data: any
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.put(\`/\${contentType}/\${id}\`, { data });
  return response.data;
}

export async function deleteEntry(
  contentType: string,
  id: string | number
): Promise<void> {
  await strapiClient.delete(\`/\${contentType}/\${id}\`);
}

export async function uploadFile(file: File): Promise<any> {
  const formData = new FormData();
  formData.append('files', file);

  const response = await strapiClient.post('/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  });

  return response.data;
}

export { strapiClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'STRAPI_URL',
            description: 'Strapi server URL',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:1337'
          },
          {
            name: 'STRAPI_API_TOKEN',
            description: 'Strapi API token',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          axios: '^1.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Strapi backend at https://strapi.io'
          },
          {
            type: 'manual',
            description: 'Create API token in Strapi admin panel'
          },
          {
            type: 'manual',
            description: 'Configure content types and permissions'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'strapi', 'api']
      },

      // CMS - Contentful
      {
        name: 'contentful',
        type: 'cms',
        provider: 'contentful',
        version: '10.0.0',
        description: 'API-first content management platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/contentful.ts',
            template: `import { createClient, Entry, Asset } from 'contentful';

const client = createClient({
  space: process.env.CONTENTFUL_SPACE_ID!,
  accessToken: process.env.CONTENTFUL_ACCESS_TOKEN!,
  environment: process.env.CONTENTFUL_ENVIRONMENT || 'master'
});

const previewClient = createClient({
  space: process.env.CONTENTFUL_SPACE_ID!,
  accessToken: process.env.CONTENTFUL_PREVIEW_TOKEN!,
  environment: process.env.CONTENTFUL_ENVIRONMENT || 'master',
  host: 'preview.contentful.com'
});

export function getClient(preview = false) {
  return preview ? previewClient : client;
}

export interface ContentfulCollection<T> {
  items: T[];
  total: number;
  skip: number;
  limit: number;
}

export async function getEntries<T extends Entry<any>>(
  contentType: string,
  query?: any,
  preview = false
): Promise<ContentfulCollection<T>> {
  const entries = await getClient(preview).getEntries({
    content_type: contentType,
    ...query
  });

  return entries as ContentfulCollection<T>;
}

export async function getEntry<T extends Entry<any>>(
  id: string,
  query?: any,
  preview = false
): Promise<T> {
  const entry = await getClient(preview).getEntry(id, query);
  return entry as T;
}

export async function getAsset(
  id: string,
  preview = false
): Promise<Asset> {
  return await getClient(preview).getAsset(id);
}

export async function getAssets(
  query?: any,
  preview = false
): Promise<ContentfulCollection<Asset>> {
  const assets = await getClient(preview).getAssets(query);
  return assets as ContentfulCollection<Asset>;
}

// Rich text renderer helper
export { documentToReactComponents } from '@contentful/rich-text-react-renderer';
export { BLOCKS, MARKS, INLINES } from '@contentful/rich-text-types';`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'CONTENTFUL_SPACE_ID',
            description: 'Contentful space ID',
            required: true,
            type: 'string'
          },
          {
            name: 'CONTENTFUL_ACCESS_TOKEN',
            description: 'Contentful delivery API token',
            required: true,
            type: 'secret'
          },
          {
            name: 'CONTENTFUL_PREVIEW_TOKEN',
            description: 'Contentful preview API token',
            required: false,
            type: 'secret'
          },
          {
            name: 'CONTENTFUL_ENVIRONMENT',
            description: 'Contentful environment',
            required: false,
            type: 'string',
            defaultValue: 'master'
          }
        ],
        dependencies: {
          contentful: '^10.0.0',
          '@contentful/rich-text-react-renderer': '^15.0.0',
          '@contentful/rich-text-types': '^16.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Contentful space at https://www.contentful.com'
          },
          {
            type: 'manual',
            description: 'Set up content models in Contentful'
          },
          {
            type: 'manual',
            description: 'Generate API tokens from Settings > API keys'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'contentful', 'api']
      },

      // CMS - Sanity
      {
        name: 'sanity',
        type: 'cms',
        provider: 'sanity',
        version: '3.0.0',
        description: 'Platform for structured content',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/sanity/client.ts',
            template: `import { createClient } from '@sanity/client';
import imageUrlBuilder from '@sanity/image-url';

export const sanityClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET || 'production',
  apiVersion: '2024-01-01',
  useCdn: process.env.NODE_ENV === 'production',
  token: process.env.SANITY_API_TOKEN
});

const builder = imageUrlBuilder(sanityClient);

export function urlFor(source: any) {
  return builder.image(source);
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'src/lib/sanity/queries.ts',
            template: `import { groq } from 'next-sanity';

// Example queries
export const postsQuery = groq\`
  *[_type == "post" && defined(slug.current)]{
    _id,
    title,
    slug,
    excerpt,
    mainImage,
    publishedAt,
    "author": author->name
  } | order(publishedAt desc)
\`;

export const postBySlugQuery = groq\`
  *[_type == "post" && slug.current == $slug][0]{
    _id,
    title,
    slug,
    excerpt,
    mainImage,
    body,
    publishedAt,
    "author": author->{
      name,
      image
    }
  }
\`;

export const pagesQuery = groq\`
  *[_type == "page" && defined(slug.current)]{
    _id,
    title,
    slug,
    content
  }
\`;`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'sanity.config.ts',
            template: `import { defineConfig } from 'sanity';
import { deskTool } from 'sanity/desk';
import { visionTool } from '@sanity/vision';
import { schemaTypes } from './sanity/schemas';

export default defineConfig({
  name: 'default',
  title: process.env.NEXT_PUBLIC_SANITY_PROJECT_TITLE || 'My Project',
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET || 'production',
  plugins: [deskTool(), visionTool()],
  schema: {
    types: schemaTypes,
  },
});`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_SANITY_PROJECT_ID',
            description: 'Sanity project ID',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_SANITY_DATASET',
            description: 'Sanity dataset name',
            required: false,
            type: 'string',
            defaultValue: 'production'
          },
          {
            name: 'SANITY_API_TOKEN',
            description: 'Sanity API token (for mutations)',
            required: false,
            type: 'secret'
          },
          {
            name: 'NEXT_PUBLIC_SANITY_PROJECT_TITLE',
            description: 'Sanity studio title',
            required: false,
            type: 'string'
          }
        ],
        dependencies: {
          '@sanity/client': '^6.0.0',
          '@sanity/image-url': '^1.0.0',
          'next-sanity': '^7.0.0',
          sanity: '^3.0.0',
          '@sanity/vision': '^3.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Initialize Sanity studio',
            command: 'npx sanity init'
          },
          {
            type: 'manual',
            description: 'Create schemas in sanity/schemas directory'
          },
          {
            type: 'manual',
            description: 'Deploy Sanity studio with: npx sanity deploy'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'sanity', 'groq']
      },

      // CMS - Payload
      {
        name: 'payload',
        type: 'cms',
        provider: 'payload',
        version: '2.0.0',
        description: 'TypeScript headless CMS',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/payload.config.ts',
            template: `import { buildConfig } from 'payload/config';
import path from 'path';
import Users from './collections/Users';
import Media from './collections/Media';

export default buildConfig({
  serverURL: process.env.PAYLOAD_PUBLIC_SERVER_URL || 'http://localhost:3000',
  admin: {
    user: Users.slug,
    bundler: 'webpack',
  },
  collections: [Users, Media],
  typescript: {
    outputFile: path.resolve(__dirname, 'payload-types.ts'),
  },
  graphQL: {
    schemaOutputFile: path.resolve(__dirname, 'generated-schema.graphql'),
  },
  cors: '*',
  csrf: [
    process.env.PAYLOAD_PUBLIC_SERVER_URL || 'http://localhost:3000',
  ],
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'src/collections/Users.ts',
            template: `import { CollectionConfig } from 'payload/types';

const Users: CollectionConfig = {
  slug: 'users',
  auth: true,
  admin: {
    useAsTitle: 'email',
  },
  fields: [
    {
      name: 'name',
      type: 'text',
      required: true,
    },
    {
      name: 'role',
      type: 'select',
      options: [
        { label: 'Admin', value: 'admin' },
        { label: 'Editor', value: 'editor' },
        { label: 'User', value: 'user' },
      ],
      defaultValue: 'user',
      required: true,
    },
  ],
};

export default Users;`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/collections/Media.ts',
            template: `import { CollectionConfig } from 'payload/types';

const Media: CollectionConfig = {
  slug: 'media',
  upload: {
    staticURL: '/media',
    staticDir: 'media',
    imageSizes: [
      {
        name: 'thumbnail',
        width: 400,
        height: 300,
        position: 'centre',
      },
      {
        name: 'card',
        width: 768,
        height: 1024,
        position: 'centre',
      },
      {
        name: 'tablet',
        width: 1024,
        height: undefined,
        position: 'centre',
      },
    ],
    adminThumbnail: 'thumbnail',
    mimeTypes: ['image/*'],
  },
  fields: [
    {
      name: 'alt',
      type: 'text',
    },
  ],
};

export default Media;`,
            priority: 95
          }
        ],
        envVariables: [
          {
            name: 'PAYLOAD_PUBLIC_SERVER_URL',
            description: 'Payload server URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          },
          {
            name: 'PAYLOAD_SECRET',
            description: 'Payload secret key',
            required: true,
            type: 'secret'
          },
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'connection_string'
          }
        ],
        dependencies: {
          payload: '^2.0.0',
          '@payloadcms/bundler-webpack': '^1.0.0',
          '@payloadcms/db-mongodb': '^1.0.0',
          '@payloadcms/richtext-slate': '^1.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MongoDB database'
          },
          {
            type: 'manual',
            description: 'Create collections in src/collections directory'
          },
          {
            type: 'manual',
            description: 'Configure admin UI and access control'
          }
        ],
        frameworks: ['next', 'express'],
        databases: ['mongodb'],
        platforms: ['web'],
        tags: ['cms', 'headless', 'typescript', 'payload', 'admin']
      },

      // CMS - Ghost
      {
        name: 'ghost',
        type: 'cms',
        provider: 'ghost',
        version: '5.0.0',
        description: 'Professional publishing platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ghost.ts',
            template: `import GhostContentAPI from '@tryghost/content-api';
import GhostAdminAPI from '@tryghost/admin-api';

// Content API for public content
export const ghostContent = new GhostContentAPI({
  url: process.env.GHOST_URL!,
  key: process.env.GHOST_CONTENT_API_KEY!,
  version: 'v5.0'
});

// Admin API for content management (optional)
export const ghostAdmin = process.env.GHOST_ADMIN_API_KEY
  ? new GhostAdminAPI({
      url: process.env.GHOST_URL!,
      key: process.env.GHOST_ADMIN_API_KEY,
      version: 'v5.0'
    })
  : null;

// Helper functions
export async function getPosts(options = {}) {
  return await ghostContent.posts.browse({
    limit: 'all',
    include: ['tags', 'authors'],
    ...options
  });
}

export async function getPost(slug: string) {
  return await ghostContent.posts.read(
    { slug },
    { include: ['tags', 'authors'] }
  );
}

export async function getPages(options = {}) {
  return await ghostContent.pages.browse({
    limit: 'all',
    ...options
  });
}

export async function getPage(slug: string) {
  return await ghostContent.pages.read({ slug });
}

export async function getTags(options = {}) {
  return await ghostContent.tags.browse({
    limit: 'all',
    ...options
  });
}

export async function getAuthors(options = {}) {
  return await ghostContent.authors.browse({
    limit: 'all',
    ...options
  });
}`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'GHOST_URL',
            description: 'Ghost instance URL',
            required: true,
            type: 'url'
          },
          {
            name: 'GHOST_CONTENT_API_KEY',
            description: 'Ghost Content API key',
            required: true,
            type: 'secret'
          },
          {
            name: 'GHOST_ADMIN_API_KEY',
            description: 'Ghost Admin API key (optional)',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          '@tryghost/content-api': '^1.11.0',
          '@tryghost/admin-api': '^1.13.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Ghost instance (self-hosted or Ghost Pro)'
          },
          {
            type: 'manual',
            description: 'Generate API keys from Ghost Admin > Integrations'
          },
          {
            type: 'manual',
            description: 'Configure webhooks for content updates (optional)'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'blog', 'publishing', 'ghost', 'content']
      },

      // Search - Elasticsearch
      {
        name: 'elasticsearch',
        type: 'search',
        provider: 'elasticsearch',
        version: '8.0.0',
        description: 'Distributed search and analytics engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/elasticsearch.ts',
            template: `import { Client } from '@elastic/elasticsearch';

const client = new Client({
  node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
  auth: process.env.ELASTICSEARCH_API_KEY
    ? { apiKey: process.env.ELASTICSEARCH_API_KEY }
    : process.env.ELASTICSEARCH_USERNAME
    ? {
        username: process.env.ELASTICSEARCH_USERNAME,
        password: process.env.ELASTICSEARCH_PASSWORD || ''
      }
    : undefined
});

export interface SearchResult<T = any> {
  hits: {
    total: { value: number; relation: string };
    hits: Array<{
      _id: string;
      _index: string;
      _score: number;
      _source: T;
      highlight?: Record<string, string[]>;
    }>;
  };
  aggregations?: any;
}

export async function search<T = any>(
  index: string,
  query: any,
  options?: {
    from?: number;
    size?: number;
    sort?: any[];
    highlight?: any;
    aggs?: any;
  }
): Promise<SearchResult<T>> {
  const response = await client.search({
    index,
    body: {
      query,
      ...options
    }
  });

  return response.body as SearchResult<T>;
}

export async function index<T = any>(
  index: string,
  id: string,
  document: T,
  refresh?: boolean
): Promise<void> {
  await client.index({
    index,
    id,
    body: document,
    refresh: refresh ? 'true' : undefined
  });
}

export async function bulkIndex<T = any>(
  index: string,
  documents: Array<{ id: string; document: T }>
): Promise<void> {
  const body = documents.flatMap(({ id, document }) => [
    { index: { _index: index, _id: id } },
    document
  ]);

  await client.bulk({ body, refresh: true });
}

export async function deleteDocument(
  index: string,
  id: string
): Promise<void> {
  await client.delete({ index, id });
}

export async function createIndex(
  index: string,
  mappings?: any,
  settings?: any
): Promise<void> {
  await client.indices.create({
    index,
    body: {
      mappings,
      settings
    }
  });
}

export async function deleteIndex(index: string): Promise<void> {
  await client.indices.delete({ index });
}

export { client as elasticsearchClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'ELASTICSEARCH_URL',
            description: 'Elasticsearch cluster URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:9200'
          },
          {
            name: 'ELASTICSEARCH_API_KEY',
            description: 'Elasticsearch API key',
            required: false,
            type: 'secret'
          },
          {
            name: 'ELASTICSEARCH_USERNAME',
            description: 'Elasticsearch username',
            required: false,
            type: 'string'
          },
          {
            name: 'ELASTICSEARCH_PASSWORD',
            description: 'Elasticsearch password',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          '@elastic/elasticsearch': '^8.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Elasticsearch cluster (local or cloud)'
          },
          {
            type: 'manual',
            description: 'Create indices and mappings for your data'
          },
          {
            type: 'manual',
            description: 'Configure authentication and security'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'elasticsearch', 'full-text', 'analytics', 'distributed']
      },

      // Search - Algolia
      {
        name: 'algolia',
        type: 'search',
        provider: 'algolia',
        version: '4.0.0',
        description: 'Hosted search API',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/algolia.ts',
            template: `import algoliasearch from 'algoliasearch';
import { SearchClient, SearchIndex } from 'algoliasearch';

const client: SearchClient = algoliasearch(
  process.env.NEXT_PUBLIC_ALGOLIA_APP_ID!,
  process.env.ALGOLIA_ADMIN_KEY!
);

// Client-side search (read-only)
export const searchClient = algoliasearch(
  process.env.NEXT_PUBLIC_ALGOLIA_APP_ID!,
  process.env.NEXT_PUBLIC_ALGOLIA_SEARCH_KEY!
);

export function getIndex(indexName: string): SearchIndex {
  return client.initIndex(indexName);
}

export interface AlgoliaSearchResult<T = any> {
  hits: T[];
  nbHits: number;
  page: number;
  nbPages: number;
  hitsPerPage: number;
  processingTimeMS: number;
  query: string;
}

export async function search<T = any>(
  indexName: string,
  query: string,
  options?: {
    page?: number;
    hitsPerPage?: number;
    filters?: string;
    facets?: string[];
    attributesToRetrieve?: string[];
    attributesToHighlight?: string[];
  }
): Promise<AlgoliaSearchResult<T>> {
  const index = searchClient.initIndex(indexName);
  const result = await index.search<T>(query, options);
  return result;
}

export async function saveObject<T extends { objectID?: string }>(
  indexName: string,
  object: T
): Promise<string> {
  const index = getIndex(indexName);
  const result = await index.saveObject(object, {
    autoGenerateObjectIDIfNotExist: true
  });
  return result.objectID;
}

export async function saveObjects<T extends { objectID?: string }>(
  indexName: string,
  objects: T[]
): Promise<string[]> {
  const index = getIndex(indexName);
  const result = await index.saveObjects(objects, {
    autoGenerateObjectIDIfNotExist: true
  });
  return result.objectIDs;
}

export async function deleteObject(
  indexName: string,
  objectID: string
): Promise<void> {
  const index = getIndex(indexName);
  await index.deleteObject(objectID);
}

export async function deleteObjects(
  indexName: string,
  objectIDs: string[]
): Promise<void> {
  const index = getIndex(indexName);
  await index.deleteObjects(objectIDs);
}

export async function clearIndex(indexName: string): Promise<void> {
  const index = getIndex(indexName);
  await index.clearObjects();
}

// React InstantSearch components
export { InstantSearch, SearchBox, Hits, Pagination, RefinementList } from 'react-instantsearch';`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_ALGOLIA_APP_ID',
            description: 'Algolia Application ID',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_ALGOLIA_SEARCH_KEY',
            description: 'Algolia Search-Only API Key',
            required: true,
            type: 'secret'
          },
          {
            name: 'ALGOLIA_ADMIN_KEY',
            description: 'Algolia Admin API Key',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          algoliasearch: '^4.0.0',
          'react-instantsearch': '^7.0.0',
          'instantsearch.js': '^4.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Algolia account at https://www.algolia.com'
          },
          {
            type: 'manual',
            description: 'Set up indices and configure searchable attributes'
          },
          {
            type: 'manual',
            description: 'Configure relevance and ranking rules'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['search', 'algolia', 'hosted', 'instant-search', 'facets']
      },

      // Search - MeiliSearch
      {
        name: 'meilisearch',
        type: 'search',
        provider: 'meilisearch',
        version: '1.0.0',
        description: 'Lightning fast search engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/meilisearch.ts',
            template: `import { MeiliSearch, Index, SearchResponse } from 'meilisearch';

const client = new MeiliSearch({
  host: process.env.MEILISEARCH_URL || 'http://localhost:7700',
  apiKey: process.env.MEILISEARCH_API_KEY
});

export function getIndex<T = any>(indexUid: string): Index<T> {
  return client.index<T>(indexUid);
}

export interface MeiliSearchResult<T = any> extends SearchResponse<T> {
  hits: T[];
  offset: number;
  limit: number;
  estimatedTotalHits: number;
  processingTimeMs: number;
  query: string;
}

export async function search<T = any>(
  indexUid: string,
  query: string,
  options?: {
    offset?: number;
    limit?: number;
    filter?: string | string[];
    facets?: string[];
    attributesToRetrieve?: string[];
    attributesToHighlight?: string[];
    attributesToCrop?: string[];
    cropLength?: number;
    sort?: string[];
  }
): Promise<MeiliSearchResult<T>> {
  const index = getIndex<T>(indexUid);
  const result = await index.search(query, options);
  return result as MeiliSearchResult<T>;
}

export async function addDocuments<T extends { id?: string | number }>(
  indexUid: string,
  documents: T[],
  primaryKey?: string
): Promise<void> {
  const index = getIndex<T>(indexUid);
  await index.addDocuments(documents, { primaryKey });
}

export async function updateDocuments<T extends { id?: string | number }>(
  indexUid: string,
  documents: T[]
): Promise<void> {
  const index = getIndex<T>(indexUid);
  await index.updateDocuments(documents);
}

export async function deleteDocument(
  indexUid: string,
  documentId: string | number
): Promise<void> {
  const index = getIndex(indexUid);
  await index.deleteDocument(documentId);
}

export async function deleteDocuments(
  indexUid: string,
  documentIds: (string | number)[]
): Promise<void> {
  const index = getIndex(indexUid);
  await index.deleteDocuments(documentIds);
}

export async function createIndex(
  uid: string,
  options?: { primaryKey?: string }
): Promise<void> {
  await client.createIndex(uid, options);
}

export async function updateIndexSettings(
  indexUid: string,
  settings: {
    searchableAttributes?: string[];
    displayedAttributes?: string[];
    filterableAttributes?: string[];
    sortableAttributes?: string[];
    rankingRules?: string[];
    stopWords?: string[];
    synonyms?: Record<string, string[]>;
  }
): Promise<void> {
  const index = getIndex(indexUid);
  await index.updateSettings(settings);
}

export { client as meilisearchClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'MEILISEARCH_URL',
            description: 'MeiliSearch server URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:7700'
          },
          {
            name: 'MEILISEARCH_API_KEY',
            description: 'MeiliSearch master key',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          meilisearch: '^0.37.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MeiliSearch server (Docker or cloud)'
          },
          {
            type: 'manual',
            description: 'Create indices and configure settings'
          },
          {
            type: 'manual',
            description: 'Set up API keys for production'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'meilisearch', 'typo-tolerant', 'fast', 'self-hosted']
      },

      // Search - Typesense
      {
        name: 'typesense',
        type: 'search',
        provider: 'typesense',
        version: '1.0.0',
        description: 'Fast, typo-tolerant search engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/typesense.ts',
            template: `import Typesense from 'typesense';
import { SearchClient } from 'typesense';

const client = new Typesense.Client({
  nodes: [
    {
      host: process.env.TYPESENSE_HOST || 'localhost',
      port: parseInt(process.env.TYPESENSE_PORT || '8108'),
      protocol: process.env.TYPESENSE_PROTOCOL || 'http'
    }
  ],
  apiKey: process.env.TYPESENSE_API_KEY!,
  connectionTimeoutSeconds: 2
});

export interface TypesenseSearchResult<T = any> {
  found: number;
  hits: Array<{
    document: T;
    highlights: Array<{
      field: string;
      snippet: string;
      value: string;
    }>;
    text_match: number;
  }>;
  facet_counts?: Array<{
    field_name: string;
    counts: Array<{
      count: number;
      highlighted: string;
      value: string;
    }>;
  }>;
  page: number;
  request_params: {
    collection_name: string;
    q: string;
  };
  search_time_ms: number;
}

export async function search<T = any>(
  collection: string,
  query: string,
  options?: {
    query_by: string;
    filter_by?: string;
    sort_by?: string;
    page?: number;
    per_page?: number;
    facet_by?: string;
    include_fields?: string;
    exclude_fields?: string;
    highlight_fields?: string;
    num_typos?: number;
  }
): Promise<TypesenseSearchResult<T>> {
  const searchParameters = {
    q: query,
    query_by: options?.query_by || '*',
    ...options
  };

  const result = await client
    .collections(collection)
    .documents()
    .search(searchParameters);

  return result as TypesenseSearchResult<T>;
}

export async function createDocument<T extends { id?: string }>(
  collection: string,
  document: T
): Promise<T> {
  const result = await client
    .collections(collection)
    .documents()
    .create(document);
  
  return result as T;
}

export async function upsertDocument<T extends { id?: string }>(
  collection: string,
  document: T
): Promise<T> {
  const result = await client
    .collections(collection)
    .documents()
    .upsert(document);
  
  return result as T;
}

export async function deleteDocument(
  collection: string,
  id: string
): Promise<void> {
  await client
    .collections(collection)
    .documents(id)
    .delete();
}

export async function createCollection(schema: {
  name: string;
  fields: Array<{
    name: string;
    type: 'string' | 'int32' | 'int64' | 'float' | 'bool' | 'string[]' | 'int32[]' | 'int64[]' | 'float[]' | 'bool[]' | 'auto';
    facet?: boolean;
    optional?: boolean;
    index?: boolean;
  }>;
  default_sorting_field?: string;
}): Promise<void> {
  await client.collections().create(schema);
}

export async function deleteCollection(name: string): Promise<void> {
  await client.collections(name).delete();
}

export { client as typesenseClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'TYPESENSE_HOST',
            description: 'Typesense server host',
            required: false,
            type: 'string',
            defaultValue: 'localhost'
          },
          {
            name: 'TYPESENSE_PORT',
            description: 'Typesense server port',
            required: false,
            type: 'number',
            defaultValue: '8108'
          },
          {
            name: 'TYPESENSE_PROTOCOL',
            description: 'Typesense server protocol',
            required: false,
            type: 'string',
            defaultValue: 'http'
          },
          {
            name: 'TYPESENSE_API_KEY',
            description: 'Typesense API key',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          typesense: '^1.7.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Typesense server (Docker or Typesense Cloud)'
          },
          {
            type: 'manual',
            description: 'Create collections with schema definitions'
          },
          {
            type: 'manual',
            description: 'Configure search-only API keys for client-side usage'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'typesense', 'typo-tolerant', 'faceted', 'fast']
      },

      // Testing - Jest
      {
        name: 'jest',
        type: 'testing',
        provider: 'jest',
        version: '29.0.0',
        description: 'Delightful JavaScript testing framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'jest.config.js',
            template: `/** @type {import('jest').Config} */
module.exports = {
  testEnvironment: 'node',
  transform: {
    '^.+\\.(t|j)sx?$': ['@swc/jest'],
  },
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^~/(.*)$': '<rootDir>/$1'
  },
  testMatch: [
    '**/__tests__/**/*.(test|spec).(ts|tsx|js)',
    '**/*.(test|spec).(ts|tsx|js)'
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx,js,jsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/**/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js']
};`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'jest.setup.js',
            template: `// Add custom jest matchers
import '@testing-library/jest-dom';

// Mock environment variables
process.env.NODE_ENV = 'test';

// Global test utilities
global.testUtils = {
  waitFor: (ms) => new Promise(resolve => setTimeout(resolve, ms))
};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/__tests__/example.test.ts',
            template: `describe('Example Test Suite', () => {
  it('should pass a basic test', () => {
    expect(true).toBe(true);
  });

  it('should test async operations', async () => {
    const result = await Promise.resolve('success');
    expect(result).toBe('success');
  });

  it('should test with mocks', () => {
    const mockFn = jest.fn();
    mockFn('test');
    expect(mockFn).toHaveBeenCalledWith('test');
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          jest: '^29.0.0',
          '@types/jest': '^29.0.0',
          '@swc/jest': '^0.2.0',
          '@testing-library/jest-dom': '^6.0.0',
          '@testing-library/react': '^14.0.0',
          '@testing-library/user-event': '^14.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test script to package.json',
            command: 'npm pkg set scripts.test="jest" scripts.test:watch="jest --watch" scripts.test:coverage="jest --coverage"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'jest', 'unit-test', 'coverage', 'mocking']
      },

      // Testing - Vitest
      {
        name: 'vitest',
        type: 'testing',
        provider: 'vitest',
        version: '1.0.0',
        description: 'Blazing fast unit test framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'vitest.config.ts',
            template: `import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./vitest.setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData/**',
        '**/*.stories.tsx'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '~': path.resolve(__dirname, './')
    }
  }
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'vitest.setup.ts',
            template: `import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest's expect with jest-dom matchers
expect.extend(matchers);

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock environment variables
process.env.NODE_ENV = 'test';

// Global test utilities
globalThis.testUtils = {
  waitFor: (ms: number) => new Promise(resolve => setTimeout(resolve, ms))
};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/__tests__/example.test.ts',
            template: `import { describe, it, expect, vi } from 'vitest';

describe('Example Test Suite', () => {
  it('should pass a basic test', () => {
    expect(true).toBe(true);
  });

  it('should test async operations', async () => {
    const result = await Promise.resolve('success');
    expect(result).toBe('success');
  });

  it('should test with mocks', () => {
    const mockFn = vi.fn();
    mockFn('test');
    expect(mockFn).toHaveBeenCalledWith('test');
  });

  it('should test with spies', () => {
    const obj = {
      method: () => 'original'
    };
    const spy = vi.spyOn(obj, 'method');
    obj.method();
    expect(spy).toHaveBeenCalled();
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          vitest: '^1.0.0',
          '@vitest/ui': '^1.0.0',
          '@vitest/coverage-v8': '^1.0.0',
          '@testing-library/react': '^14.0.0',
          '@testing-library/jest-dom': '^6.0.0',
          '@testing-library/user-event': '^14.0.0',
          jsdom: '^23.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test="vitest" scripts.test:ui="vitest --ui" scripts.test:coverage="vitest --coverage"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'vitest', 'unit-test', 'vite', 'fast']
      },

      // Testing - Playwright
      {
        name: 'playwright',
        type: 'testing',
        provider: 'playwright',
        version: '1.40.0',
        description: 'End-to-end testing framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'playwright.config.ts',
            template: `import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'e2e/example.spec.ts',
            template: `import { test, expect } from '@playwright/test';

test.describe('Example E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should display homepage', async ({ page }) => {
    await expect(page).toHaveTitle(/Home/);
    await expect(page.locator('h1')).toBeVisible();
  });

  test('should navigate to about page', async ({ page }) => {
    await page.click('text=About');
    await expect(page).toHaveURL(/.*about/);
  });

  test('should fill and submit form', async ({ page }) => {
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('.success-message')).toBeVisible();
  });

  test('should handle API responses', async ({ page }) => {
    // Mock API response
    await page.route('**/api/users', route => {
      route.fulfill({
        status: 200,
        body: JSON.stringify({ users: [] })
      });
    });

    await page.goto('/users');
    await expect(page.locator('.user-list')).toBeVisible();
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          '@playwright/test': '^1.40.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Playwright browsers',
            command: 'npx playwright install'
          },
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test:e2e="playwright test" scripts.test:e2e:ui="playwright test --ui"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['testing', 'e2e', 'playwright', 'browser', 'automation']
      },

      // Testing - Cypress
      {
        name: 'cypress',
        type: 'testing',
        provider: 'cypress',
        version: '13.0.0',
        description: 'Fast, easy and reliable testing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'cypress.config.ts',
            template: `import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    viewportWidth: 1280,
    viewportHeight: 720,
    video: true,
    screenshotOnRunFailure: true,
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
  component: {
    devServer: {
      framework: 'react',
      bundler: 'vite',
    },
    specPattern: 'src/**/*.cy.{js,jsx,ts,tsx}',
  },
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'cypress/support/commands.ts',
            template: `// Custom commands
Cypress.Commands.add('login', (email: string, password: string) => {
  cy.visit('/login');
  cy.get('input[name="email"]').type(email);
  cy.get('input[name="password"]').type(password);
  cy.get('button[type="submit"]').click();
});

Cypress.Commands.add('waitForApi', (alias: string) => {
  cy.intercept('GET', '/api/**').as(alias);
  cy.wait(\`@\${alias}\`);
});

// TypeScript support
declare global {
  namespace Cypress {
    interface Chainable {
      login(email: string, password: string): Chainable<void>;
      waitForApi(alias: string): Chainable<void>;
    }
  }
}

export {};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'cypress/e2e/example.cy.ts',
            template: `describe('Example E2E Tests', () => {
  beforeEach(() => {
    cy.visit('/');
  });

  it('displays homepage', () => {
    cy.contains('h1', 'Welcome');
    cy.title().should('include', 'Home');
  });

  it('navigates to about page', () => {
    cy.contains('About').click();
    cy.url().should('include', '/about');
    cy.contains('h1', 'About Us');
  });

  it('submits contact form', () => {
    cy.visit('/contact');
    
    cy.get('input[name="name"]').type('John Doe');
    cy.get('input[name="email"]').type('john@example.com');
    cy.get('textarea[name="message"]').type('Test message');
    
    cy.get('form').submit();
    
    cy.contains('.success', 'Thank you').should('be.visible');
  });

  it('handles API data', () => {
    cy.intercept('GET', '/api/products', { fixture: 'products.json' }).as('getProducts');
    
    cy.visit('/products');
    cy.wait('@getProducts');
    
    cy.get('.product-card').should('have.length.greaterThan', 0);
  });

  it('tests responsive design', () => {
    // Mobile view
    cy.viewport('iphone-x');
    cy.get('.mobile-menu').should('be.visible');
    
    // Desktop view
    cy.viewport(1920, 1080);
    cy.get('.desktop-menu').should('be.visible');
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          cypress: '^13.0.0',
          '@cypress/react': '^8.0.0',
          '@cypress/vue': '^6.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.cy:open="cypress open" scripts.cy:run="cypress run"'
          },
          {
            type: 'manual',
            description: 'Create cypress/fixtures, cypress/downloads, and cypress/screenshots directories'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['testing', 'e2e', 'cypress', 'browser', 'component']
      },

      // Testing - k6
      {
        name: 'k6',
        type: 'testing',
        provider: 'k6',
        version: '0.48.0',
        description: 'Modern load testing tool',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'k6/load-test.js',
            template: `import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');

// Test configuration
export const options = {
  stages: [
    { duration: '30s', target: 10 },  // Ramp up to 10 users
    { duration: '1m', target: 10 },   // Stay at 10 users
    { duration: '30s', target: 20 },  // Ramp up to 20 users
    { duration: '1m', target: 20 },   // Stay at 20 users
    { duration: '30s', target: 0 },   // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
    errors: ['rate<0.1'],             // Error rate must be below 10%
  },
};

// Main test function
export default function () {
  // Test homepage
  const homeRes = http.get(__ENV.BASE_URL || 'http://localhost:3000');
  check(homeRes, {
    'homepage status is 200': (r) => r.status === 200,
    'homepage loads quickly': (r) => r.timings.duration < 200,
  });
  errorRate.add(homeRes.status !== 200);

  sleep(1);

  // Test API endpoint
  const apiRes = http.get(\`\${__ENV.BASE_URL || 'http://localhost:3000'}/api/health\`);
  check(apiRes, {
    'API status is 200': (r) => r.status === 200,
    'API response has data': (r) => JSON.parse(r.body).status === 'ok',
  });
  errorRate.add(apiRes.status !== 200);

  sleep(1);
}

// Setup function (runs once per VU)
export function setup() {
  console.log('Starting load test...');
  return { startTime: new Date().toISOString() };
}

// Teardown function (runs once)
export function teardown(data) {
  console.log(\`Load test completed at \${new Date().toISOString()}\`);
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'k6/stress-test.js',
            template: `import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 },  // Ramp up to 100 users
    { duration: '5m', target: 100 },  // Stay at 100 users
    { duration: '2m', target: 200 },  // Ramp up to 200 users
    { duration: '5m', target: 200 },  // Stay at 200 users
    { duration: '2m', target: 300 },  // Ramp up to 300 users
    { duration: '5m', target: 300 },  // Stay at 300 users
    { duration: '2m', target: 0 },    // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(99)<1500'], // 99% of requests must complete below 1.5s
  },
};

export default function () {
  const responses = http.batch([
    ['GET', \`\${__ENV.BASE_URL}/\`],
    ['GET', \`\${__ENV.BASE_URL}/api/products\`],
    ['GET', \`\${__ENV.BASE_URL}/api/users\`],
  ]);

  responses.forEach((res, index) => {
    check(res, {
      \`request \${index} status is 200\`: (r) => r.status === 200,
    });
  });
}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'k6/spike-test.js',
            template: `import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '10s', target: 100 },  // Ramp up to 100 users quickly
    { duration: '1m', target: 100 },   // Stay at 100 users
    { duration: '10s', target: 1000 }, // Spike to 1000 users
    { duration: '3m', target: 1000 },  // Stay at 1000 users
    { duration: '10s', target: 100 },  // Scale down to 100 users
    { duration: '3m', target: 100 },   // Stay at 100 users
    { duration: '10s', target: 0 },    // Ramp down to 0 users
  ],
};

export default function () {
  const res = http.get(__ENV.BASE_URL || 'http://localhost:3000');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  sleep(1);
}`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'BASE_URL',
            description: 'Base URL for load testing',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          }
        ],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Install k6 from https://k6.io/docs/getting-started/installation/'
          },
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test:load="k6 run k6/load-test.js" scripts.test:stress="k6 run k6/stress-test.js" scripts.test:spike="k6 run k6/spike-test.js"'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'performance', 'load-testing', 'k6', 'stress']
      },

      // DevOps - Docker
      {
        name: 'docker',
        type: 'devops',
        provider: 'docker',
        version: '24.0.0',
        description: 'Containerization platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'Dockerfile',
            template: `# Multi-stage build for optimized image size
FROM node:20-alpine AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \\
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \\
  elif [ -f package-lock.json ]; then npm ci; \\
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \\
  else echo "Lockfile not found." && exit 1; \\
  fi

# Rebuild the source code only when needed
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build the application
RUN \\
  if [ -f yarn.lock ]; then yarn build; \\
  elif [ -f package-lock.json ]; then npm run build; \\
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm build; \\
  else echo "Lockfile not found." && exit 1; \\
  fi

# Production image, copy all the files and run
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nodejs

# Copy built application
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./package.json
COPY --from=builder /app/node_modules ./node_modules

USER nodejs

EXPOSE 3000

ENV PORT=3000

CMD ["node", "dist/index.js"]`,
            priority: 100
          },
          {
            type: 'file-create',
            target: '.dockerignore',
            template: `node_modules
npm-debug.log
.env.local
.env
.DS_Store
*.log
.next
.nuxt
dist
.cache
.vscode
.idea
coverage
.nyc_output
*.test.js
*.spec.js
__tests__
.git
.gitignore
README.md
.editorconfig
.eslintrc
.prettierrc
docker-compose*.yml
Dockerfile
.dockerignore`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'docker-compose.yml',
            template: `version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
    depends_on:
      - db
      - redis
    networks:
      - app-network

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - app-network

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Build Docker image',
            command: 'docker build -t myapp .'
          },
          {
            type: 'command',
            description: 'Run with docker-compose',
            command: 'docker-compose up -d'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['devops', 'docker', 'container', 'deployment', 'orchestration']
      },

      // DevOps - GitHub Actions
      {
        name: 'github-actions',
        type: 'devops',
        provider: 'github',
        version: '3.0.0',
        description: 'CI/CD workflows for GitHub',
        injectionPoints: [
          {
            type: 'file-create',
            target: '.github/workflows/ci.yml',
            template: `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '20'

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 21]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js \${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: \${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: \${{ secrets.CODECOV_TOKEN }}

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/`,
            priority: 100
          },
          {
            type: 'file-create',
            target: '.github/workflows/deploy.yml',
            template: `name: Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci --production
      
      - name: Build
        run: npm run build
        env:
          NODE_ENV: production
      
      # Deploy to Vercel
      - name: Deploy to Vercel
        if: \${{ vars.DEPLOY_TARGET == 'vercel' }}
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: \${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
      
      # Deploy to Docker Registry
      - name: Build and push Docker image
        if: \${{ vars.DEPLOY_TARGET == 'docker' }}
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            \${{ secrets.DOCKER_REGISTRY }}/\${{ github.repository }}:latest
            \${{ secrets.DOCKER_REGISTRY }}/\${{ github.repository }}:\${{ github.sha }}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: '.github/workflows/security.yml',
            template: `name: Security

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # Weekly on Monday

jobs:
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run npm audit
        run: npm audit --production
      
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: \${{ secrets.SNYK_TOKEN }}`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Add secrets to GitHub repository settings'
          },
          {
            type: 'manual',
            description: 'Configure branch protection rules'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['devops', 'ci-cd', 'github-actions', 'automation', 'deployment']
      },

      // DevOps - Terraform
      {
        name: 'terraform',
        type: 'devops',
        provider: 'terraform',
        version: '1.6.0',
        description: 'Infrastructure as Code',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'terraform/main.tf',
            template: `terraform {
  required_version = ">= 1.6.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket = "terraform-state-bucket"
    key    = "prod/terraform.tfstate"
    region = "us-east-1"
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC Configuration
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "\${var.project_name}-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = data.aws_availability_zones.available.names
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = true
  
  tags = local.common_tags
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "\${var.project_name}-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
  
  tags = local.common_tags
}

# Load Balancer
resource "aws_lb" "main" {
  name               = "\${var.project_name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = module.vpc.public_subnets
  
  enable_deletion_protection = var.environment == "production"
  
  tags = local.common_tags
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'terraform/variables.tf',
            template: `variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "environment" {
  description = "Environment name"
  type        = string
  validation {
    condition     = contains(["development", "staging", "production"], var.environment)
    error_message = "Environment must be development, staging, or production."
  }
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "database_instance_class" {
  description = "RDS instance class"
  type        = string
  default     = "db.t3.micro"
}

variable "min_size" {
  description = "Minimum number of instances"
  type        = number
  default     = 1
}

variable "max_size" {
  description = "Maximum number of instances"
  type        = number
  default     = 3
}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'terraform/outputs.tf',
            template: `output "vpc_id" {
  description = "ID of the VPC"
  value       = module.vpc.vpc_id
}

output "load_balancer_url" {
  description = "URL of the load balancer"
  value       = aws_lb.main.dns_name
}

output "ecs_cluster_name" {
  description = "Name of the ECS cluster"
  value       = aws_ecs_cluster.main.name
}

output "database_endpoint" {
  description = "RDS instance endpoint"
  value       = aws_db_instance.main.endpoint
  sensitive   = true
}

output "redis_endpoint" {
  description = "ElastiCache Redis endpoint"
  value       = aws_elasticache_cluster.redis.cache_nodes[0].address
  sensitive   = true
}`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Initialize Terraform',
            command: 'cd terraform && terraform init'
          },
          {
            type: 'command',
            description: 'Plan infrastructure changes',
            command: 'cd terraform && terraform plan'
          },
          {
            type: 'manual',
            description: 'Review and apply infrastructure changes with: terraform apply'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['infrastructure'],
        tags: ['devops', 'terraform', 'iac', 'infrastructure', 'aws']
      },

      // DevOps - Kubernetes
      {
        name: 'kubernetes',
        type: 'devops',
        provider: 'kubernetes',
        version: '1.28.0',
        description: 'Container orchestration platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'k8s/deployment.yaml',
            template: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
  labels:
    app: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'k8s/service.yaml',
            template: `apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  name: app-service-internal
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
  type: ClusterIP`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'k8s/ingress.yaml',
            template: `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - myapp.example.com
    secretName: myapp-tls
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'k8s/configmap.yaml',
            template: `apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.properties: |
    server.port=3000
    app.name=myapp
    app.environment=production`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'k8s/secret.yaml',
            template: `apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  database-url: "postgresql://user:password@postgres:5432/myapp"
  redis-url: "redis://redis:6379"
  api-key: "your-api-key-here"`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'k8s/hpa.yaml',
            template: `apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: app-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80`,
            priority: 80
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Apply Kubernetes configurations',
            command: 'kubectl apply -f k8s/'
          },
          {
            type: 'manual',
            description: 'Set up Kubernetes cluster (local with kind/minikube or cloud)'
          },
          {
            type: 'manual',
            description: 'Configure kubectl context'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['infrastructure'],
        tags: ['devops', 'kubernetes', 'k8s', 'orchestration', 'container']
      },

      // RBAC (Role-Based Access Control) Services
      {
        name: 'casbin',
        type: 'rbac',
        provider: 'casbin',
        version: '5.0.0',
        description: 'Authorization library that supports access control models',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth/rbac.ts',
            template: `import { newEnforcer } from 'casbin';
import { PrismaAdapter } from 'casbin-prisma-adapter';
import { prisma } from '@/lib/prisma';

// Casbin RBAC configuration
const modelText = \`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
\`;

export class RBACService {
  private enforcer: any;

  async initialize() {
    const adapter = await PrismaAdapter.newAdapter(prisma);
    this.enforcer = await newEnforcer(modelText, adapter);
    
    // Initialize default policies
    await this.setupDefaultPolicies();
  }

  private async setupDefaultPolicies() {
    // Admin role can do everything
    await this.enforcer.addPolicy('admin', '*', '*');
    
    // User role permissions
    await this.enforcer.addPolicy('user', 'profile', 'read');
    await this.enforcer.addPolicy('user', 'profile', 'update');
    
    // Guest role permissions
    await this.enforcer.addPolicy('guest', 'public', 'read');
    
    // Role inheritance
    await this.enforcer.addGroupingPolicy('admin', 'user');
    await this.enforcer.addGroupingPolicy('user', 'guest');
  }

  async checkPermission(userId: string, resource: string, action: string): Promise<boolean> {
    return await this.enforcer.enforce(userId, resource, action);
  }

  async assignRole(userId: string, role: string) {
    await this.enforcer.addGroupingPolicy(userId, role);
  }

  async removeRole(userId: string, role: string) {
    await this.enforcer.removeGroupingPolicy(userId, role);
  }

  async getUserRoles(userId: string): Promise<string[]> {
    return await this.enforcer.getRolesForUser(userId);
  }

  async getRolePermissions(role: string): Promise<string[][]> {
    return await this.enforcer.getPermissionsForUser(role);
  }
}

export const rbac = new RBACService();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/rbac.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { rbac } from '@/lib/auth/rbac';
import { getSession } from '@/lib/auth';

export function withRBAC(resource: string, action: string) {
  return async function middleware(req: NextRequest) {
    try {
      const session = await getSession(req);
      
      if (!session?.userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
      
      const hasPermission = await rbac.checkPermission(
        session.userId,
        resource,
        action
      );
      
      if (!hasPermission) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }
      
      return NextResponse.next();
    } catch (error) {
      console.error('RBAC middleware error:', error);
      return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
  };
}
`
          },
          {
            type: 'dependency',
            packages: {
              'casbin': '^5.0.0',
              'casbin-prisma-adapter': '^1.0.0'
            }
          }
        ],
        documentation: 'https://casbin.org/',
        complexity: 'medium',
        tags: ['authorization', 'access-control', 'rbac', 'permissions']
      },
      {
        name: 'opa',
        type: 'rbac',
        provider: 'open-policy-agent',
        version: '0.50.0',
        description: 'Policy-based control for cloud native environments',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth/opa.ts',
            template: `import axios from 'axios';

interface OPAInput {
  user: {
    id: string;
    roles: string[];
    attributes?: Record<string, any>;
  };
  resource: {
    type: string;
    id?: string;
    attributes?: Record<string, any>;
  };
  action: string;
}

export class OPAService {
  private baseURL: string;

  constructor(baseURL = process.env.OPA_URL || 'http://localhost:8181') {
    this.baseURL = baseURL;
  }

  async evaluatePolicy(
    policyPath: string,
    input: OPAInput
  ): Promise<boolean> {
    try {
      const response = await axios.post(
        \`\${this.baseURL}/v1/data/\${policyPath}\`,
        { input }
      );
      
      return response.data.result?.allow || false;
    } catch (error) {
      console.error('OPA evaluation error:', error);
      return false;
    }
  }

  async checkPermission(
    userId: string,
    userRoles: string[],
    resource: string,
    action: string,
    resourceAttributes?: Record<string, any>
  ): Promise<boolean> {
    const input: OPAInput = {
      user: {
        id: userId,
        roles: userRoles
      },
      resource: {
        type: resource,
        attributes: resourceAttributes
      },
      action
    };

    return await this.evaluatePolicy('app/rbac', input);
  }

  async uploadPolicy(name: string, policy: string): Promise<void> {
    await axios.put(
      \`\${this.baseURL}/v1/policies/\${name}\`,
      policy,
      {
        headers: {
          'Content-Type': 'text/plain'
        }
      }
    );
  }
}

export const opa = new OPAService();
`
          },
          {
            type: 'file-create',
            target: 'policies/rbac.rego',
            template: `package app.rbac

import future.keywords.contains
import future.keywords.if
import future.keywords.in

# Default deny
default allow := false

# Admin can do everything
allow if {
    "admin" in input.user.roles
}

# User role permissions
allow if {
    "user" in input.user.roles
    input.resource.type == "profile"
    input.action in ["read", "update"]
    input.resource.id == input.user.id
}

# Moderator permissions
allow if {
    "moderator" in input.user.roles
    input.resource.type in ["post", "comment"]
    input.action in ["read", "update", "delete"]
}

# Owner permissions
allow if {
    input.resource.attributes.ownerId == input.user.id
    input.action in ["read", "update", "delete"]
}

# Public read permissions
allow if {
    input.resource.attributes.visibility == "public"
    input.action == "read"
}

# Role hierarchy
user_has_role(user_id, role) if {
    role in input.user.roles
}

user_has_role(user_id, "user") if {
    "admin" in input.user.roles
}

user_has_role(user_id, "guest") if {
    "user" in input.user.roles
}
`
          },
          {
            type: 'file-create',
            target: 'docker-compose.opa.yml',
            template: `version: '3.8'

services:
  opa:
    image: openpolicyagent/opa:latest-envoy
    ports:
      - "8181:8181"
    command:
      - "run"
      - "--server"
      - "--log-level=debug"
      - "/policies"
    volumes:
      - ./policies:/policies
    environment:
      - OPA_LOG_LEVEL=debug
`
          },
          {
            type: 'dependency',
            packages: {
              'axios': '^1.6.0'
            }
          }
        ],
        documentation: 'https://www.openpolicyagent.org/',
        complexity: 'high',
        tags: ['policy', 'authorization', 'rbac', 'cloud-native']
      },
      {
        name: 'custom-rbac',
        type: 'rbac',
        provider: 'custom',
        version: '1.0.0',
        description: 'Custom role-based access control implementation',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/rbac/index.ts',
            template: `import { prisma } from '@/lib/prisma';

export interface Permission {
  id: string;
  name: string;
  resource: string;
  action: string;
  description?: string;
}

export interface Role {
  id: string;
  name: string;
  description?: string;
  permissions: Permission[];
}

export class CustomRBAC {
  async createRole(name: string, description?: string): Promise<Role> {
    return await prisma.role.create({
      data: {
        name,
        description
      },
      include: {
        permissions: true
      }
    });
  }

  async createPermission(
    name: string,
    resource: string,
    action: string,
    description?: string
  ): Promise<Permission> {
    return await prisma.permission.create({
      data: {
        name,
        resource,
        action,
        description
      }
    });
  }

  async assignPermissionToRole(roleId: string, permissionId: string): Promise<void> {
    await prisma.rolePermission.create({
      data: {
        roleId,
        permissionId
      }
    });
  }

  async assignRoleToUser(userId: string, roleId: string): Promise<void> {
    await prisma.userRole.create({
      data: {
        userId,
        roleId
      }
    });
  }

  async getUserPermissions(userId: string): Promise<Permission[]> {
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          include: {
            permissions: {
              include: {
                permission: true
              }
            }
          }
        }
      }
    });

    const permissions = new Map<string, Permission>();
    
    for (const userRole of userRoles) {
      for (const rolePermission of userRole.role.permissions) {
        const perm = rolePermission.permission;
        permissions.set(perm.id, perm);
      }
    }

    return Array.from(permissions.values());
  }

  async checkPermission(
    userId: string,
    resource: string,
    action: string
  ): Promise<boolean> {
    const permissions = await this.getUserPermissions(userId);
    
    return permissions.some(
      p => p.resource === resource && p.action === action
    );
  }

  async checkPermissions(
    userId: string,
    requiredPermissions: Array<{ resource: string; action: string }>
  ): Promise<boolean> {
    const userPermissions = await this.getUserPermissions(userId);
    
    return requiredPermissions.every(required =>
      userPermissions.some(
        p => p.resource === required.resource && p.action === required.action
      )
    );
  }

  async getUserRoles(userId: string): Promise<Role[]> {
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          include: {
            permissions: {
              include: {
                permission: true
              }
            }
          }
        }
      }
    });

    return userRoles.map(ur => ({
      ...ur.role,
      permissions: ur.role.permissions.map(rp => rp.permission)
    }));
  }
}

export const rbac = new CustomRBAC();
`
          },
          {
            type: 'file-create',
            target: 'prisma/schema.rbac.prisma',
            template: `// Add these models to your schema.prisma

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  permissions RolePermission[]
  users       UserRole[]
}

model Permission {
  id          String   @id @default(cuid())
  name        String   @unique
  resource    String
  action      String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  roles RolePermission[]
  
  @@unique([resource, action])
  @@index([resource])
}

model RolePermission {
  roleId       String
  permissionId String
  createdAt    DateTime @default(now())
  
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@id([roleId, permissionId])
}

model UserRole {
  userId    String
  roleId    String
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@id([userId, roleId])
  @@index([userId])
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/rbac/seed.ts',
            template: `import { rbac } from './index';

export async function seedRBAC() {
  // Create permissions
  const permissions = [
    // User permissions
    { name: 'user.profile.read', resource: 'user.profile', action: 'read' },
    { name: 'user.profile.update', resource: 'user.profile', action: 'update' },
    { name: 'user.settings.read', resource: 'user.settings', action: 'read' },
    { name: 'user.settings.update', resource: 'user.settings', action: 'update' },
    
    // Admin permissions
    { name: 'admin.users.read', resource: 'admin.users', action: 'read' },
    { name: 'admin.users.create', resource: 'admin.users', action: 'create' },
    { name: 'admin.users.update', resource: 'admin.users', action: 'update' },
    { name: 'admin.users.delete', resource: 'admin.users', action: 'delete' },
    { name: 'admin.roles.manage', resource: 'admin.roles', action: 'manage' },
    
    // Content permissions
    { name: 'content.posts.read', resource: 'content.posts', action: 'read' },
    { name: 'content.posts.create', resource: 'content.posts', action: 'create' },
    { name: 'content.posts.update', resource: 'content.posts', action: 'update' },
    { name: 'content.posts.delete', resource: 'content.posts', action: 'delete' },
  ];

  const createdPermissions = new Map();
  for (const perm of permissions) {
    const created = await rbac.createPermission(
      perm.name,
      perm.resource,
      perm.action
    );
    createdPermissions.set(perm.name, created);
  }

  // Create roles
  const adminRole = await rbac.createRole('admin', 'Full system access');
  const userRole = await rbac.createRole('user', 'Regular user access');
  const guestRole = await rbac.createRole('guest', 'Limited guest access');

  // Assign permissions to roles
  // Admin gets all permissions
  for (const [_, permission] of createdPermissions) {
    await rbac.assignPermissionToRole(adminRole.id, permission.id);
  }

  // User role permissions
  const userPermissions = [
    'user.profile.read',
    'user.profile.update',
    'user.settings.read',
    'user.settings.update',
    'content.posts.read',
    'content.posts.create'
  ];

  for (const permName of userPermissions) {
    const perm = createdPermissions.get(permName);
    if (perm) {
      await rbac.assignPermissionToRole(userRole.id, perm.id);
    }
  }

  // Guest role permissions
  const guestPermissions = [
    'content.posts.read'
  ];

  for (const permName of guestPermissions) {
    const perm = createdPermissions.get(permName);
    if (perm) {
      await rbac.assignPermissionToRole(guestRole.id, perm.id);
    }
  }

  console.log('RBAC seed completed successfully');
}
`
          }
        ],
        documentation: 'Custom RBAC implementation guide',
        complexity: 'medium',
        tags: ['custom', 'rbac', 'permissions', 'roles']
      },

      // Multi-tenancy Services
      {
        name: 'schema-separation',
        type: 'multiTenancy',
        provider: 'schema-separation',
        version: '1.0.0',
        description: 'Multi-tenancy using database schema separation',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/tenancy/schema-manager.ts',
            template: `import { PrismaClient } from '@prisma/client';

export class SchemaManager {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createTenantSchema(tenantId: string): Promise<void> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    try {
      // Create schema
      await this.prisma.$executeRawUnsafe(
        \`CREATE SCHEMA IF NOT EXISTS "\${schemaName}"\`
      );
      
      // Run migrations for the schema
      await this.runMigrationsForSchema(schemaName);
      
      console.log(\`Created schema for tenant: \${tenantId}\`);
    } catch (error) {
      console.error(\`Error creating schema for tenant \${tenantId}:\`, error);
      throw error;
    }
  }

  async deleteTenantSchema(tenantId: string): Promise<void> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    try {
      await this.prisma.$executeRawUnsafe(
        \`DROP SCHEMA IF EXISTS "\${schemaName}" CASCADE\`
      );
      
      console.log(\`Deleted schema for tenant: \${tenantId}\`);
    } catch (error) {
      console.error(\`Error deleting schema for tenant \${tenantId}:\`, error);
      throw error;
    }
  }

  async runMigrationsForSchema(schemaName: string): Promise<void> {
    // Create tables in the tenant schema
    const tables = [
      \`CREATE TABLE IF NOT EXISTS "\${schemaName}"."User" (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        name TEXT,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )\`,
      \`CREATE TABLE IF NOT EXISTS "\${schemaName}"."Product" (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        price DECIMAL(10,2),
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )\`,
      // Add more tables as needed
    ];

    for (const query of tables) {
      await this.prisma.$executeRawUnsafe(query);
    }
  }

  getTenantSchemaName(tenantId: string): string {
    return \`tenant_\${tenantId.replace(/-/g, '_')}\`;
  }

  async getTenantPrismaClient(tenantId: string): Promise<PrismaClient> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    // Create a new Prisma client with the tenant's schema
    return new PrismaClient({
      datasources: {
        db: {
          url: \`\${process.env.DATABASE_URL}?schema=\${schemaName}\`
        }
      }
    });
  }
}

export const schemaManager = new SchemaManager();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/tenant.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { schemaManager } from '@/lib/tenancy/schema-manager';

export async function withTenant(req: NextRequest) {
  try {
    // Extract tenant ID from subdomain, header, or JWT
    const tenantId = extractTenantId(req);
    
    if (!tenantId) {
      return NextResponse.json({ error: 'Tenant not found' }, { status: 400 });
    }
    
    // Get tenant-specific Prisma client
    const tenantPrisma = await schemaManager.getTenantPrismaClient(tenantId);
    
    // Attach to request for use in API routes
    (req as any).tenantPrisma = tenantPrisma;
    (req as any).tenantId = tenantId;
    
    return NextResponse.next();
  } catch (error) {
    console.error('Tenant middleware error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

function extractTenantId(req: NextRequest): string | null {
  // Option 1: From subdomain
  const host = req.headers.get('host') || '';
  const subdomain = host.split('.')[0];
  if (subdomain && subdomain !== 'www' && subdomain !== 'app') {
    return subdomain;
  }
  
  // Option 2: From header
  const tenantHeader = req.headers.get('x-tenant-id');
  if (tenantHeader) {
    return tenantHeader;
  }
  
  // Option 3: From JWT token
  // Implementation depends on your auth setup
  
  return null;
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/tenant-service.ts',
            template: `import { PrismaClient } from '@prisma/client';
import { schemaManager } from './schema-manager';

export interface Tenant {
  id: string;
  name: string;
  subdomain: string;
  plan: 'free' | 'starter' | 'pro' | 'enterprise';
  status: 'active' | 'suspended' | 'deleted';
  createdAt: Date;
  updatedAt: Date;
}

export class TenantService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createTenant(data: {
    name: string;
    subdomain: string;
    plan?: 'free' | 'starter' | 'pro' | 'enterprise';
  }): Promise<Tenant> {
    // Create tenant record in master database
    const tenant = await this.prisma.tenant.create({
      data: {
        name: data.name,
        subdomain: data.subdomain,
        plan: data.plan || 'free',
        status: 'active'
      }
    });

    // Create tenant schema
    await schemaManager.createTenantSchema(tenant.id);

    return tenant;
  }

  async getTenant(id: string): Promise<Tenant | null> {
    return await this.prisma.tenant.findUnique({
      where: { id }
    });
  }

  async getTenantBySubdomain(subdomain: string): Promise<Tenant | null> {
    return await this.prisma.tenant.findUnique({
      where: { subdomain }
    });
  }

  async updateTenant(id: string, data: Partial<Tenant>): Promise<Tenant> {
    return await this.prisma.tenant.update({
      where: { id },
      data
    });
  }

  async deleteTenant(id: string): Promise<void> {
    // Soft delete tenant
    await this.prisma.tenant.update({
      where: { id },
      data: { status: 'deleted' }
    });

    // Optionally delete schema (consider archiving instead)
    // await schemaManager.deleteTenantSchema(id);
  }

  async listTenants(params?: {
    status?: 'active' | 'suspended' | 'deleted';
    plan?: 'free' | 'starter' | 'pro' | 'enterprise';
  }): Promise<Tenant[]> {
    return await this.prisma.tenant.findMany({
      where: params
    });
  }
}

export const tenantService = new TenantService();
`
          }
        ],
        documentation: 'https://www.postgresql.org/docs/current/ddl-schemas.html',
        complexity: 'high',
        tags: ['multi-tenancy', 'schema-separation', 'postgresql', 'isolation']
      },
      {
        name: 'row-level-security',
        type: 'multiTenancy',
        provider: 'row-level-security',
        version: '1.0.0',
        description: 'Multi-tenancy using row-level security (RLS)',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/migrations/enable_rls.sql',
            template: `-- Enable Row Level Security on all tenant-scoped tables

-- Users table
ALTER TABLE "User" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "User"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Products table  
ALTER TABLE "Product" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "Product"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Orders table
ALTER TABLE "Order" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "Order"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Add tenant_id column to all tables
ALTER TABLE "User" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;
ALTER TABLE "Product" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;
ALTER TABLE "Order" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_tenant_id ON "User"(tenant_id);
CREATE INDEX IF NOT EXISTS idx_product_tenant_id ON "Product"(tenant_id);
CREATE INDEX IF NOT EXISTS idx_order_tenant_id ON "Order"(tenant_id);
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/rls-client.ts',
            template: `import { PrismaClient } from '@prisma/client';

export class RLSPrismaClient {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async getClientForTenant(tenantId: string): Promise<PrismaClient> {
    const client = new PrismaClient({
      datasources: {
        db: {
          url: process.env.DATABASE_URL
        }
      }
    });

    // Set the tenant context for RLS
    await client.$executeRawUnsafe(
      \`SET app.current_tenant = '\${tenantId}'\`
    );

    return client;
  }

  async withTenant<T>(
    tenantId: string,
    callback: (prisma: PrismaClient) => Promise<T>
  ): Promise<T> {
    const client = await this.getClientForTenant(tenantId);
    
    try {
      const result = await callback(client);
      return result;
    } finally {
      await client.$disconnect();
    }
  }
}

export const rlsClient = new RLSPrismaClient();

// Extended Prisma Client with tenant context
export function createTenantPrismaClient(tenantId: string) {
  const prisma = new PrismaClient();

  // Middleware to automatically set tenant context
  prisma.$use(async (params, next) => {
    if (params.model && !['Tenant', 'System'].includes(params.model)) {
      // Set tenant context before each query
      await prisma.$executeRawUnsafe(
        \`SET app.current_tenant = '\${tenantId}'\`
      );
    }
    
    return next(params);
  });

  return prisma;
}
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/rls-tenant.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { createTenantPrismaClient } from '@/lib/tenancy/rls-client';
import { getSession } from '@/lib/auth';

export async function withRLSTenant(req: NextRequest) {
  try {
    const session = await getSession(req);
    
    if (!session?.tenantId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    // Create tenant-specific Prisma client with RLS
    const tenantPrisma = createTenantPrismaClient(session.tenantId);
    
    // Attach to request
    (req as any).prisma = tenantPrisma;
    (req as any).tenantId = session.tenantId;
    
    return NextResponse.next();
  } catch (error) {
    console.error('RLS tenant middleware error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/rls-helpers.ts',
            template: `// Helper functions for RLS-based multi-tenancy

export async function setTenantContext(
  prisma: any,
  tenantId: string
): Promise<void> {
  await prisma.$executeRawUnsafe(
    \`SET LOCAL app.current_tenant = '\${tenantId}'\`
  );
}

export async function clearTenantContext(prisma: any): Promise<void> {
  await prisma.$executeRawUnsafe(
    \`RESET app.current_tenant\`
  );
}

// Wrapper for transactions with tenant context
export async function tenantTransaction<T>(
  prisma: any,
  tenantId: string,
  callback: (tx: any) => Promise<T>
): Promise<T> {
  return await prisma.$transaction(async (tx: any) => {
    await tx.$executeRawUnsafe(
      \`SET LOCAL app.current_tenant = '\${tenantId}'\`
    );
    
    return await callback(tx);
  });
}

// Automatically add tenant_id to all create/update operations
export function addTenantId<T extends Record<string, any>>(
  data: T,
  tenantId: string
): T & { tenant_id: string } {
  return {
    ...data,
    tenant_id: tenantId
  };
}
`
          }
        ],
        documentation: 'https://www.postgresql.org/docs/current/ddl-rowsecurity.html',
        complexity: 'medium',
        tags: ['multi-tenancy', 'row-level-security', 'rls', 'postgresql']
      },
      {
        name: 'tenant-routing',
        type: 'multiTenancy',
        provider: 'tenant-routing',
        version: '1.0.0',
        description: 'Multi-tenancy using subdomain/path routing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/tenancy/tenant-resolver.ts',
            template: `import { NextRequest } from 'next/server';

export interface TenantInfo {
  id: string;
  identifier: string;
  type: 'subdomain' | 'path' | 'header' | 'custom';
}

export class TenantResolver {
  async resolveTenant(req: NextRequest): Promise<TenantInfo | null> {
    // Try different resolution strategies in order
    const strategies = [
      this.resolveFromSubdomain,
      this.resolveFromPath,
      this.resolveFromHeader,
      this.resolveFromCustomDomain
    ];

    for (const strategy of strategies) {
      const tenant = await strategy.call(this, req);
      if (tenant) {
        return tenant;
      }
    }

    return null;
  }

  private async resolveFromSubdomain(req: NextRequest): Promise<TenantInfo | null> {
    const host = req.headers.get('host') || '';
    const parts = host.split('.');
    
    // Skip if no subdomain or common subdomains
    if (parts.length < 2 || ['www', 'app', 'api'].includes(parts[0])) {
      return null;
    }

    const subdomain = parts[0];
    
    // Verify tenant exists
    const tenant = await this.verifyTenant(subdomain, 'subdomain');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: subdomain,
        type: 'subdomain'
      };
    }

    return null;
  }

  private async resolveFromPath(req: NextRequest): Promise<TenantInfo | null> {
    const pathname = req.nextUrl.pathname;
    const match = pathname.match(/^\\/tenant\\/([^/]+)/);
    
    if (!match) {
      return null;
    }

    const tenantSlug = match[1];
    
    const tenant = await this.verifyTenant(tenantSlug, 'path');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: tenantSlug,
        type: 'path'
      };
    }

    return null;
  }

  private async resolveFromHeader(req: NextRequest): Promise<TenantInfo | null> {
    const tenantId = req.headers.get('x-tenant-id');
    
    if (!tenantId) {
      return null;
    }

    const tenant = await this.verifyTenant(tenantId, 'header');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: tenantId,
        type: 'header'
      };
    }

    return null;
  }

  private async resolveFromCustomDomain(req: NextRequest): Promise<TenantInfo | null> {
    const host = req.headers.get('host') || '';
    
    // Check if this is a custom domain
    const tenant = await this.verifyCustomDomain(host);
    if (tenant) {
      return {
        id: tenant.id,
        identifier: host,
        type: 'custom'
      };
    }

    return null;
  }

  private async verifyTenant(
    identifier: string,
    type: string
  ): Promise<{ id: string } | null> {
    // Implementation depends on your database
    // This is a placeholder
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();
      
      const tenant = await prisma.tenant.findFirst({
        where: {
          OR: [
            { subdomain: identifier },
            { slug: identifier },
            { id: identifier }
          ],
          status: 'active'
        }
      });

      await prisma.$disconnect();
      
      return tenant;
    } catch (error) {
      console.error('Error verifying tenant:', error);
      return null;
    }
  }

  private async verifyCustomDomain(domain: string): Promise<{ id: string } | null> {
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();
      
      const customDomain = await prisma.customDomain.findUnique({
        where: { domain },
        include: { tenant: true }
      });

      await prisma.$disconnect();
      
      return customDomain?.tenant || null;
    } catch (error) {
      console.error('Error verifying custom domain:', error);
      return null;
    }
  }
}

export const tenantResolver = new TenantResolver();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { tenantResolver } from '@/lib/tenancy/tenant-resolver';

export async function middleware(req: NextRequest) {
  // Skip tenant resolution for static assets and API routes
  if (
    req.nextUrl.pathname.startsWith('/_next') ||
    req.nextUrl.pathname.startsWith('/api/public') ||
    req.nextUrl.pathname.startsWith('/static')
  ) {
    return NextResponse.next();
  }

  try {
    // Resolve tenant
    const tenant = await tenantResolver.resolveTenant(req);
    
    if (!tenant) {
      // Redirect to main site or show error
      return NextResponse.redirect(new URL('/no-tenant', req.url));
    }

    // Add tenant info to headers for downstream use
    const response = NextResponse.next();
    response.headers.set('x-tenant-id', tenant.id);
    response.headers.set('x-tenant-type', tenant.type);
    
    // For path-based tenancy, you might want to rewrite the URL
    if (tenant.type === 'path') {
      const url = req.nextUrl.clone();
      url.pathname = url.pathname.replace(/^\\/tenant\\/[^/]+/, '');
      return NextResponse.rewrite(url);
    }

    return response;
  } catch (error) {
    console.error('Tenant resolution error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useTenant.ts',
            template: `import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';

export interface TenantContext {
  tenantId: string | null;
  tenantName: string | null;
  tenantPlan: 'free' | 'starter' | 'pro' | 'enterprise' | null;
  isLoading: boolean;
}

export function useTenant(): TenantContext {
  const [tenant, setTenant] = useState<TenantContext>({
    tenantId: null,
    tenantName: null,
    tenantPlan: null,
    isLoading: true
  });
  
  const router = useRouter();

  useEffect(() => {
    async function loadTenant() {
      try {
        const response = await fetch('/api/tenant/current');
        const data = await response.json();
        
        setTenant({
          tenantId: data.id,
          tenantName: data.name,
          tenantPlan: data.plan,
          isLoading: false
        });
      } catch (error) {
        console.error('Error loading tenant:', error);
        setTenant(prev => ({ ...prev, isLoading: false }));
      }
    }

    loadTenant();
  }, [router.asPath]);

  return tenant;
}

// React Context for tenant information
import { createContext, useContext, ReactNode } from 'react';

const TenantContext = createContext<TenantContext | undefined>(undefined);

export function TenantProvider({ 
  children,
  tenant 
}: { 
  children: ReactNode;
  tenant: TenantContext;
}) {
  return (
    <TenantContext.Provider value={tenant}>
      {children}
    </TenantContext.Provider>
  );
}

export function useTenantContext(): TenantContext {
  const context = useContext(TenantContext);
  if (context === undefined) {
    throw new Error('useTenantContext must be used within a TenantProvider');
  }
  return context;
}
`
          }
        ],
        documentation: 'Multi-tenancy routing guide',
        complexity: 'medium',
        tags: ['multi-tenancy', 'routing', 'subdomain', 'middleware']
      },

      // Subscription/Billing Services
      {
        name: 'paddle',
        type: 'subscriptions',
        provider: 'paddle',
        version: '2.0.0',
        description: 'Complete payments, tax, and subscription management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/billing/paddle.ts',
            template: `import { Paddle, PaddleProduct, PaddlePrice, PaddleSubscription } from '@paddle/paddle-js';

export class PaddleBilling {
  private paddle: Paddle;

  constructor() {
    this.paddle = new Paddle({
      environment: process.env.PADDLE_ENVIRONMENT as 'sandbox' | 'production' || 'sandbox',
      token: process.env.PADDLE_API_KEY!,
      pwCustomerId: process.env.PADDLE_CUSTOMER_ID
    });
  }

  // Product Management
  async createProduct(data: {
    name: string;
    description?: string;
    taxCategory: string;
    imageUrl?: string;
  }): Promise<PaddleProduct> {
    return await this.paddle.products.create({
      name: data.name,
      description: data.description,
      tax_category: data.taxCategory,
      image_url: data.imageUrl
    });
  }

  async listProducts(): Promise<PaddleProduct[]> {
    const response = await this.paddle.products.list();
    return response.data;
  }

  // Price Management
  async createPrice(data: {
    productId: string;
    amount: string;
    currency: string;
    description?: string;
    billingCycle?: {
      interval: 'day' | 'week' | 'month' | 'year';
      frequency: number;
    };
  }): Promise<PaddlePrice> {
    return await this.paddle.prices.create({
      product_id: data.productId,
      unit_price: {
        amount: data.amount,
        currency_code: data.currency
      },
      description: data.description,
      billing_cycle: data.billingCycle
    });
  }

  // Subscription Management
  async createSubscription(data: {
    customerId: string;
    priceIds: string[];
    currencyCode?: string;
    collectionMode?: 'automatic' | 'manual';
  }): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.create({
      customer_id: data.customerId,
      items: data.priceIds.map(id => ({ price_id: id, quantity: 1 })),
      currency_code: data.currencyCode,
      collection_mode: data.collectionMode
    });
  }

  async getSubscription(subscriptionId: string): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.get(subscriptionId);
  }

  async updateSubscription(
    subscriptionId: string,
    data: {
      priceIds?: string[];
      quantity?: number;
      proration?: 'full_immediately' | 'full_next_billing_period' | 'do_not_bill';
    }
  ): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.update(subscriptionId, {
      items: data.priceIds?.map(id => ({ price_id: id, quantity: data.quantity || 1 })),
      proration: data.proration
    });
  }

  async cancelSubscription(
    subscriptionId: string,
    effectiveFrom?: 'immediately' | 'next_billing_period'
  ): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.cancel(subscriptionId, {
      effective_from: effectiveFrom
    });
  }

  // Customer Management
  async createCustomer(data: {
    email: string;
    name?: string;
    customData?: Record<string, any>;
  }) {
    return await this.paddle.customers.create({
      email: data.email,
      name: data.name,
      custom_data: data.customData
    });
  }

  // Checkout
  async createCheckoutUrl(data: {
    priceIds: string[];
    customerId?: string;
    successUrl?: string;
    customData?: Record<string, any>;
  }): Promise<string> {
    const transaction = await this.paddle.transactions.create({
      items: data.priceIds.map(id => ({ price_id: id, quantity: 1 })),
      customer_id: data.customerId,
      checkout: {
        url: data.successUrl
      },
      custom_data: data.customData
    });

    return transaction.checkout?.url || '';
  }

  // Webhooks
  async handleWebhook(
    signature: string,
    payload: string,
    secret: string
  ): Promise<any> {
    // Verify webhook signature
    const isValid = this.paddle.webhooks.verify(signature, payload, secret);
    
    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = JSON.parse(payload);
    
    // Handle different event types
    switch (event.event_type) {
      case 'subscription.created':
        return this.handleSubscriptionCreated(event);
      case 'subscription.updated':
        return this.handleSubscriptionUpdated(event);
      case 'subscription.canceled':
        return this.handleSubscriptionCanceled(event);
      case 'transaction.completed':
        return this.handleTransactionCompleted(event);
      default:
        console.log(\`Unhandled event type: \${event.event_type}\`);
    }
  }

  private async handleSubscriptionCreated(event: any) {
    // Implementation for subscription created
    console.log('Subscription created:', event);
  }

  private async handleSubscriptionUpdated(event: any) {
    // Implementation for subscription updated
    console.log('Subscription updated:', event);
  }

  private async handleSubscriptionCanceled(event: any) {
    // Implementation for subscription canceled
    console.log('Subscription canceled:', event);
  }

  private async handleTransactionCompleted(event: any) {
    // Implementation for transaction completed
    console.log('Transaction completed:', event);
  }
}

export const paddleBilling = new PaddleBilling();
`
          },
          {
            type: 'file-create',
            target: 'src/app/api/webhooks/paddle/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { paddleBilling } from '@/lib/billing/paddle';

export async function POST(request: NextRequest) {
  try {
    const signature = request.headers.get('paddle-signature') || '';
    const rawBody = await request.text();
    const secret = process.env.PADDLE_WEBHOOK_SECRET!;

    await paddleBilling.handleWebhook(signature, rawBody, secret);

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Paddle webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 400 }
    );
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/billing/PaddleCheckout.tsx',
            template: `import { useEffect } from 'react';
import Script from 'next/script';

interface PaddleCheckoutProps {
  priceIds: string[];
  customerId?: string;
  successCallback?: () => void;
  closeCallback?: () => void;
}

export function PaddleCheckout({
  priceIds,
  customerId,
  successCallback,
  closeCallback
}: PaddleCheckoutProps) {
  useEffect(() => {
    if (typeof window !== 'undefined' && (window as any).Paddle) {
      const paddle = (window as any).Paddle;
      
      paddle.Setup({
        vendor: parseInt(process.env.NEXT_PUBLIC_PADDLE_VENDOR_ID!),
        environment: process.env.NEXT_PUBLIC_PADDLE_ENVIRONMENT
      });
    }
  }, []);

  const openCheckout = () => {
    if (typeof window !== 'undefined' && (window as any).Paddle) {
      const paddle = (window as any).Paddle;
      
      paddle.Checkout.open({
        items: priceIds.map(id => ({ price_id: id, quantity: 1 })),
        customer: customerId ? { id: customerId } : undefined,
        settings: {
          allowLogout: false,
          successUrl: window.location.origin + '/billing/success',
          theme: 'light'
        },
        customData: {
          userId: customerId
        },
        eventCallback: (event: any) => {
          if (event.name === 'checkout.completed') {
            successCallback?.();
          } else if (event.name === 'checkout.closed') {
            closeCallback?.();
          }
        }
      });
    }
  };

  return (
    <>
      <Script
        src="https://cdn.paddle.com/paddle/v2/paddle.js"
        strategy="afterInteractive"
      />
      <button
        onClick={openCheckout}
        className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        Subscribe Now
      </button>
    </>
  );
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@paddle/paddle-js': '^1.0.0'
            }
          }
        ],
        documentation: 'https://developer.paddle.com/',
        complexity: 'medium',
        tags: ['billing', 'subscriptions', 'payments', 'saas', 'paddle']
      },
      {
        name: 'chargebee',
        type: 'subscriptions',
        provider: 'chargebee',
        version: '2.0.0',
        description: 'Subscription billing and revenue management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/billing/chargebee.ts',
            template: `import { ChargeBee } from 'chargebee-typescript';

export class ChargebeeBilling {
  private chargebee: ChargeBee;

  constructor() {
    this.chargebee = new ChargeBee();
    this.chargebee.configure({
      site: process.env.CHARGEBEE_SITE!,
      api_key: process.env.CHARGEBEE_API_KEY!
    });
  }

  // Customer Management
  async createCustomer(data: {
    id?: string;
    email: string;
    firstName?: string;
    lastName?: string;
    company?: string;
    phone?: string;
    billingAddress?: {
      line1: string;
      city: string;
      state?: string;
      country: string;
      zip?: string;
    };
  }) {
    const result = await this.chargebee.customer.create({
      id: data.id,
      email: data.email,
      first_name: data.firstName,
      last_name: data.lastName,
      company: data.company,
      phone: data.phone,
      billing_address: data.billingAddress
    }).request();

    return result.customer;
  }

  async getCustomer(customerId: string) {
    const result = await this.chargebee.customer.retrieve(customerId).request();
    return result.customer;
  }

  async updateCustomer(customerId: string, data: any) {
    const result = await this.chargebee.customer.update(customerId, data).request();
    return result.customer;
  }

  // Subscription Management
  async createSubscription(data: {
    customerId: string;
    planId: string;
    couponIds?: string[];
    trialEnd?: number;
    billingCycles?: number;
    autoCollection?: 'on' | 'off';
    paymentMethodToken?: string;
  }) {
    const params: any = {
      customer_id: data.customerId,
      plan_id: data.planId,
      coupon_ids: data.couponIds,
      trial_end: data.trialEnd,
      billing_cycles: data.billingCycles,
      auto_collection: data.autoCollection
    };

    if (data.paymentMethodToken) {
      params.payment_method = {
        type: 'card',
        gateway_account_id: process.env.CHARGEBEE_GATEWAY_ACCOUNT_ID,
        reference_id: data.paymentMethodToken
      };
    }

    const result = await this.chargebee.subscription
      .createWithItems(data.customerId, {
        subscription_items: [{
          item_price_id: data.planId,
          quantity: 1
        }],
        ...params
      })
      .request();

    return result.subscription;
  }

  async getSubscription(subscriptionId: string) {
    const result = await this.chargebee.subscription
      .retrieve(subscriptionId)
      .request();
    
    return result.subscription;
  }

  async updateSubscription(subscriptionId: string, data: {
    planId?: string;
    quantity?: number;
    trialEnd?: number;
    prorationDate?: number;
  }) {
    const params: any = {};
    
    if (data.planId) {
      params.plan_id = data.planId;
    }
    
    if (data.quantity) {
      params.quantity = data.quantity;
    }
    
    if (data.trialEnd) {
      params.trial_end = data.trialEnd;
    }
    
    if (data.prorationDate) {
      params.prorate_from = data.prorationDate;
    }

    const result = await this.chargebee.subscription
      .update(subscriptionId, params)
      .request();
    
    return result.subscription;
  }

  async cancelSubscription(
    subscriptionId: string,
    options?: {
      endOfTerm?: boolean;
      creditOptionForCurrentTermCharges?: 'none' | 'prorate' | 'full';
    }
  ) {
    const params: any = {
      end_of_term: options?.endOfTerm ?? true,
      credit_option_for_current_term_charges: options?.creditOptionForCurrentTermCharges ?? 'prorate'
    };

    const result = await this.chargebee.subscription
      .cancel(subscriptionId, params)
      .request();
    
    return result.subscription;
  }

  async reactivateSubscription(subscriptionId: string) {
    const result = await this.chargebee.subscription
      .reactivate(subscriptionId)
      .request();
    
    return result.subscription;
  }

  // Plan Management
  async createPlan(data: {
    id: string;
    name: string;
    invoiceName?: string;
    description?: string;
    price: number;
    currencyCode: string;
    period: number;
    periodUnit: 'day' | 'week' | 'month' | 'year';
    trialPeriod?: number;
    trialPeriodUnit?: 'day' | 'week' | 'month' | 'year';
    setupCost?: number;
  }) {
    const result = await this.chargebee.itemPrice.create({
      id: data.id,
      item_id: data.id,
      name: data.name,
      invoice_name: data.invoiceName,
      description: data.description,
      price: data.price,
      currency_code: data.currencyCode,
      period: data.period,
      period_unit: data.periodUnit,
      trial_period: data.trialPeriod,
      trial_period_unit: data.trialPeriodUnit,
      setup_cost: data.setupCost,
      item_type: 'plan',
      pricing_model: 'per_unit'
    }).request();

    return result.item_price;
  }

  // Hosted Pages
  async createCheckoutNewUrl(data: {
    planId: string;
    customer?: {
      email: string;
      firstName?: string;
      lastName?: string;
    };
    successUrl?: string;
    cancelUrl?: string;
    passThruContent?: string;
  }) {
    const params: any = {
      subscription: {
        plan_id: data.planId
      },
      redirect_url: data.successUrl,
      cancel_url: data.cancelUrl,
      pass_thru_content: data.passThruContent
    };

    if (data.customer) {
      params.customer = {
        email: data.customer.email,
        first_name: data.customer.firstName,
        last_name: data.customer.lastName
      };
    }

    const result = await this.chargebee.hostedPage
      .checkoutNew(params)
      .request();

    return result.hosted_page;
  }

  async createPortalSession(customerId: string, options?: {
    redirectUrl?: string;
    forwardUrl?: string;
  }) {
    const result = await this.chargebee.portalSession.create({
      customer: {
        id: customerId
      },
      redirect_url: options?.redirectUrl,
      forward_url: options?.forwardUrl
    }).request();

    return result.portal_session;
  }

  // Webhook handling
  async handleWebhook(body: any, signature: string): Promise<void> {
    // Verify webhook (implement signature verification)
    const isValid = this.verifyWebhookSignature(body, signature);
    
    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = body;

    switch (event.event_type) {
      case 'subscription_created':
        await this.handleSubscriptionCreated(event);
        break;
      case 'subscription_updated':
        await this.handleSubscriptionUpdated(event);
        break;
      case 'subscription_cancelled':
        await this.handleSubscriptionCancelled(event);
        break;
      case 'invoice_generated':
        await this.handleInvoiceGenerated(event);
        break;
      case 'payment_succeeded':
        await this.handlePaymentSucceeded(event);
        break;
      case 'payment_failed':
        await this.handlePaymentFailed(event);
        break;
      default:
        console.log(\`Unhandled event type: \${event.event_type}\`);
    }
  }

  private verifyWebhookSignature(body: any, signature: string): boolean {
    // Implement Chargebee webhook signature verification
    // This is a placeholder - implement actual verification
    return true;
  }

  private async handleSubscriptionCreated(event: any) {
    console.log('Subscription created:', event.content.subscription);
  }

  private async handleSubscriptionUpdated(event: any) {
    console.log('Subscription updated:', event.content.subscription);
  }

  private async handleSubscriptionCancelled(event: any) {
    console.log('Subscription cancelled:', event.content.subscription);
  }

  private async handleInvoiceGenerated(event: any) {
    console.log('Invoice generated:', event.content.invoice);
  }

  private async handlePaymentSucceeded(event: any) {
    console.log('Payment succeeded:', event.content.transaction);
  }

  private async handlePaymentFailed(event: any) {
    console.log('Payment failed:', event.content.transaction);
  }
}

export const chargebeeBilling = new ChargebeeBilling();
`
          },
          {
            type: 'file-create',
            target: 'src/app/api/webhooks/chargebee/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { chargebeeBilling } from '@/lib/billing/chargebee';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const signature = request.headers.get('x-chargebee-signature') || '';

    await chargebeeBilling.handleWebhook(body, signature);

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Chargebee webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 400 }
    );
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              'chargebee-typescript': '^2.0.0'
            }
          }
        ],
        documentation: 'https://apidocs.chargebee.com/',
        complexity: 'medium',
        tags: ['billing', 'subscriptions', 'revenue', 'saas', 'chargebee']
      },

      // i18n (Internationalization) Services
      {
        name: 'next-intl',
        type: 'i18n',
        provider: 'next-intl',
        version: '3.0.0',
        description: 'Internationalization for Next.js with full TypeScript support',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n.ts',
            template: `import { getRequestConfig } from 'next-intl/server';
import { notFound } from 'next/navigation';

// Can be imported from a shared config
export const locales = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type Locale = (typeof locales)[number];

export const defaultLocale: Locale = 'en';

export default getRequestConfig(async ({ locale }) => {
  // Validate that the incoming \`locale\` parameter is valid
  if (!locales.includes(locale as any)) notFound();

  return {
    messages: (await import(\`./messages/\${locale}.json\`)).default
  };
});
`
          },
          {
            type: 'file-create',
            target: 'src/middleware.ts',
            template: `import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from './i18n';

export default createMiddleware({
  // A list of all locales that are supported
  locales,

  // Used when no locale matches
  defaultLocale,

  // Always use a locale prefix for routing
  localePrefix: 'as-needed'
});

export const config = {
  // Match only internationalized pathnames
  matcher: ['/', '/(en|nb|nn|fr|es|de|ar)/:path*']
};
`
          },
          {
            type: 'file-create',
            target: 'src/app/[locale]/layout.tsx',
            template: `import { NextIntlClientProvider } from 'next-intl';
import { getMessages } from 'next-intl/server';
import { notFound } from 'next/navigation';
import { locales } from '@/i18n';

export function generateStaticParams() {
  return locales.map((locale) => ({ locale }));
}

export default async function LocaleLayout({
  children,
  params: { locale }
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  // Ensure that the incoming locale is valid
  if (!locales.includes(locale as any)) {
    notFound();
  }

  // Providing all messages to the client
  const messages = await getMessages();

  return (
    <html lang={locale} dir={locale === 'ar' ? 'rtl' : 'ltr'}>
      <body>
        <NextIntlClientProvider messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/[locale]/page.tsx',
            template: `import { useTranslations } from 'next-intl';
import { Link } from 'next-intl/link';

export default function HomePage() {
  const t = useTranslations('HomePage');

  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
      
      <Link href="/about" locale="en">
        {t('navigation.about')}
      </Link>
    </div>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/messages/en.json',
            template: `{
  "HomePage": {
    "title": "Welcome to our application",
    "description": "This is a multilingual Next.js application",
    "navigation": {
      "about": "About Us",
      "contact": "Contact",
      "services": "Services"
    }
  },
  "common": {
    "loading": "Loading...",
    "error": "An error occurred",
    "retry": "Try again",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "create": "Create",
    "search": "Search",
    "filter": "Filter",
    "sort": "Sort",
    "close": "Close"
  },
  "auth": {
    "login": "Log in",
    "logout": "Log out",
    "signup": "Sign up",
    "forgotPassword": "Forgot password?",
    "resetPassword": "Reset password"
  },
  "errors": {
    "required": "This field is required",
    "email": "Please enter a valid email",
    "minLength": "Must be at least {min} characters",
    "maxLength": "Must be no more than {max} characters"
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/LocaleSwitcher.tsx',
            template: `'use client';

import { useLocale, useTranslations } from 'next-intl';
import { usePathname, useRouter } from 'next-intl/client';
import { locales } from '@/i18n';

export function LocaleSwitcher() {
  const t = useTranslations('LocaleSwitcher');
  const locale = useLocale();
  const router = useRouter();
  const pathname = usePathname();

  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newLocale = event.target.value;
    router.replace(pathname, { locale: newLocale });
  };

  return (
    <select
      value={locale}
      onChange={handleChange}
      className="px-3 py-2 border rounded-md"
      aria-label={t('label')}
    >
      {locales.map((loc) => (
        <option key={loc} value={loc}>
          {t('locale', { locale: loc })}
        </option>
      ))}
    </select>
  );
}
`
          },
          {
            type: 'dependency',
            packages: {
              'next-intl': '^3.0.0'
            }
          }
        ],
        documentation: 'https://next-intl-docs.vercel.app/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'nextjs', 'localization', 'typescript']
      },
      {
        name: 'react-i18next',
        type: 'i18n',
        provider: 'react-i18next',
        version: '13.0.0',
        description: 'Powerful internationalization framework for React',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n/config.ts',
            template: `import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

export const supportedLanguages = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type SupportedLanguage = typeof supportedLanguages[number];

i18n
  // Load translation using http backend
  .use(Backend)
  // Detect user language
  .use(LanguageDetector)
  // Pass the i18n instance to react-i18next
  .use(initReactI18next)
  // Initialize i18next
  .init({
    fallbackLng: 'en',
    debug: process.env.NODE_ENV === 'development',
    
    interpolation: {
      escapeValue: false // React already escapes values
    },

    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json'
    },

    detection: {
      order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage', 'cookie']
    },

    supportedLngs: supportedLanguages,
    
    ns: ['common', 'auth', 'errors', 'navigation'],
    defaultNS: 'common',

    react: {
      useSuspense: false
    }
  });

export default i18n;
`
          },
          {
            type: 'file-create',
            target: 'src/app/layout.tsx',
            template: `import { I18nextProvider } from 'react-i18next';
import i18n from '@/i18n/config';

export default function RootLayout({
  children
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang={i18n.language} dir={i18n.language === 'ar' ? 'rtl' : 'ltr'}>
      <body>
        <I18nextProvider i18n={i18n}>
          {children}
        </I18nextProvider>
      </body>
    </html>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useTranslation.ts',
            template: `import { useTranslation as useI18nTranslation } from 'react-i18next';

export function useTranslation(namespace?: string) {
  return useI18nTranslation(namespace);
}

// Type-safe translation hook
export function useTypedTranslation<T extends Record<string, any>>(namespace: string) {
  const { t, ...rest } = useI18nTranslation(namespace);
  
  return {
    t: (key: keyof T, options?: any) => t(key as string, options),
    ...rest
  };
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/LanguageSwitcher.tsx',
            template: `import { useTranslation } from 'react-i18next';
import { supportedLanguages } from '@/i18n/config';

export function LanguageSwitcher() {
  const { i18n, t } = useTranslation();

  const handleLanguageChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newLang = event.target.value;
    i18n.changeLanguage(newLang);
    
    // Update HTML attributes
    document.documentElement.lang = newLang;
    document.documentElement.dir = newLang === 'ar' ? 'rtl' : 'ltr';
  };

  return (
    <select
      value={i18n.language}
      onChange={handleLanguageChange}
      className="px-3 py-2 border rounded-md"
      aria-label={t('languageSwitcher.label')}
    >
      {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
          {t(\`languageSwitcher.languages.\${lang}\`)}
        </option>
      ))}
    </select>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'public/locales/en/common.json',
            template: `{
  "welcome": "Welcome",
  "loading": "Loading...",
  "error": "An error occurred",
  "retry": "Try again",
  "save": "Save",
  "cancel": "Cancel",
  "delete": "Delete",
  "edit": "Edit",
  "create": "Create",
  "search": "Search",
  "filter": "Filter",
  "sort": "Sort",
  "close": "Close",
  "languageSwitcher": {
    "label": "Select language",
    "languages": {
      "en": "English",
      "nb": "Norsk bokmål",
      "nn": "Norsk nynorsk",
      "fr": "Français",
      "es": "Español",
      "de": "Deutsch",
      "ar": "العربية"
    }
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              'react-i18next': '^13.0.0',
              'i18next': '^23.0.0',
              'i18next-browser-languagedetector': '^7.0.0',
              'i18next-http-backend': '^2.0.0'
            }
          }
        ],
        documentation: 'https://react.i18next.com/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'react', 'localization', 'translation']
      },
      {
        name: 'formatjs',
        type: 'i18n',
        provider: 'formatjs',
        version: '6.0.0',
        description: 'Internationalization libraries by FormatJS (React Intl)',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n/provider.tsx',
            template: `import { IntlProvider } from 'react-intl';
import { ReactNode, useState, useEffect } from 'react';

type Messages = Record<string, string>;

interface I18nProviderProps {
  children: ReactNode;
  defaultLocale?: string;
}

export const supportedLocales = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type SupportedLocale = typeof supportedLocales[number];

async function loadMessages(locale: string): Promise<Messages> {
  try {
    const messages = await import(\`../messages/\${locale}.json\`);
    return messages.default;
  } catch (error) {
    console.error(\`Failed to load messages for locale \${locale}\`, error);
    // Fallback to English
    const messages = await import('../messages/en.json');
    return messages.default;
  }
}

export function I18nProvider({ 
  children, 
  defaultLocale = 'en' 
}: I18nProviderProps) {
  const [locale, setLocale] = useState<string>(defaultLocale);
  const [messages, setMessages] = useState<Messages>({});
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadMessages(locale).then((loadedMessages) => {
      setMessages(loadedMessages);
      setLoading(false);
    });
  }, [locale]);

  if (loading) {
    return <div>Loading translations...</div>;
  }

  return (
    <IntlProvider
      locale={locale}
      messages={messages}
      onError={(err) => {
        if (err.code === 'MISSING_TRANSLATION') {
          console.warn(\`Missing translation: \${err.message}\`);
          return;
        }
        throw err;
      }}
    >
      {children}
    </IntlProvider>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useIntl.ts',
            template: `import { useIntl as useReactIntl, MessageDescriptor } from 'react-intl';

export function useIntl() {
  const intl = useReactIntl();

  // Enhanced formatMessage with type safety
  const formatMessage = (
    descriptor: MessageDescriptor,
    values?: Record<string, any>
  ) => {
    return intl.formatMessage(descriptor, values);
  };

  // Format number with currency
  const formatCurrency = (amount: number, currency = 'USD') => {
    return intl.formatNumber(amount, {
      style: 'currency',
      currency
    });
  };

  // Format relative time
  const formatRelativeTime = (date: Date | number, unit?: any) => {
    const rtf = new Intl.RelativeTimeFormat(intl.locale, {
      numeric: 'auto'
    });
    
    // Calculate relative time
    const now = new Date().getTime();
    const then = typeof date === 'number' ? date : date.getTime();
    const diff = then - now;
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (Math.abs(days) > 0) return rtf.format(days, 'day');
    if (Math.abs(hours) > 0) return rtf.format(hours, 'hour');
    if (Math.abs(minutes) > 0) return rtf.format(minutes, 'minute');
    return rtf.format(seconds, 'second');
  };

  return {
    ...intl,
    formatMessage,
    formatCurrency,
    formatRelativeTime
  };
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/FormattedMessage.tsx',
            template: `import { FormattedMessage as IntlFormattedMessage } from 'react-intl';

interface FormattedMessageProps {
  id: string;
  defaultMessage?: string;
  values?: Record<string, any>;
  description?: string;
}

export function FormattedMessage({
  id,
  defaultMessage,
  values,
  description
}: FormattedMessageProps) {
  return (
    <IntlFormattedMessage
      id={id}
      defaultMessage={defaultMessage}
      values={values}
      description={description}
    />
  );
}

// Type-safe message component
export function TypedMessage<T extends Record<string, any>>({
  id,
  values
}: {
  id: keyof T;
  values?: Record<string, any>;
}) {
  return (
    <IntlFormattedMessage
      id={id as string}
      values={values}
    />
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/messages/en.json',
            template: `{
  "app.title": "Welcome to our application",
  "app.description": "This is a multilingual application using FormatJS",
  "nav.home": "Home",
  "nav.about": "About",
  "nav.contact": "Contact",
  "nav.services": "Services",
  "common.loading": "Loading...",
  "common.error": "An error occurred",
  "common.retry": "Try again",
  "common.save": "Save",
  "common.cancel": "Cancel",
  "common.delete": "Delete",
  "common.edit": "Edit",
  "common.create": "Create",
  "common.search": "Search",
  "common.filter": "Filter",
  "common.sort": "Sort",
  "common.close": "Close",
  "auth.login": "Log in",
  "auth.logout": "Log out",
  "auth.signup": "Sign up",
  "auth.forgotPassword": "Forgot password?",
  "auth.resetPassword": "Reset password",
  "validation.required": "This field is required",
  "validation.email": "Please enter a valid email",
  "validation.minLength": "Must be at least {min} characters",
  "validation.maxLength": "Must be no more than {max} characters",
  "format.currency": "{amount, number, currency}",
  "format.date": "{date, date, long}",
  "format.time": "{time, time, short}",
  "format.relative": "{date, relative}"
}
`
          },
          {
            type: 'dependency',
            packages: {
              'react-intl': '^6.0.0',
              '@formatjs/intl-relativetimeformat': '^11.0.0',
              '@formatjs/intl-locale': '^3.0.0',
              '@formatjs/intl-pluralrules': '^5.0.0',
              '@formatjs/intl-numberformat': '^8.0.0'
            }
          }
        ],
        documentation: 'https://formatjs.io/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'react', 'formatjs', 'intl']
      },
      {
        name: 'crowdin',
        type: 'i18n',
        provider: 'crowdin',
        version: '1.0.0',
        description: 'Localization management platform integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'crowdin.yml',
            template: `project_id: '${CROWDIN_PROJECT_ID}'
api_token: '${CROWDIN_API_TOKEN}'

preserve_hierarchy: true

files:
  - source: /src/messages/en.json
    translation: /src/messages/%locale%.json
    
  - source: /public/locales/en/**/*.json
    translation: /public/locales/%locale%/**/%original_file_name%

  - source: /content/en/**/*.md
    translation: /content/%locale%/**/%original_file_name%

export_languages: ['nb', 'nn', 'fr', 'es', 'de', 'ar']

bundles:
  - mode: bundle
    name: app-translations
    format: react-intl
    sources:
      - /src/messages/en.json
    
  - mode: bundle
    name: content-translations
    format: markdown
    sources:
      - /content/en/**/*.md
`
          },
          {
            type: 'file-create',
            target: 'scripts/crowdin-sync.ts',
            template: `import crowdin, { SourceFilesModel } from '@crowdin/crowdin-api-client';
import * as fs from 'fs';
import * as path from 'path';

const { uploadStorageApi, sourceFilesApi, translationsApi } = new crowdin({
  token: process.env.CROWDIN_API_TOKEN!
});

const projectId = parseInt(process.env.CROWDIN_PROJECT_ID!);

interface SyncOptions {
  upload?: boolean;
  download?: boolean;
  languages?: string[];
}

export async function syncTranslations(options: SyncOptions = {}) {
  const { upload = true, download = true, languages = [] } = options;

  if (upload) {
    await uploadSourceFiles();
  }

  if (download) {
    await downloadTranslations(languages);
  }
}

async function uploadSourceFiles() {
  console.log('Uploading source files to Crowdin...');

  const sourceFiles = [
    'src/messages/en.json',
    'public/locales/en/common.json',
    'public/locales/en/auth.json',
    'public/locales/en/errors.json'
  ];

  for (const filePath of sourceFiles) {
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const fileName = path.basename(filePath);
      
      // Upload file to storage
      const storageResponse = await uploadStorageApi.addStorage(
        fileName,
        fileContent
      );
      
      // Update or create source file
      try {
        await sourceFilesApi.updateOrCreateFile(projectId, {
          storageId: storageResponse.data.id,
          name: fileName,
          directoryId: undefined, // root directory
          title: fileName,
          type: 'json'
        });
        
        console.log(\`✓ Uploaded \${filePath}\`);
      } catch (error) {
        console.error(\`✗ Failed to upload \${filePath}:\`, error);
      }
    } catch (error) {
      console.error(\`✗ Failed to read \${filePath}:\`, error);
    }
  }
}

async function downloadTranslations(languages: string[]) {
  console.log('Downloading translations from Crowdin...');

  const targetLanguages = languages.length > 0 
    ? languages 
    : ['nb', 'nn', 'fr', 'es', 'de', 'ar'];

  for (const language of targetLanguages) {
    try {
      // Build translations
      const buildResponse = await translationsApi.buildProjectTranslation(
        projectId,
        { targetLanguageId: language }
      );
      
      // Wait for build to complete
      await waitForBuild(buildResponse.data.id);
      
      // Download translations
      const downloadUrl = await translationsApi.downloadTranslations(
        projectId,
        buildResponse.data.id
      );
      
      // Download and extract files
      await downloadAndExtractTranslations(downloadUrl.data.url, language);
      
      console.log(\`✓ Downloaded translations for \${language}\`);
    } catch (error) {
      console.error(\`✗ Failed to download \${language}:\`, error);
    }
  }
}

async function waitForBuild(buildId: number) {
  // Implementation to wait for build completion
  // Poll the build status until it's finished
}

async function downloadAndExtractTranslations(url: string, language: string) {
  // Implementation to download ZIP and extract translations
  // Place files in appropriate directories
}

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const options: SyncOptions = {};
  
  if (args.includes('--upload-only')) {
    options.download = false;
  }
  
  if (args.includes('--download-only')) {
    options.upload = false;
  }
  
  const langIndex = args.indexOf('--languages');
  if (langIndex !== -1 && args[langIndex + 1]) {
    options.languages = args[langIndex + 1].split(',');
  }
  
  syncTranslations(options)
    .then(() => console.log('✓ Sync complete'))
    .catch((error) => console.error('✗ Sync failed:', error));
}
`
          },
          {
            type: 'file-create',
            target: '.github/workflows/crowdin.yml',
            template: `name: Crowdin Sync

on:
  push:
    branches: [main]
    paths:
      - 'src/messages/en.json'
      - 'public/locales/en/**/*.json'
      - 'content/en/**/*.md'
  
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  
  workflow_dispatch:
    inputs:
      sync_type:
        description: 'Sync type'
        required: true
        default: 'both'
        type: choice
        options:
          - upload
          - download
          - both

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Upload sources
        if: \${{ github.event_name == 'push' || github.event.inputs.sync_type == 'upload' || github.event.inputs.sync_type == 'both' }}
        run: npm run crowdin:upload
        env:
          CROWDIN_PROJECT_ID: \${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: \${{ secrets.CROWDIN_API_TOKEN }}
      
      - name: Download translations
        if: \${{ github.event_name == 'schedule' || github.event.inputs.sync_type == 'download' || github.event.inputs.sync_type == 'both' }}
        run: npm run crowdin:download
        env:
          CROWDIN_PROJECT_ID: \${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: \${{ secrets.CROWDIN_API_TOKEN }}
      
      - name: Create Pull Request
        if: \${{ github.event_name == 'schedule' || github.event.inputs.sync_type == 'download' || github.event.inputs.sync_type == 'both' }}
        uses: peter-evans/create-pull-request@v5
        with:
          token: \${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore: update translations from Crowdin'
          title: '🌍 Update translations from Crowdin'
          body: |
            This PR updates translations from Crowdin.
            
            - Updated language files
            - Synchronized with latest translations
            
            Please review the changes before merging.
          branch: crowdin-translations
          delete-branch: true
`
          },
          {
            type: 'dependency',
            packages: {
              '@crowdin/crowdin-api-client': '^1.0.0'
            },
            devDependencies: {
              '@crowdin/cli': '^3.0.0'
            }
          }
        ],
        documentation: 'https://developer.crowdin.com/',
        complexity: 'high',
        tags: ['i18n', 'localization', 'translation-management', 'crowdin', 'ci-cd']
      }
    ];

    // Register built-in templates
    for (const template of builtInTemplates) {
      await this.registerTemplate(template);
    }
  }
}