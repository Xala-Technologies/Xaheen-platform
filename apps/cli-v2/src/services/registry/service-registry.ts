/**
 * Service Registry Implementation
 * 
 * Central registry for managing service templates and definitions.
 * 
 * @author Backend Expert Agent
 * @since 2025-01-03
 */

import { consola } from 'consola';
import fs from 'fs-extra';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { dirname } from 'node:path';

import type { IServiceRegistry, ServiceTemplate, ServiceType } from '../../types/index.js';
import { ServiceTemplateSchema } from '../../types/index.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

export class ServiceRegistry implements IServiceRegistry {
  private templates: Map<string, ServiceTemplate> = new Map();
  private initialized = false;
  private templatesPath: string;

  constructor() {
    // Service templates are stored in src/services/templates/definitions
    this.templatesPath = path.join(__dirname, '../templates/definitions');
  }

  async initialize(): Promise<void> {
    if (this.initialized) return;

    consola.debug('Initializing service registry...');

    try {
      await this.loadServiceTemplates();
      this.initialized = true;
      consola.debug(`Service registry initialized with ${this.templates.size} templates`);
    } catch (error) {
      consola.error('Failed to initialize service registry:', error);
      throw new Error('Service registry initialization failed');
    }
  }

  async getTemplate(type: ServiceType | string, provider: string): Promise<ServiceTemplate | null> {
    const key = `${type}:${provider}`;
    return this.templates.get(key) || null;
  }

  async listTemplates(type?: ServiceType | string): Promise<ServiceTemplate[]> {
    const templates = Array.from(this.templates.values());
    
    if (type) {
      return templates.filter(t => t.type === type);
    }
    
    return templates;
  }

  async registerTemplate(template: ServiceTemplate): Promise<void> {
    // Validate template
    const result = ServiceTemplateSchema.safeParse(template);
    if (!result.success) {
      throw new Error(`Invalid template: ${result.error.message}`);
    }

    const key = `${template.type}:${template.provider}`;
    this.templates.set(key, template);
    
    consola.debug(`Registered template: ${key}`);
  }

  private async loadServiceTemplates(): Promise<void> {
    // Create templates directory if it doesn't exist
    await fs.ensureDir(this.templatesPath);

    // Load built-in templates
    await this.loadBuiltInTemplates();

    // Load custom templates from JSON files
    const files = await fs.readdir(this.templatesPath);
    const jsonFiles = files.filter(f => f.endsWith('.json'));

    for (const file of jsonFiles) {
      try {
        const filePath = path.join(this.templatesPath, file);
        const content = await fs.readJson(filePath);
        
        // Validate and register template
        const result = ServiceTemplateSchema.safeParse(content);
        if (result.success) {
          await this.registerTemplate(result.data);
        } else {
          consola.warn(`Invalid template in ${file}:`, result.error.message);
        }
      } catch (error) {
        consola.warn(`Failed to load template ${file}:`, error);
      }
    }
  }

  private async loadBuiltInTemplates(): Promise<void> {
    // Built-in templates for common services
    const builtInTemplates: ServiceTemplate[] = [
      // Frontend Framework Services
      {
        name: 'nextjs',
        type: 'frontend',
        provider: 'vercel',
        version: '14.0.0',
        description: 'React framework with hybrid SSR/SSG and full-stack capabilities',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'next.config.js',
            template: `/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ['localhost'],
  },
  experimental: {
    serverActions: true,
  },
}

module.exports = nextConfig
`
          },
          {
            type: 'file-create',
            target: 'src/app/layout.tsx',
            template: `import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'Create Next App',
  description: 'Generated by create next app',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>{children}</body>
    </html>
  )
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/page.tsx',
            template: `export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-between p-24">
      <h1 className="text-4xl font-bold">Welcome to Next.js!</h1>
    </main>
  )
}
`
          },
          {
            type: 'dependency',
            packages: {
              'next': '^14.0.0',
              'react': '^18.0.0',
              'react-dom': '^18.0.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              '@types/react': '^18.0.0',
              '@types/react-dom': '^18.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://nextjs.org/docs',
        complexity: 'medium',
        tags: ['react', 'ssr', 'ssg', 'full-stack', 'vercel']
      },
      {
        name: 'nuxt',
        type: 'frontend',
        provider: 'nuxt',
        version: '3.0.0',
        description: 'Vue.js framework with SSR, SSG, and full-stack capabilities',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'nuxt.config.ts',
            template: `export default defineNuxtConfig({
  devtools: { enabled: true },
  modules: [
    '@nuxtjs/tailwindcss',
    '@pinia/nuxt',
  ],
  css: ['~/assets/css/main.css'],
  typescript: {
    strict: true
  }
})
`
          },
          {
            type: 'file-create',
            target: 'app.vue',
            template: `<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>
`
          },
          {
            type: 'file-create',
            target: 'pages/index.vue',
            template: `<template>
  <div class="min-h-screen flex items-center justify-center">
    <h1 class="text-4xl font-bold">Welcome to Nuxt 3!</h1>
  </div>
</template>

<script setup lang="ts">
// Page meta
useHead({
  title: 'Home',
  meta: [
    { name: 'description', content: 'Welcome to Nuxt 3' }
  ]
})
</script>
`
          },
          {
            type: 'dependency',
            packages: {
              'nuxt': '^3.0.0',
              'vue': '^3.0.0',
              'vue-router': '^4.0.0'
            },
            devDependencies: {
              '@nuxt/devtools': 'latest',
              '@nuxtjs/tailwindcss': '^6.0.0',
              '@pinia/nuxt': '^0.5.0'
            }
          }
        ],
        documentation: 'https://nuxt.com/docs',
        complexity: 'medium',
        tags: ['vue', 'ssr', 'ssg', 'full-stack', 'nitro']
      },
      {
        name: 'sveltekit',
        type: 'frontend',
        provider: 'svelte',
        version: '2.0.0',
        description: 'Svelte app framework with SSR and filesystem-based routing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'svelte.config.js',
            template: `import adapter from '@sveltejs/adapter-auto';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

/** @type {import('@sveltejs/kit').Config} */
const config = {
  preprocess: vitePreprocess(),
  kit: {
    adapter: adapter()
  }
};

export default config;
`
          },
          {
            type: 'file-create',
            target: 'src/routes/+layout.svelte',
            template: `<script>
  import '../app.css';
</script>

<slot />
`
          },
          {
            type: 'file-create',
            target: 'src/routes/+page.svelte',
            template: `<script lang="ts">
  import { onMount } from 'svelte';
  
  let message = 'Welcome to SvelteKit!';
</script>

<main class="min-h-screen flex items-center justify-center">
  <h1 class="text-4xl font-bold">{message}</h1>
</main>
`
          },
          {
            type: 'dependency',
            packages: {
              '@sveltejs/kit': '^2.0.0',
              'svelte': '^4.0.0'
            },
            devDependencies: {
              '@sveltejs/adapter-auto': '^3.0.0',
              '@sveltejs/vite-plugin-svelte': '^3.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://kit.svelte.dev/docs',
        complexity: 'medium',
        tags: ['svelte', 'ssr', 'ssg', 'vite', 'filesystem-routing']
      },
      {
        name: 'react',
        type: 'frontend',
        provider: 'facebook',
        version: '18.0.0',
        description: 'A JavaScript library for building user interfaces',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/App.tsx',
            template: `import React, { useState } from 'react';
import './App.css';

function App() {
  const [count, setCount] = useState(0);

  return (
    <div className="App">
      <header className="App-header">
        <h1>Welcome to React!</h1>
        <p>Count: {count}</p>
        <button onClick={() => setCount(count + 1)}>
          Increment
        </button>
      </header>
    </div>
  );
}

export default App;
`
          },
          {
            type: 'file-create',
            target: 'src/main.tsx',
            template: `import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)
`
          },
          {
            type: 'dependency',
            packages: {
              'react': '^18.0.0',
              'react-dom': '^18.0.0'
            },
            devDependencies: {
              '@types/react': '^18.0.0',
              '@types/react-dom': '^18.0.0',
              '@vitejs/plugin-react': '^4.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://react.dev/',
        complexity: 'low',
        tags: ['react', 'spa', 'ui-library', 'component-based']
      },
      {
        name: 'vue',
        type: 'frontend',
        provider: 'vue',
        version: '3.0.0',
        description: 'The progressive JavaScript framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/App.vue',
            template: `<template>
  <div id="app">
    <h1>{{ message }}</h1>
    <p>Count: {{ count }}</p>
    <button @click="increment">Increment</button>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue'

const message = ref('Welcome to Vue 3!')
const count = ref(0)

const increment = () => {
  count.value++
}
</script>

<style scoped>
#app {
  font-family: Avenir, Helvetica, Arial, sans-serif;
  text-align: center;
  margin-top: 60px;
}
</style>
`
          },
          {
            type: 'file-create',
            target: 'src/main.ts',
            template: `import { createApp } from 'vue'
import './style.css'
import App from './App.vue'

createApp(App).mount('#app')
`
          },
          {
            type: 'dependency',
            packages: {
              'vue': '^3.0.0'
            },
            devDependencies: {
              '@vitejs/plugin-vue': '^4.0.0',
              'vite': '^5.0.0',
              'typescript': '^5.0.0',
              'vue-tsc': '^1.0.0'
            }
          }
        ],
        documentation: 'https://vuejs.org/guide/',
        complexity: 'low',
        tags: ['vue', 'spa', 'progressive', 'reactive']
      },
      {
        name: 'angular',
        type: 'frontend',
        provider: 'google',
        version: '17.0.0',
        description: 'Platform for building mobile and desktop web applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'angular.json',
            template: `{
  "$schema": "./node_modules/@angular/cli/lib/config/schema.json",
  "version": 1,
  "newProjectRoot": "projects",
  "projects": {
    "app": {
      "projectType": "application",
      "root": "",
      "sourceRoot": "src",
      "prefix": "app",
      "architect": {
        "build": {
          "builder": "@angular-devkit/build-angular:browser",
          "options": {
            "outputPath": "dist/app",
            "index": "src/index.html",
            "main": "src/main.ts",
            "polyfills": ["zone.js"],
            "tsConfig": "tsconfig.app.json",
            "assets": ["src/favicon.ico", "src/assets"],
            "styles": ["src/styles.css"],
            "scripts": []
          }
        }
      }
    }
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/app.component.ts',
            template: `import { Component } from '@angular/core';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-root',
  standalone: true,
  imports: [CommonModule],
  template: \`
    <div class="container">
      <h1>Welcome to {{ title }}!</h1>
      <p>Count: {{ count }}</p>
      <button (click)="increment()">Increment</button>
    </div>
  \`,
  styles: [\`
    .container {
      text-align: center;
      padding: 50px;
    }
  \`]
})
export class AppComponent {
  title = 'Angular';
  count = 0;

  increment() {
    this.count++;
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@angular/animations': '^17.0.0',
              '@angular/common': '^17.0.0',
              '@angular/compiler': '^17.0.0',
              '@angular/core': '^17.0.0',
              '@angular/forms': '^17.0.0',
              '@angular/platform-browser': '^17.0.0',
              '@angular/platform-browser-dynamic': '^17.0.0',
              '@angular/router': '^17.0.0',
              'rxjs': '^7.0.0',
              'tslib': '^2.0.0',
              'zone.js': '^0.14.0'
            },
            devDependencies: {
              '@angular-devkit/build-angular': '^17.0.0',
              '@angular/cli': '^17.0.0',
              '@angular/compiler-cli': '^17.0.0',
              'typescript': '~5.2.0'
            }
          }
        ],
        documentation: 'https://angular.io/docs',
        complexity: 'high',
        tags: ['angular', 'typescript', 'enterprise', 'full-framework']
      },

      // Backend Framework Services
      {
        name: 'hono',
        type: 'backend',
        provider: 'hono',
        version: '3.0.0',
        description: 'Ultrafast web framework for the Edge',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/index.ts',
            template: `import { Hono } from 'hono'
import { cors } from 'hono/cors'
import { logger } from 'hono/logger'
import { prettyJSON } from 'hono/pretty-json'

const app = new Hono()

// Middleware
app.use('*', logger())
app.use('*', cors())
app.use('*', prettyJSON())

// Routes
app.get('/', (c) => {
  return c.json({ message: 'Welcome to Hono!' })
})

app.get('/api/users', (c) => {
  return c.json({ users: [] })
})

app.post('/api/users', async (c) => {
  const body = await c.req.json()
  return c.json({ user: body }, 201)
})

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import { serve } from '@hono/node-server'
import app from './index'

const port = 3000
console.log(\`Server is running on port \${port}\`)

serve({
  fetch: app.fetch,
  port
})
`
          },
          {
            type: 'dependency',
            packages: {
              'hono': '^3.0.0',
              '@hono/node-server': '^1.0.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              'tsx': '^4.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://hono.dev/',
        complexity: 'low',
        tags: ['edge', 'fast', 'lightweight', 'web-framework']
      },
      {
        name: 'express',
        type: 'backend',
        provider: 'express',
        version: '4.18.0',
        description: 'Fast, unopinionated, minimalist web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import express, { Express, Request, Response } from 'express'
import cors from 'cors'
import helmet from 'helmet'
import morgan from 'morgan'
import { errorHandler } from './middleware/errorHandler'

const app: Express = express()

// Middleware
app.use(helmet())
app.use(cors())
app.use(morgan('dev'))
app.use(express.json())
app.use(express.urlencoded({ extended: true }))

// Routes
app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Welcome to Express!' })
})

app.get('/api/users', (req: Request, res: Response) => {
  res.json({ users: [] })
})

app.post('/api/users', (req: Request, res: Response) => {
  const user = req.body
  res.status(201).json({ user })
})

// Error handling
app.use(errorHandler)

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import app from './app'
import dotenv from 'dotenv'

dotenv.config()

const PORT = process.env.PORT || 3000

app.listen(PORT, () => {
  console.log(\`Server is running on port \${PORT}\`)
})
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/errorHandler.ts',
            template: `import { Request, Response, NextFunction } from 'express'

export const errorHandler = (
  err: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  console.error(err.stack)
  res.status(500).json({
    message: 'Something went wrong!',
    error: process.env.NODE_ENV === 'production' ? {} : err
  })
}
`
          },
          {
            type: 'dependency',
            packages: {
              'express': '^4.18.0',
              'cors': '^2.8.5',
              'helmet': '^7.0.0',
              'morgan': '^1.10.0',
              'dotenv': '^16.0.0'
            },
            devDependencies: {
              '@types/express': '^4.17.0',
              '@types/cors': '^2.8.0',
              '@types/morgan': '^1.9.0',
              '@types/node': '^20.0.0',
              'nodemon': '^3.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://expressjs.com/',
        complexity: 'low',
        tags: ['nodejs', 'web-framework', 'rest-api', 'traditional']
      },
      {
        name: 'fastify',
        type: 'backend',
        provider: 'fastify',
        version: '4.0.0',
        description: 'Fast and low overhead web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import Fastify from 'fastify'
import cors from '@fastify/cors'
import helmet from '@fastify/helmet'
import { TypeBoxTypeProvider } from '@fastify/type-provider-typebox'
import { Type } from '@sinclair/typebox'

const fastify = Fastify({
  logger: true
}).withTypeProvider<TypeBoxTypeProvider>()

// Register plugins
fastify.register(cors)
fastify.register(helmet)

// Schemas
const UserSchema = Type.Object({
  id: Type.String(),
  name: Type.String(),
  email: Type.String({ format: 'email' })
})

// Routes
fastify.get('/', async (request, reply) => {
  return { message: 'Welcome to Fastify!' }
})

fastify.get('/api/users', {
  schema: {
    response: {
      200: Type.Array(UserSchema)
    }
  }
}, async (request, reply) => {
  return []
})

fastify.post('/api/users', {
  schema: {
    body: Type.Omit(UserSchema, ['id']),
    response: {
      201: UserSchema
    }
  }
}, async (request, reply) => {
  const user = {
    id: crypto.randomUUID(),
    ...request.body
  }
  reply.code(201).send(user)
})

export default fastify
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import fastify from './app'

const start = async () => {
  try {
    await fastify.listen({ port: 3000, host: '0.0.0.0' })
  } catch (err) {
    fastify.log.error(err)
    process.exit(1)
  }
}

start()
`
          },
          {
            type: 'dependency',
            packages: {
              'fastify': '^4.0.0',
              '@fastify/cors': '^8.0.0',
              '@fastify/helmet': '^11.0.0',
              '@fastify/type-provider-typebox': '^3.0.0',
              '@sinclair/typebox': '^0.31.0'
            },
            devDependencies: {
              '@types/node': '^20.0.0',
              'tsx': '^4.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://www.fastify.io/',
        complexity: 'medium',
        tags: ['nodejs', 'fast', 'schema-based', 'typescript']
      },
      {
        name: 'nestjs',
        type: 'backend',
        provider: 'nestjs',
        version: '10.0.0',
        description: 'Progressive Node.js framework for building efficient and scalable server-side applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/main.ts',
            template: `import { NestFactory } from '@nestjs/core';
import { AppModule } from './app.module';
import { ValidationPipe } from '@nestjs/common';
import { SwaggerModule, DocumentBuilder } from '@nestjs/swagger';

async function bootstrap() {
  const app = await NestFactory.create(AppModule);
  
  // Global pipes
  app.useGlobalPipes(new ValidationPipe());
  
  // Swagger documentation
  const config = new DocumentBuilder()
    .setTitle('API Documentation')
    .setDescription('The API description')
    .setVersion('1.0')
    .addTag('users')
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup('api', app, document);
  
  await app.listen(3000);
}
bootstrap();
`
          },
          {
            type: 'file-create',
            target: 'src/app.module.ts',
            template: `import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';
import { UsersModule } from './users/users.module';

@Module({
  imports: [UsersModule],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
`
          },
          {
            type: 'file-create',
            target: 'src/users/users.controller.ts',
            template: `import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { ApiTags, ApiOperation } from '@nestjs/swagger';
import { UsersService } from './users.service';
import { CreateUserDto } from './dto/create-user.dto';
import { UpdateUserDto } from './dto/update-user.dto';

@ApiTags('users')
@Controller('users')
export class UsersController {
  constructor(private readonly usersService: UsersService) {}

  @Post()
  @ApiOperation({ summary: 'Create user' })
  create(@Body() createUserDto: CreateUserDto) {
    return this.usersService.create(createUserDto);
  }

  @Get()
  @ApiOperation({ summary: 'Get all users' })
  findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  @ApiOperation({ summary: 'Get user by id' })
  findOne(@Param('id') id: string) {
    return this.usersService.findOne(id);
  }

  @Put(':id')
  @ApiOperation({ summary: 'Update user' })
  update(@Param('id') id: string, @Body() updateUserDto: UpdateUserDto) {
    return this.usersService.update(id, updateUserDto);
  }

  @Delete(':id')
  @ApiOperation({ summary: 'Delete user' })
  remove(@Param('id') id: string) {
    return this.usersService.remove(id);
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@nestjs/common': '^10.0.0',
              '@nestjs/core': '^10.0.0',
              '@nestjs/platform-express': '^10.0.0',
              '@nestjs/swagger': '^7.0.0',
              'class-transformer': '^0.5.0',
              'class-validator': '^0.14.0',
              'reflect-metadata': '^0.1.0',
              'rxjs': '^7.0.0'
            },
            devDependencies: {
              '@nestjs/cli': '^10.0.0',
              '@nestjs/schematics': '^10.0.0',
              '@nestjs/testing': '^10.0.0',
              '@types/node': '^20.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://nestjs.com/',
        complexity: 'high',
        tags: ['nodejs', 'typescript', 'enterprise', 'decorators', 'dependency-injection']
      },
      {
        name: 'koa',
        type: 'backend',
        provider: 'koa',
        version: '2.0.0',
        description: 'Next generation web framework for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app.ts',
            template: `import Koa from 'koa'
import Router from '@koa/router'
import bodyParser from 'koa-bodyparser'
import cors from '@koa/cors'
import logger from 'koa-logger'
import helmet from 'koa-helmet'

const app = new Koa()
const router = new Router()

// Middleware
app.use(helmet())
app.use(cors())
app.use(logger())
app.use(bodyParser())

// Error handling
app.use(async (ctx, next) => {
  try {
    await next()
  } catch (err: any) {
    ctx.status = err.status || 500
    ctx.body = {
      message: err.message,
      error: process.env.NODE_ENV === 'production' ? {} : err
    }
  }
})

// Routes
router.get('/', (ctx) => {
  ctx.body = { message: 'Welcome to Koa!' }
})

router.get('/api/users', (ctx) => {
  ctx.body = { users: [] }
})

router.post('/api/users', (ctx) => {
  const user = ctx.request.body
  ctx.status = 201
  ctx.body = { user }
})

app.use(router.routes()).use(router.allowedMethods())

export default app
`
          },
          {
            type: 'file-create',
            target: 'src/server.ts',
            template: `import app from './app'

const PORT = process.env.PORT || 3000

app.listen(PORT, () => {
  console.log(\`Server is running on port \${PORT}\`)
})
`
          },
          {
            type: 'dependency',
            packages: {
              'koa': '^2.0.0',
              '@koa/router': '^12.0.0',
              '@koa/cors': '^5.0.0',
              'koa-bodyparser': '^4.0.0',
              'koa-helmet': '^7.0.0',
              'koa-logger': '^3.0.0'
            },
            devDependencies: {
              '@types/koa': '^2.0.0',
              '@types/koa__router': '^12.0.0',
              '@types/koa-bodyparser': '^4.0.0',
              '@types/koa-logger': '^3.0.0',
              '@types/node': '^20.0.0',
              'typescript': '^5.0.0'
            }
          }
        ],
        documentation: 'https://koajs.com/',
        complexity: 'medium',
        tags: ['nodejs', 'async', 'middleware', 'minimalist']
      },

      // Backend - Laravel (PHP)
      {
        name: 'laravel',
        type: 'backend',
        provider: 'laravel',
        version: '11.0.0',
        description: 'The PHP Framework for Web Artisans',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'composer.json',
            template: `{
    "name": "laravel/laravel",
    "type": "project",
    "description": "The Laravel Framework.",
    "require": {
        "php": "^8.2",
        "guzzlehttp/guzzle": "^7.8",
        "laravel/framework": "^11.0",
        "laravel/sanctum": "^4.0",
        "laravel/tinker": "^2.9"
    },
    "require-dev": {
        "fakerphp/faker": "^1.23",
        "laravel/pint": "^1.13",
        "laravel/sail": "^1.26",
        "mockery/mockery": "^1.6",
        "nunomaduro/collision": "^8.0",
        "phpunit/phpunit": "^10.5",
        "spatie/laravel-ignition": "^2.4"
    },
    "autoload": {
        "psr-4": {
            "App\\\\": "app/",
            "Database\\\\Factories\\\\": "database/factories/",
            "Database\\\\Seeders\\\\": "database/seeders/"
        }
    },
    "scripts": {
        "post-autoload-dump": [
            "Illuminate\\\\Foundation\\\\ComposerScripts::postAutoloadDump",
            "@php artisan package:discover --ansi"
        ],
        "post-create-project-cmd": [
            "@php artisan key:generate --ansi",
            "@php -r \\"file_exists('.env') || copy('.env.example', '.env');\\""
        ]
    },
    "config": {
        "optimize-autoloader": true,
        "preferred-install": "dist",
        "sort-packages": true
    },
    "minimum-stability": "stable",
    "prefer-stable": true
}`
          },
          {
            type: 'file-create',
            target: 'routes/api.php',
            template: `<?php

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Route;
use App\Http\Controllers\UserController;

/*
|--------------------------------------------------------------------------
| API Routes
|--------------------------------------------------------------------------
*/

Route::middleware('auth:sanctum')->get('/user', function (Request $request) {
    return $request->user();
});

// User routes
Route::apiResource('users', UserController::class);

// Health check
Route::get('/health', function () {
    return response()->json([
        'status' => 'healthy',
        'timestamp' => now()
    ]);
});`
          },
          {
            type: 'file-create',
            target: 'app/Http/Controllers/UserController.php',
            template: `<?php

namespace App\Http\Controllers;

use App\Models\User;
use Illuminate\Http\Request;
use Illuminate\Http\JsonResponse;

class UserController extends Controller
{
    /**
     * Display a listing of users.
     */
    public function index(): JsonResponse
    {
        $users = User::paginate(15);
        return response()->json($users);
    }

    /**
     * Store a newly created user.
     */
    public function store(Request $request): JsonResponse
    {
        $validated = $request->validate([
            'name' => 'required|string|max:255',
            'email' => 'required|string|email|max:255|unique:users',
            'password' => 'required|string|min:8',
        ]);

        $user = User::create([
            'name' => $validated['name'],
            'email' => $validated['email'],
            'password' => bcrypt($validated['password']),
        ]);

        return response()->json($user, 201);
    }

    /**
     * Display the specified user.
     */
    public function show(User $user): JsonResponse
    {
        return response()->json($user);
    }

    /**
     * Update the specified user.
     */
    public function update(Request $request, User $user): JsonResponse
    {
        $validated = $request->validate([
            'name' => 'sometimes|string|max:255',
            'email' => 'sometimes|string|email|max:255|unique:users,email,' . $user->id,
        ]);

        $user->update($validated);
        return response()->json($user);
    }

    /**
     * Remove the specified user.
     */
    public function destroy(User $user): JsonResponse
    {
        $user->delete();
        return response()->json(null, 204);
    }
}`
          },
          {
            type: 'file-create',
            target: '.env.example',
            template: `APP_NAME=Laravel
APP_ENV=local
APP_KEY=
APP_DEBUG=true
APP_URL=http://localhost

LOG_CHANNEL=stack
LOG_DEPRECATIONS_CHANNEL=null
LOG_LEVEL=debug

DB_CONNECTION=mysql
DB_HOST=127.0.0.1
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=root
DB_PASSWORD=

BROADCAST_DRIVER=log
CACHE_DRIVER=file
FILESYSTEM_DISK=local
QUEUE_CONNECTION=sync
SESSION_DRIVER=file
SESSION_LIFETIME=120

MEMCACHED_HOST=127.0.0.1

REDIS_HOST=127.0.0.1
REDIS_PASSWORD=null
REDIS_PORT=6379

MAIL_MAILER=smtp
MAIL_HOST=mailpit
MAIL_PORT=1025
MAIL_USERNAME=null
MAIL_PASSWORD=null
MAIL_ENCRYPTION=null
MAIL_FROM_ADDRESS="hello@example.com"
MAIL_FROM_NAME="${APP_NAME}"`
          }
        ],
        documentation: 'https://laravel.com/docs',
        complexity: 'medium',
        tags: ['php', 'fullstack', 'mvc', 'eloquent', 'artisan']
      },

      // Backend - Django (Python)
      {
        name: 'django',
        type: 'backend',
        provider: 'django',
        version: '5.0.0',
        description: 'The web framework for perfectionists with deadlines',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'requirements.txt',
            template: `Django==5.0.0
djangorestframework==3.14.0
django-cors-headers==4.3.0
django-environ==0.11.2
gunicorn==21.2.0
psycopg2-binary==2.9.9
redis==5.0.1
celery==5.3.4
django-celery-beat==2.5.0
django-storages==1.14.2
boto3==1.34.0
Pillow==10.1.0
django-filter==23.5
django-redis==5.4.0
drf-spectacular==0.27.0
pytest==7.4.3
pytest-django==4.7.0
factory-boy==3.3.0
black==23.12.0
flake8==6.1.0
isort==5.13.0`
          },
          {
            type: 'file-create',
            target: 'manage.py',
            template: `#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys

if __name__ == '__main__':
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'config.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)`
          },
          {
            type: 'file-create',
            target: 'config/settings.py',
            template: `"""
Django settings for project.
"""

from pathlib import Path
import environ

# Build paths inside the project
BASE_DIR = Path(__file__).resolve().parent.parent

# Environment variables
env = environ.Env(
    DEBUG=(bool, False)
)
environ.Env.read_env(BASE_DIR / '.env')

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = env('SECRET_KEY', default='your-secret-key-here')

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = env('DEBUG')

ALLOWED_HOSTS = env.list('ALLOWED_HOSTS', default=['localhost', '127.0.0.1'])

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third party apps
    'rest_framework',
    'corsheaders',
    'django_filters',
    'drf_spectacular',
    # Local apps
    'api',
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'config.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'config.wsgi.application'

# Database
DATABASES = {
    'default': env.db(default='sqlite:///db.sqlite3')
}

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Internationalization
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_TZ = True

# Static files (CSS, JavaScript, Images)
STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Media files
MEDIA_URL = 'media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Default primary key field type
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',
}

# CORS settings
CORS_ALLOWED_ORIGINS = env.list('CORS_ALLOWED_ORIGINS', default=['http://localhost:3000'])

# Spectacular settings for API documentation
SPECTACULAR_SETTINGS = {
    'TITLE': 'API',
    'DESCRIPTION': 'API documentation',
    'VERSION': '1.0.0',
}`
          },
          {
            type: 'file-create',
            target: 'api/views.py',
            template: `from rest_framework import viewsets, status
from rest_framework.decorators import api_view
from rest_framework.response import Response
from django.contrib.auth.models import User
from .serializers import UserSerializer

class UserViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows users to be viewed or edited.
    """
    queryset = User.objects.all().order_by('-date_joined')
    serializer_class = UserSerializer

@api_view(['GET'])
def health_check(request):
    """
    Health check endpoint
    """
    return Response({
        'status': 'healthy',
        'version': '1.0.0'
    }, status=status.HTTP_200_OK)`
          },
          {
            type: 'file-create',
            target: 'api/serializers.py',
            template: `from rest_framework import serializers
from django.contrib.auth.models import User

class UserSerializer(serializers.ModelSerializer):
    class Meta:
        model = User
        fields = ['id', 'username', 'email', 'first_name', 'last_name', 'date_joined']
        read_only_fields = ['id', 'date_joined']`
          }
        ],
        documentation: 'https://docs.djangoproject.com/',
        complexity: 'medium',
        tags: ['python', 'fullstack', 'mvc', 'orm', 'django-admin']
      },

      // Frontend - Blazor (.NET)
      {
        name: 'blazor',
        type: 'frontend',
        provider: 'microsoft',
        version: '8.0.0',
        description: 'Build interactive web UIs using C# instead of JavaScript',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'Program.cs',
            template: `using Microsoft.AspNetCore.Components.Web;
using Microsoft.AspNetCore.Components.WebAssembly.Hosting;
using MyApp;

var builder = WebAssemblyHostBuilder.CreateDefault(args);
builder.RootComponents.Add<App>("#app");
builder.RootComponents.Add<HeadOutlet>("head::after");

builder.Services.AddScoped(sp => new HttpClient { BaseAddress = new Uri(builder.HostEnvironment.BaseAddress) });

// Add additional services
builder.Services.AddScoped<IWeatherForecastService, WeatherForecastService>();

await builder.Build().RunAsync();`
          },
          {
            type: 'file-create',
            target: 'App.razor',
            template: `<Router AppAssembly="@typeof(App).Assembly">
    <Found Context="routeData">
        <RouteView RouteData="@routeData" DefaultLayout="@typeof(MainLayout)" />
        <FocusOnNavigate RouteData="@routeData" Selector="h1" />
    </Found>
    <NotFound>
        <PageTitle>Not found</PageTitle>
        <LayoutView Layout="@typeof(MainLayout)">
            <p role="alert">Sorry, there's nothing at this address.</p>
        </LayoutView>
    </NotFound>
</Router>`
          },
          {
            type: 'file-create',
            target: 'Pages/Index.razor',
            template: `@page "/"

<PageTitle>Home</PageTitle>

<div class="container mt-5">
    <h1 class="display-4">Welcome to Blazor!</h1>
    <p class="lead">Build interactive web UIs using C# instead of JavaScript.</p>
    
    <div class="row mt-4">
        <div class="col-md-4">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Component-based</h5>
                    <p class="card-text">Build encapsulated components that manage their own state.</p>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Full-stack C#</h5>
                    <p class="card-text">Share code and libraries between client and server.</p>
                </div>
            </div>
        </div>
        <div class="col-md-4">
            <div class="card">
                <div class="card-body">
                    <h5 class="card-title">Fast & Scalable</h5>
                    <p class="card-text">Leverage WebAssembly for near-native performance.</p>
                </div>
            </div>
        </div>
    </div>
</div>`
          },
          {
            type: 'file-create',
            target: 'Shared/MainLayout.razor',
            template: `@inherits LayoutComponentBase

<div class="page">
    <div class="sidebar">
        <NavMenu />
    </div>

    <main>
        <div class="top-row px-4">
            <a href="https://docs.microsoft.com/aspnet/" target="_blank">About</a>
        </div>

        <article class="content px-4">
            @Body
        </article>
    </main>
</div>`
          },
          {
            type: 'file-create',
            target: 'MyApp.csproj',
            template: `<Project Sdk="Microsoft.NET.Sdk.BlazorWebAssembly">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly" Version="8.0.0" />
    <PackageReference Include="Microsoft.AspNetCore.Components.WebAssembly.DevServer" Version="8.0.0" PrivateAssets="all" />
    <PackageReference Include="System.Net.Http.Json" Version="8.0.0" />
  </ItemGroup>

</Project>`
          }
        ],
        documentation: 'https://blazor.net/',
        complexity: 'medium',
        tags: ['dotnet', 'csharp', 'webassembly', 'spa', 'component-based']
      },

      // Backend - ASP.NET Core
      {
        name: 'dotnet',
        type: 'backend',
        provider: 'microsoft',
        version: '8.0.0',
        description: 'Cross-platform, high-performance framework for building modern web APIs',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'Program.cs',
            template: `var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// Add CORS
builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowAll",
        builder =>
        {
            builder.AllowAnyOrigin()
                   .AllowAnyMethod()
                   .AllowAnyHeader();
        });
});

// Add Entity Framework
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseNpgsql(builder.Configuration.GetConnectionString("DefaultConnection")));

// Add authentication
builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options =>
    {
        options.TokenValidationParameters = new TokenValidationParameters
        {
            ValidateIssuer = true,
            ValidateAudience = true,
            ValidateLifetime = true,
            ValidateIssuerSigningKey = true,
            ValidIssuer = builder.Configuration["Jwt:Issuer"],
            ValidAudience = builder.Configuration["Jwt:Audience"],
            IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["Jwt:Key"]))
        };
    });

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseCors("AllowAll");
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();

app.Run();`
          },
          {
            type: 'file-create',
            target: 'Controllers/UsersController.cs',
            template: `using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using Microsoft.EntityFrameworkCore;

namespace MyApp.Controllers;

[ApiController]
[Route("api/[controller]")]
[Authorize]
public class UsersController : ControllerBase
{
    private readonly ApplicationDbContext _context;
    private readonly ILogger<UsersController> _logger;

    public UsersController(ApplicationDbContext context, ILogger<UsersController> logger)
    {
        _context = context;
        _logger = logger;
    }

    [HttpGet]
    public async Task<ActionResult<IEnumerable<User>>> GetUsers()
    {
        return await _context.Users.ToListAsync();
    }

    [HttpGet("{id}")]
    public async Task<ActionResult<User>> GetUser(int id)
    {
        var user = await _context.Users.FindAsync(id);

        if (user == null)
        {
            return NotFound();
        }

        return user;
    }

    [HttpPost]
    public async Task<ActionResult<User>> CreateUser(User user)
    {
        _context.Users.Add(user);
        await _context.SaveChangesAsync();

        return CreatedAtAction(nameof(GetUser), new { id = user.Id }, user);
    }

    [HttpPut("{id}")]
    public async Task<IActionResult> UpdateUser(int id, User user)
    {
        if (id != user.Id)
        {
            return BadRequest();
        }

        _context.Entry(user).State = EntityState.Modified;

        try
        {
            await _context.SaveChangesAsync();
        }
        catch (DbUpdateConcurrencyException)
        {
            if (!UserExists(id))
            {
                return NotFound();
            }
            else
            {
                throw;
            }
        }

        return NoContent();
    }

    [HttpDelete("{id}")]
    public async Task<IActionResult> DeleteUser(int id)
    {
        var user = await _context.Users.FindAsync(id);
        if (user == null)
        {
            return NotFound();
        }

        _context.Users.Remove(user);
        await _context.SaveChangesAsync();

        return NoContent();
    }

    private bool UserExists(int id)
    {
        return _context.Users.Any(e => e.Id == id);
    }
}`
          },
          {
            type: 'file-create',
            target: 'Models/User.cs',
            template: `using System.ComponentModel.DataAnnotations;

namespace MyApp.Models;

public class User
{
    public int Id { get; set; }
    
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    
    [Required]
    public string Name { get; set; } = string.Empty;
    
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
}`
          },
          {
            type: 'file-create',
            target: 'Data/ApplicationDbContext.cs',
            template: `using Microsoft.EntityFrameworkCore;
using MyApp.Models;

namespace MyApp.Data;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        modelBuilder.Entity<User>(entity =>
        {
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.Name).IsRequired().HasMaxLength(100);
        });
    }
}`
          },
          {
            type: 'file-create',
            target: 'MyApp.csproj',
            template: `<Project Sdk="Microsoft.NET.Sdk.Web">

  <PropertyGroup>
    <TargetFramework>net8.0</TargetFramework>
    <Nullable>enable</Nullable>
    <ImplicitUsings>enable</ImplicitUsings>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
    <PackageReference Include="Microsoft.EntityFrameworkCore.Design" Version="8.0.0" />
    <PackageReference Include="Npgsql.EntityFrameworkCore.PostgreSQL" Version="8.0.0" />
    <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  </ItemGroup>

</Project>`
          },
          {
            type: 'file-create',
            target: 'appsettings.json',
            template: `{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "ConnectionStrings": {
    "DefaultConnection": "Host=localhost;Database=myapp;Username=postgres;Password=password"
  },
  "Jwt": {
    "Key": "ThisIsMySecretKeyForJwtToken",
    "Issuer": "MyApp",
    "Audience": "MyAppUsers"
  },
  "AllowedHosts": "*"
}`
          }
        ],
        documentation: 'https://docs.microsoft.com/aspnet/core/',
        complexity: 'medium',
        tags: ['dotnet', 'csharp', 'api', 'entity-framework', 'cross-platform']
      },

      // ORM - Entity Framework
      {
        name: 'entity-framework',
        type: 'orm',
        provider: 'microsoft',
        version: '8.0.0',
        description: 'Modern object-database mapper for .NET',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'Data/ApplicationDbContext.cs',
            template: `using Microsoft.EntityFrameworkCore;

namespace MyApp.Data;

public class ApplicationDbContext : DbContext
{
    public ApplicationDbContext(DbContextOptions<ApplicationDbContext> options)
        : base(options)
    {
    }

    public DbSet<User> Users { get; set; } = null!;
    public DbSet<Post> Posts { get; set; } = null!;

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);

        // User configuration
        modelBuilder.Entity<User>(entity =>
        {
            entity.ToTable("users");
            entity.HasKey(e => e.Id);
            entity.HasIndex(e => e.Email).IsUnique();
            entity.Property(e => e.Email).IsRequired().HasMaxLength(255);
            entity.Property(e => e.Name).HasMaxLength(100);
            
            // Relationships
            entity.HasMany(e => e.Posts)
                  .WithOne(e => e.Author)
                  .HasForeignKey(e => e.AuthorId)
                  .OnDelete(DeleteBehavior.Cascade);
        });

        // Post configuration
        modelBuilder.Entity<Post>(entity =>
        {
            entity.ToTable("posts");
            entity.HasKey(e => e.Id);
            entity.Property(e => e.Title).IsRequired().HasMaxLength(200);
            entity.Property(e => e.Content).HasColumnType("text");
            entity.Property(e => e.Published).HasDefaultValue(false);
            
            // Indexes
            entity.HasIndex(e => e.Published);
            entity.HasIndex(e => e.CreatedAt);
        });

        // Seed data
        modelBuilder.Entity<User>().HasData(
            new User { Id = 1, Email = "admin@example.com", Name = "Admin User" }
        );
    }
}`
          },
          {
            type: 'file-create',
            target: 'Models/User.cs',
            template: `using System.ComponentModel.DataAnnotations;

namespace MyApp.Models;

public class User
{
    public int Id { get; set; }
    
    [Required]
    [EmailAddress]
    public string Email { get; set; } = string.Empty;
    
    [StringLength(100)]
    public string? Name { get; set; }
    
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    
    // Navigation properties
    public virtual ICollection<Post> Posts { get; set; } = new List<Post>();
}`
          },
          {
            type: 'file-create',
            target: 'Models/Post.cs',
            template: `using System.ComponentModel.DataAnnotations;

namespace MyApp.Models;

public class Post
{
    public int Id { get; set; }
    
    [Required]
    [StringLength(200)]
    public string Title { get; set; } = string.Empty;
    
    public string? Content { get; set; }
    
    public bool Published { get; set; } = false;
    
    public int? AuthorId { get; set; }
    
    public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
    
    public DateTime UpdatedAt { get; set; } = DateTime.UtcNow;
    
    // Navigation properties
    public virtual User? Author { get; set; }
}`
          },
          {
            type: 'file-create',
            target: 'Migrations/DatabaseInitializer.cs',
            template: `using Microsoft.EntityFrameworkCore;

namespace MyApp.Data;

public static class DatabaseInitializer
{
    public static async Task InitializeAsync(IServiceProvider serviceProvider)
    {
        using var scope = serviceProvider.CreateScope();
        var context = scope.ServiceProvider.GetRequiredService<ApplicationDbContext>();
        
        // Apply migrations
        await context.Database.MigrateAsync();
        
        // Seed data if needed
        if (!await context.Users.AnyAsync())
        {
            await SeedDataAsync(context);
        }
    }
    
    private static async Task SeedDataAsync(ApplicationDbContext context)
    {
        var users = new[]
        {
            new User { Email = "user1@example.com", Name = "User One" },
            new User { Email = "user2@example.com", Name = "User Two" }
        };
        
        context.Users.AddRange(users);
        await context.SaveChangesAsync();
        
        var posts = new[]
        {
            new Post { Title = "First Post", Content = "Hello World!", AuthorId = users[0].Id, Published = true },
            new Post { Title = "Second Post", Content = "Another post", AuthorId = users[1].Id }
        };
        
        context.Posts.AddRange(posts);
        await context.SaveChangesAsync();
    }
}`
          },
          {
            type: 'dependency',
            packages: {
              'Microsoft.EntityFrameworkCore': '^8.0.0',
              'Microsoft.EntityFrameworkCore.Design': '^8.0.0',
              'Microsoft.EntityFrameworkCore.Tools': '^8.0.0',
              'Npgsql.EntityFrameworkCore.PostgreSQL': '^8.0.0'
            }
          }
        ],
        documentation: 'https://docs.microsoft.com/ef/core/',
        complexity: 'medium',
        tags: ['dotnet', 'orm', 'database', 'migrations', 'linq']
      },

      // Authentication
      {
        name: 'better-auth',
        type: 'auth',
        provider: 'better-auth',
        version: '1.0.0',
        description: 'Modern authentication library for TypeScript',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth.ts',
            template: `import { betterAuth } from 'better-auth';
import { prismaAdapter } from '@better-auth/prisma-adapter';
import { prisma } from './prisma';

export const auth = betterAuth({
  database: prismaAdapter(prisma, {
    provider: '{{database}}'
  }),
  emailAndPassword: {
    enabled: true,
    requireEmailVerification: {{config.requireEmailVerification}}
  },
  socialProviders: {
    {{#if config.providers.google}}
    google: {
      clientId: process.env.GOOGLE_CLIENT_ID!,
      clientSecret: process.env.GOOGLE_CLIENT_SECRET!
    },
    {{/if}}
    {{#if config.providers.github}}
    github: {
      clientId: process.env.GITHUB_CLIENT_ID!,
      clientSecret: process.env.GITHUB_CLIENT_SECRET!
    }
    {{/if}}
  }
});

export type Auth = typeof auth;`,
            priority: 100
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "better-auth": "^1.0.0",
    "@better-auth/prisma-adapter": "^1.0.0"
  }
}`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'BETTER_AUTH_SECRET',
            description: 'Secret key for Better Auth',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'BETTER_AUTH_URL',
            description: 'URL for Better Auth',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          }
        ],
        dependencies: [
          {
            serviceType: 'database',
            required: true
          }
        ],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Configure authentication providers in .env file'
          },
          {
            type: 'command',
            description: 'Generate Prisma schema for auth tables',
            command: 'npx prisma generate'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: ['postgresql', 'mysql', 'sqlite'],
        platforms: ['web'],
        tags: ['authentication', 'security', 'user-management']
      },

      // Database - PostgreSQL
      {
        name: 'postgresql',
        type: 'database',
        provider: 'postgresql',
        version: '16.0.0',
        description: 'PostgreSQL database with Prisma ORM',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'PostgreSQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'postgresql://user:password@localhost:5432/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up PostgreSQL database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'orm', 'prisma']
      },

      // Database - MySQL
      {
        name: 'mysql',
        type: 'database',
        provider: 'mysql',
        version: '8.0.0',
        description: 'MySQL relational database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'MySQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mysql://user:password@localhost:3306/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up MySQL database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'mysql', 'orm', 'prisma']
      },

      // Database - MongoDB
      {
        name: 'mongodb',
        type: 'database',
        provider: 'mongodb',
        version: '7.0.0',
        description: 'MongoDB NoSQL database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/mongodb.ts',
            template: `import { MongoClient, Db, Collection } from 'mongodb';

const uri = process.env.MONGODB_URI || 'mongodb://localhost:27017';
const dbName = process.env.MONGODB_DB || 'myapp';

let cachedClient: MongoClient | null = null;
let cachedDb: Db | null = null;

export async function connectToDatabase(): Promise<{ client: MongoClient; db: Db }> {
  if (cachedClient && cachedDb) {
    return { client: cachedClient, db: cachedDb };
  }

  const client = new MongoClient(uri);
  await client.connect();

  const db = client.db(dbName);

  cachedClient = client;
  cachedDb = db;

  return { client, db };
}

export async function getCollection<T>(collectionName: string): Promise<Collection<T>> {
  const { db } = await connectToDatabase();
  return db.collection<T>(collectionName);
}

// Helper functions
export async function findOne<T>(collection: string, query: any): Promise<T | null> {
  const col = await getCollection<T>(collection);
  return col.findOne(query);
}

export async function findMany<T>(collection: string, query: any = {}, options: any = {}): Promise<T[]> {
  const col = await getCollection<T>(collection);
  return col.find(query, options).toArray();
}

export async function insertOne<T>(collection: string, document: T): Promise<string> {
  const col = await getCollection<T>(collection);
  const result = await col.insertOne(document as any);
  return result.insertedId.toString();
}

export async function updateOne<T>(collection: string, query: any, update: any): Promise<boolean> {
  const col = await getCollection<T>(collection);
  const result = await col.updateOne(query, { $set: update });
  return result.modifiedCount > 0;
}

export async function deleteOne(collection: string, query: any): Promise<boolean> {
  const col = await getCollection<any>(collection);
  const result = await col.deleteOne(query);
  return result.deletedCount > 0;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/models/User.ts',
            template: `import { ObjectId } from 'mongodb';
import { findOne, insertOne, updateOne } from '@/lib/mongodb';

export interface User {
  _id?: ObjectId;
  email: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
}

export class UserModel {
  static collection = 'users';

  static async findById(id: string): Promise<User | null> {
    return findOne<User>(this.collection, { _id: new ObjectId(id) });
  }

  static async findByEmail(email: string): Promise<User | null> {
    return findOne<User>(this.collection, { email });
  }

  static async create(data: Omit<User, '_id' | 'createdAt' | 'updatedAt'>): Promise<User> {
    const user: User = {
      ...data,
      createdAt: new Date(),
      updatedAt: new Date()
    };
    
    const id = await insertOne(this.collection, user);
    return { ...user, _id: new ObjectId(id) };
  }

  static async update(id: string, data: Partial<User>): Promise<boolean> {
    return updateOne(this.collection, 
      { _id: new ObjectId(id) }, 
      { ...data, updatedAt: new Date() }
    );
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "mongodb": "^6.0.0"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mongodb://localhost:27017'
          },
          {
            name: 'MONGODB_DB',
            description: 'MongoDB database name',
            required: true,
            type: 'string',
            defaultValue: 'myapp'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MongoDB database and update MONGODB_URI'
          },
          {
            type: 'manual',
            description: 'Create indexes for optimal performance'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'nosql', 'mongodb', 'document-store']
      },

      // Database - SQLite
      {
        name: 'sqlite',
        type: 'database',
        provider: 'sqlite',
        version: '3.0.0',
        description: 'SQLite embedded database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'SQLite database file path',
            required: true,
            type: 'string',
            defaultValue: 'file:./dev.db'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'command',
            description: 'Push database schema',
            command: 'npx prisma db push'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'sqlite', 'embedded', 'orm', 'prisma']
      },

      // Database - SQL Server
      {
        name: 'sqlserver',
        type: 'database',
        provider: 'microsoft',
        version: '2022',
        description: 'Microsoft SQL Server database',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient();

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:push": "prisma db push",
    "db:studio": "prisma studio"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'SQL Server connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'sqlserver://localhost:1433;database=mydb;user=sa;password=YourPassword;encrypt=true;trustServerCertificate=true'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Prisma dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Set up SQL Server database and update DATABASE_URL'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['database', 'sql', 'sqlserver', 'mssql', 'microsoft', 'orm', 'prisma']
      },

      // ORM - Prisma (standalone)
      {
        name: 'prisma',
        type: 'orm',
        provider: 'prisma',
        version: '5.0.0',
        description: 'Next-generation Node.js and TypeScript ORM',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/schema.prisma',
            template: `// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql" // Change this based on your database
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String?
  posts     Post[]
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Post {
  id        String   @id @default(cuid())
  title     String
  content   String?
  published Boolean  @default(false)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/prisma.ts',
            template: `import { PrismaClient } from '@prisma/client';

const globalForPrisma = globalThis as unknown as {
  prisma: PrismaClient | undefined;
};

export const prisma = globalForPrisma.prisma ?? new PrismaClient({
  log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],
});

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

export * from '@prisma/client';`,
            priority: 90
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@prisma/client": "^5.0.0"
  },
  "devDependencies": {
    "prisma": "^5.0.0",
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:generate": "prisma generate",
    "db:migrate": "prisma migrate dev",
    "db:migrate:create": "prisma migrate dev --create-only",
    "db:migrate:deploy": "prisma migrate deploy",
    "db:push": "prisma db push",
    "db:seed": "tsx prisma/seed.ts",
    "db:studio": "prisma studio",
    "db:reset": "prisma migrate reset"
  }
}`,
            priority: 80
          },
          {
            type: 'file-create',
            target: 'prisma/seed.ts',
            template: `import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
  // Create sample users
  const user1 = await prisma.user.upsert({
    where: { email: 'alice@example.com' },
    update: {},
    create: {
      email: 'alice@example.com',
      name: 'Alice',
      posts: {
        create: [
          {
            title: 'My first post',
            content: 'This is my first post content',
            published: true
          }
        ]
      }
    }
  });

  const user2 = await prisma.user.upsert({
    where: { email: 'bob@example.com' },
    update: {},
    create: {
      email: 'bob@example.com',
      name: 'Bob',
      posts: {
        create: [
          {
            title: 'Hello World',
            content: 'This is my hello world post',
            published: true
          }
        ]
      }
    }
  });

  console.log({ user1, user2 });
}

main()
  .then(async () => {
    await prisma.$disconnect();
  })
  .catch(async (e) => {
    console.error(e);
    await prisma.$disconnect();
    process.exit(1);
  });`,
            priority: 85
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'Database connection string',
            required: true,
            type: 'url',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate Prisma client',
            command: 'npx prisma generate'
          },
          {
            type: 'manual',
            description: 'Configure your database connection in .env'
          },
          {
            type: 'command',
            description: 'Run initial migration',
            command: 'npx prisma migrate dev --name init'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite', 'sqlserver', 'mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'prisma', 'typescript', 'sql']
      },

      // ORM - Drizzle
      {
        name: 'drizzle',
        type: 'orm',
        provider: 'drizzle-team',
        version: '0.29.0',
        description: 'TypeScript ORM with SQL-like experience',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/db/schema.ts',
            template: `import { pgTable, serial, text, varchar, timestamp, boolean } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  name: text('name'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 255 }).notNull(),
  content: text('content'),
  published: boolean('published').default(false).notNull(),
  authorId: serial('author_id').references(() => users.id),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull()
});

export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts)
}));

export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, {
    fields: [posts.authorId],
    references: [users.id]
  })
}));

export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;
export type Post = typeof posts.$inferSelect;
export type NewPost = typeof posts.$inferInsert;`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/db/index.ts',
            template: `import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';
import * as schema from './schema';

const connectionString = process.env.DATABASE_URL!;
const sql = postgres(connectionString);

export const db = drizzle(sql, { schema });

export * from './schema';`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'drizzle.config.ts',
            template: `import type { Config } from 'drizzle-kit';

export default {
  schema: './src/db/schema.ts',
  out: './drizzle',
  driver: 'pg',
  dbCredentials: {
    connectionString: process.env.DATABASE_URL!,
  },
  verbose: true,
  strict: true,
} satisfies Config;`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "drizzle-orm": "^0.29.0",
    "postgres": "^3.4.0"
  },
  "devDependencies": {
    "drizzle-kit": "^0.20.0",
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:generate": "drizzle-kit generate:pg",
    "db:push": "drizzle-kit push:pg",
    "db:drop": "drizzle-kit drop",
    "db:pull": "drizzle-kit introspect:pg",
    "db:studio": "drizzle-kit studio",
    "db:check": "drizzle-kit check:pg"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DATABASE_URL',
            description: 'PostgreSQL connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'postgresql://user:password@localhost:5432/mydb'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'command',
            description: 'Generate SQL migrations',
            command: 'npm run db:generate'
          },
          {
            type: 'command',
            description: 'Push schema to database',
            command: 'npm run db:push'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'drizzle', 'typescript', 'sql']
      },

      // ORM - TypeORM
      {
        name: 'typeorm',
        type: 'orm',
        provider: 'typeorm',
        version: '0.3.0',
        description: 'TypeScript ORM for SQL and NoSQL databases',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/entities/User.ts',
            template: `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, OneToMany } from 'typeorm';
import { Post } from './Post';

@Entity('users')
export class User {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column({ unique: true })
  email: string;

  @Column({ nullable: true })
  name: string;

  @OneToMany(() => Post, (post) => post.author)
  posts: Post[];

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/entities/Post.ts',
            template: `import { Entity, PrimaryGeneratedColumn, Column, CreateDateColumn, UpdateDateColumn, ManyToOne, JoinColumn } from 'typeorm';
import { User } from './User';

@Entity('posts')
export class Post {
  @PrimaryGeneratedColumn('uuid')
  id: string;

  @Column()
  title: string;

  @Column({ type: 'text', nullable: true })
  content: string;

  @Column({ default: false })
  published: boolean;

  @ManyToOne(() => User, (user) => user.posts, { nullable: true })
  @JoinColumn({ name: 'author_id' })
  author: User;

  @Column({ nullable: true })
  authorId: string;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/data-source.ts',
            template: `import 'reflect-metadata';
import { DataSource } from 'typeorm';
import { User } from './entities/User';
import { Post } from './entities/Post';

export const AppDataSource = new DataSource({
  type: 'postgres',
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  username: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || 'password',
  database: process.env.DB_NAME || 'mydb',
  synchronize: process.env.NODE_ENV === 'development',
  logging: process.env.NODE_ENV === 'development',
  entities: [User, Post],
  migrations: ['src/migrations/*.ts'],
  subscribers: [],
});

// Initialize connection
export async function initializeDatabase() {
  try {
    await AppDataSource.initialize();
    console.log('Data Source has been initialized!');
  } catch (err) {
    console.error('Error during Data Source initialization:', err);
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "typeorm": "^0.3.0",
    "reflect-metadata": "^0.1.13",
    "pg": "^8.11.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "typeorm": "typeorm-ts-node-commonjs",
    "db:create": "typeorm migration:create",
    "db:generate": "typeorm migration:generate -d src/data-source.ts",
    "db:run": "typeorm migration:run -d src/data-source.ts",
    "db:revert": "typeorm migration:revert -d src/data-source.ts",
    "db:drop": "typeorm schema:drop -d src/data-source.ts",
    "db:sync": "typeorm schema:sync -d src/data-source.ts"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'DB_HOST',
            description: 'Database host',
            required: true,
            type: 'string',
            defaultValue: 'localhost'
          },
          {
            name: 'DB_PORT',
            description: 'Database port',
            required: true,
            type: 'number',
            defaultValue: '5432'
          },
          {
            name: 'DB_USER',
            description: 'Database user',
            required: true,
            type: 'string'
          },
          {
            name: 'DB_PASSWORD',
            description: 'Database password',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'DB_NAME',
            description: 'Database name',
            required: true,
            type: 'string'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'manual',
            description: 'Configure database connection in .env'
          },
          {
            type: 'command',
            description: 'Run migrations',
            command: 'npm run db:run'
          }
        ],
        frameworks: [],
        databases: ['postgresql', 'mysql', 'sqlite', 'sqlserver', 'mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'database', 'typeorm', 'typescript', 'decorators']
      },

      // ORM - Mongoose (for MongoDB)
      {
        name: 'mongoose',
        type: 'orm',
        provider: 'mongoose',
        version: '8.0.0',
        description: 'MongoDB object modeling for Node.js',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/models/User.ts',
            template: `import { Schema, model, Document } from 'mongoose';

export interface IUser extends Document {
  email: string;
  name?: string;
  createdAt: Date;
  updatedAt: Date;
}

const userSchema = new Schema<IUser>(
  {
    email: {
      type: String,
      required: true,
      unique: true,
      lowercase: true,
      trim: true
    },
    name: {
      type: String,
      trim: true
    }
  },
  {
    timestamps: true
  }
);

// Indexes
userSchema.index({ email: 1 });
userSchema.index({ createdAt: -1 });

// Virtual for user's full info
userSchema.virtual('displayName').get(function() {
  return this.name || this.email;
});

// Instance methods
userSchema.methods.toJSON = function() {
  const obj = this.toObject();
  delete obj.__v;
  return obj;
};

export const User = model<IUser>('User', userSchema);`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/models/Post.ts',
            template: `import { Schema, model, Document, Types } from 'mongoose';

export interface IPost extends Document {
  title: string;
  content?: string;
  published: boolean;
  author?: Types.ObjectId;
  createdAt: Date;
  updatedAt: Date;
}

const postSchema = new Schema<IPost>(
  {
    title: {
      type: String,
      required: true,
      trim: true
    },
    content: {
      type: String
    },
    published: {
      type: Boolean,
      default: false
    },
    author: {
      type: Schema.Types.ObjectId,
      ref: 'User'
    }
  },
  {
    timestamps: true
  }
);

// Indexes
postSchema.index({ title: 'text', content: 'text' });
postSchema.index({ author: 1, createdAt: -1 });
postSchema.index({ published: 1 });

// Virtual for excerpt
postSchema.virtual('excerpt').get(function() {
  if (!this.content) return '';
  return this.content.substring(0, 150) + '...';
});

// Pre-save middleware
postSchema.pre('save', function(next) {
  // Add any pre-save logic here
  next();
});

export const Post = model<IPost>('Post', postSchema);`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'src/lib/mongoose.ts',
            template: `import mongoose from 'mongoose';

const MONGODB_URI = process.env.MONGODB_URI || 'mongodb://localhost:27017/myapp';

/**
 * Global is used here to maintain a cached connection across hot reloads
 * in development. This prevents connections growing exponentially
 * during API Route usage.
 */
declare global {
  var mongoose: {
    conn: typeof mongoose | null;
    promise: Promise<typeof mongoose> | null;
  };
}

let cached = global.mongoose || { conn: null, promise: null };

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

export async function connectDB() {
  if (cached.conn) {
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    throw e;
  }

  return cached.conn;
}

export default connectDB;`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "mongoose": "^8.0.0"
  },
  "devDependencies": {
    "@types/node": "^20.0.0"
  },
  "scripts": {
    "db:seed": "tsx src/scripts/seed.ts"
  }
}`,
            priority: 80
          }
        ],
        envVariables: [
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'mongodb://localhost:27017/myapp'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install dependencies',
            command: 'npm install'
          },
          {
            type: 'manual',
            description: 'Ensure MongoDB is running'
          },
          {
            type: 'manual',
            description: 'Configure connection string in .env'
          }
        ],
        frameworks: [],
        databases: ['mongodb'],
        platforms: ['web', 'mobile', 'desktop'],
        tags: ['orm', 'odm', 'database', 'mongodb', 'mongoose', 'nosql']
      },

      // Payments - Stripe
      {
        name: 'stripe',
        type: 'payments',
        provider: 'stripe',
        version: '16.0.0',
        description: 'Stripe payment processing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/stripe.ts',
            template: `import Stripe from 'stripe';

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {
  apiVersion: '2024-12-18.acacia',
  typescript: true
});

export async function createCheckoutSession(params: {
  priceId: string;
  customerId?: string;
  successUrl: string;
  cancelUrl: string;
}) {
  return stripe.checkout.sessions.create({
    payment_method_types: ['card'],
    line_items: [{
      price: params.priceId,
      quantity: 1
    }],
    mode: 'subscription',
    success_url: params.successUrl,
    cancel_url: params.cancelUrl,
    customer: params.customerId
  });
}

export async function createCustomer(params: {
  email: string;
  name?: string;
}) {
  return stripe.customers.create({
    email: params.email,
    name: params.name
  });
}`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "stripe": "^16.0.0"
  }
}`,
            priority: 75
          }
        ],
        envVariables: [
          {
            name: 'STRIPE_SECRET_KEY',
            description: 'Stripe secret key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'STRIPE_PUBLISHABLE_KEY',
            description: 'Stripe publishable key',
            required: true,
            type: 'string'
          },
          {
            name: 'STRIPE_WEBHOOK_SECRET',
            description: 'Stripe webhook secret',
            required: false,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Stripe account and add API keys to .env'
          },
          {
            type: 'manual',
            description: 'Configure Stripe webhooks for subscription events'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['payments', 'billing', 'subscriptions', 'stripe']
      },

      // Email - Resend
      {
        name: 'resend',
        type: 'email',
        provider: 'resend',
        version: '3.0.0',
        description: 'Modern email API for developers',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/email.ts',
            template: `import { Resend } from 'resend';

const resend = new Resend(process.env.RESEND_API_KEY!);

export async function sendEmail({
  to,
  subject,
  html,
  text,
  from = process.env.EMAIL_FROM || 'noreply@example.com'
}: {
  to: string | string[];
  subject: string;
  html?: string;
  text?: string;
  from?: string;
}) {
  try {
    const { data, error } = await resend.emails.send({
      from,
      to,
      subject,
      html,
      text
    });

    if (error) {
      console.error('Email send error:', error);
      throw error;
    }

    return data;
  } catch (error) {
    console.error('Failed to send email:', error);
    throw error;
  }
}

export async function sendWelcomeEmail(email: string, name: string) {
  return sendEmail({
    to: email,
    subject: 'Welcome to {{name}}!',
    html: \`
      <h1>Welcome, \${name}!</h1>
      <p>Thanks for signing up. We're excited to have you on board.</p>
    \`
  });
}`,
            priority: 70,
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "resend": "^3.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'RESEND_API_KEY',
            description: 'Resend API key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'EMAIL_FROM',
            description: 'Default from email address',
            required: false,
            type: 'string',
            defaultValue: 'noreply@example.com'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Sign up for Resend and get your API key'
          },
          {
            type: 'manual',
            description: 'Verify your domain in Resend dashboard'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['email', 'transactional', 'notifications']
      },

      // Analytics - PostHog
      {
        name: 'posthog',
        type: 'analytics',
        provider: 'posthog',
        version: '1.0.0',
        description: 'Open-source product analytics',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/analytics.ts',
            template: `import posthog from 'posthog-js';

let posthogClient: ReturnType<typeof posthog.init> | null = null;

export function initAnalytics() {
  if (typeof window === 'undefined') return;
  if (posthogClient) return posthogClient;

  posthogClient = posthog.init(process.env.NEXT_PUBLIC_POSTHOG_KEY!, {
    api_host: process.env.NEXT_PUBLIC_POSTHOG_HOST || 'https://app.posthog.com',
    loaded: (posthog) => {
      if (process.env.NODE_ENV === 'development') posthog.debug();
    }
  });

  return posthogClient;
}

export function trackEvent(event: string, properties?: Record<string, any>) {
  if (!posthogClient) initAnalytics();
  posthogClient?.capture(event, properties);
}

export function identifyUser(userId: string, properties?: Record<string, any>) {
  if (!posthogClient) initAnalytics();
  posthogClient?.identify(userId, properties);
}

export function resetUser() {
  if (!posthogClient) initAnalytics();
  posthogClient?.reset();
}`,
            priority: 60
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "posthog-js": "^1.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_POSTHOG_KEY',
            description: 'PostHog project API key',
            required: true,
            type: 'string',
            sensitive: false
          },
          {
            name: 'NEXT_PUBLIC_POSTHOG_HOST',
            description: 'PostHog API host',
            required: false,
            type: 'url',
            defaultValue: 'https://app.posthog.com'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create a PostHog account and get your project API key'
          },
          {
            type: 'manual',
            description: 'Initialize analytics in your app entry point'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'react', 'vue'],
        databases: [],
        platforms: ['web'],
        tags: ['analytics', 'tracking', 'product-analytics']
      },

      // Monitoring - Sentry
      {
        name: 'sentry',
        type: 'monitoring',
        provider: 'sentry',
        version: '7.0.0',
        description: 'Error tracking and performance monitoring',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/monitoring.ts',
            template: `import * as Sentry from '@sentry/nextjs';

export function initSentry() {
  Sentry.init({
    dsn: process.env.SENTRY_DSN,
    environment: process.env.NODE_ENV,
    tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
    debug: process.env.NODE_ENV === 'development',
    integrations: [
      new Sentry.BrowserTracing(),
      new Sentry.Replay({
        maskAllText: false,
        blockAllMedia: false
      })
    ],
    replaysSessionSampleRate: 0.1,
    replaysOnErrorSampleRate: 1.0
  });
}

export function captureError(error: Error, context?: Record<string, any>) {
  Sentry.captureException(error, {
    extra: context
  });
}

export function captureMessage(message: string, level: 'info' | 'warning' | 'error' = 'info') {
  Sentry.captureMessage(message, level);
}

export function setUser(user: { id: string; email?: string; username?: string }) {
  Sentry.setUser(user);
}

export function clearUser() {
  Sentry.setUser(null);
}`,
            priority: 50
          },
          {
            type: 'file-create',
            target: 'sentry.client.config.ts',
            template: `import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN || process.env.NEXT_PUBLIC_SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: false,
  replaysOnErrorSampleRate: 1.0,
  replaysSessionSampleRate: 0.1,
  integrations: [
    new Sentry.Replay({
      maskAllText: true,
      blockAllMedia: true,
    }),
  ],
});`,
            priority: 50
          },
          {
            type: 'file-create',
            target: 'sentry.server.config.ts',
            template: `import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.SENTRY_DSN,
  tracesSampleRate: 1.0,
  debug: false,
});`,
            priority: 50
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "@sentry/nextjs": "^7.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'SENTRY_DSN',
            description: 'Sentry Data Source Name',
            required: true,
            type: 'url',
            sensitive: true
          },
          {
            name: 'SENTRY_ORG',
            description: 'Sentry organization slug',
            required: false,
            type: 'string'
          },
          {
            name: 'SENTRY_PROJECT',
            description: 'Sentry project slug',
            required: false,
            type: 'string'
          },
          {
            name: 'SENTRY_AUTH_TOKEN',
            description: 'Sentry authentication token for source maps',
            required: false,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create a Sentry account and project'
          },
          {
            type: 'manual',
            description: 'Configure Sentry in your next.config.js'
          },
          {
            type: 'command',
            description: 'Install Sentry wizard',
            command: 'npx @sentry/wizard@latest -i nextjs'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['monitoring', 'error-tracking', 'performance', 'observability']
      },

      // Cache - Redis
      {
        name: 'redis',
        type: 'cache',
        provider: 'redis',
        version: '4.0.0',
        description: 'In-memory data structure store',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/cache.ts',
            template: `import { createClient } from 'redis';

let redisClient: ReturnType<typeof createClient> | null = null;

export async function getRedisClient() {
  if (redisClient) return redisClient;

  redisClient = createClient({
    url: process.env.REDIS_URL
  });

  redisClient.on('error', (err) => console.error('Redis Client Error', err));
  
  await redisClient.connect();
  
  return redisClient;
}

export async function cacheGet<T>(key: string): Promise<T | null> {
  try {
    const client = await getRedisClient();
    const value = await client.get(key);
    return value ? JSON.parse(value) : null;
  } catch (error) {
    console.error('Cache get error:', error);
    return null;
  }
}

export async function cacheSet(
  key: string, 
  value: any, 
  expirationSeconds?: number
): Promise<void> {
  try {
    const client = await getRedisClient();
    const stringValue = JSON.stringify(value);
    
    if (expirationSeconds) {
      await client.setEx(key, expirationSeconds, stringValue);
    } else {
      await client.set(key, stringValue);
    }
  } catch (error) {
    console.error('Cache set error:', error);
  }
}

export async function cacheDelete(key: string): Promise<void> {
  try {
    const client = await getRedisClient();
    await client.del(key);
  } catch (error) {
    console.error('Cache delete error:', error);
  }
}

export async function cacheFlush(): Promise<void> {
  try {
    const client = await getRedisClient();
    await client.flushAll();
  } catch (error) {
    console.error('Cache flush error:', error);
  }
}`,
            priority: 85
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
            priority: 70,
  "dependencies": {
    "redis": "^4.0.0"
  }
}`
          }
        ],
        envVariables: [
          {
            name: 'REDIS_URL',
            description: 'Redis connection URL',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'redis://localhost:6379'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Redis server locally or use a cloud service'
          },
          {
            type: 'manual',
            description: 'Update REDIS_URL with your connection string'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['cache', 'redis', 'performance', 'session-store']
      },

      // Storage - AWS S3
      {
        name: 'aws-s3',
        type: 'storage',
        provider: 's3',
        version: '3.0.0',
        description: 'AWS S3 object storage',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/storage.ts',
            template: `import { S3Client, PutObjectCommand, GetObjectCommand, DeleteObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';

const s3Client = new S3Client({
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
  }
});

const BUCKET_NAME = process.env.S3_BUCKET_NAME!;

export async function uploadFile(
  key: string,
  body: Buffer | Uint8Array | string,
  contentType?: string
) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key,
    Body: body,
    ContentType: contentType
  });

  return s3Client.send(command);
}

export async function getFile(key: string) {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return s3Client.send(command);
}

export async function deleteFile(key: string) {
  const command = new DeleteObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return s3Client.send(command);
}

export async function getSignedUploadUrl(
  key: string,
  expiresIn: number = 3600
) {
  const command = new PutObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return getSignedUrl(s3Client, command, { expiresIn });
}

export async function getSignedDownloadUrl(
  key: string,
  expiresIn: number = 3600
) {
  const command = new GetObjectCommand({
    Bucket: BUCKET_NAME,
    Key: key
  });

  return getSignedUrl(s3Client, command, { expiresIn });
}`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "@aws-sdk/client-s3": "^3.0.0",
    "@aws-sdk/s3-request-presigner": "^3.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'AWS_ACCESS_KEY_ID',
            description: 'AWS Access Key ID',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'AWS_SECRET_ACCESS_KEY',
            description: 'AWS Secret Access Key',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'AWS_REGION',
            description: 'AWS Region',
            required: false,
            type: 'string',
            defaultValue: 'us-east-1'
          },
          {
            name: 'S3_BUCKET_NAME',
            description: 'S3 Bucket Name',
            required: true,
            type: 'string'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create an S3 bucket in AWS Console'
          },
          {
            type: 'manual',
            description: 'Create IAM user with S3 access and get credentials'
          },
          {
            type: 'manual',
            description: 'Configure CORS settings for your S3 bucket if needed'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['storage', 's3', 'aws', 'files', 'uploads']
      },

      // Storage - Cloudinary
      {
        name: 'cloudinary',
        type: 'storage',
        provider: 'cloudinary',
        version: '2.0.0',
        description: 'Cloudinary image and video management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/cloudinary.ts',
            template: `import { v2 as cloudinary } from 'cloudinary';

cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET
});

export async function uploadImage(
  filePath: string,
  options?: {
    folder?: string;
    publicId?: string;
    transformation?: any[];
  }
) {
  return cloudinary.uploader.upload(filePath, {
    folder: options?.folder || 'uploads',
    public_id: options?.publicId,
    transformation: options?.transformation
  });
}

export async function uploadVideo(
  filePath: string,
  options?: {
    folder?: string;
    publicId?: string;
    transformation?: any[];
  }
) {
  return cloudinary.uploader.upload(filePath, {
    resource_type: 'video',
    folder: options?.folder || 'videos',
    public_id: options?.publicId,
    transformation: options?.transformation
  });
}

export async function deleteAsset(publicId: string, resourceType: 'image' | 'video' = 'image') {
  return cloudinary.uploader.destroy(publicId, {
    resource_type: resourceType
  });
}

export function getOptimizedUrl(
  publicId: string,
  options?: {
    width?: number;
    height?: number;
    quality?: number | 'auto';
    format?: string | 'auto';
    crop?: string;
  }
) {
  return cloudinary.url(publicId, {
    width: options?.width,
    height: options?.height,
    quality: options?.quality || 'auto',
    format: options?.format || 'auto',
    crop: options?.crop || 'limit',
    secure: true
  });
}

export function getVideoThumbnail(publicId: string, options?: any) {
  return cloudinary.url(publicId, {
    resource_type: 'video',
    transformation: [
      { width: options?.width || 400, crop: 'limit' },
      { start_offset: options?.offset || '0' }
    ]
  });
}`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "cloudinary": "^2.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'CLOUDINARY_CLOUD_NAME',
            description: 'Cloudinary Cloud Name',
            required: true,
            type: 'string'
          },
          {
            name: 'CLOUDINARY_API_KEY',
            description: 'Cloudinary API Key',
            required: true,
            type: 'string'
          },
          {
            name: 'CLOUDINARY_API_SECRET',
            description: 'Cloudinary API Secret',
            required: true,
            type: 'secret',
            sensitive: true
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Sign up for Cloudinary and get your credentials'
          },
          {
            type: 'manual',
            description: 'Configure upload presets in Cloudinary dashboard'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['storage', 'cloudinary', 'images', 'video', 'media']
      },

      // Queue - BullMQ
      {
        name: 'bullmq',
        type: 'queue',
        provider: 'bullmq',
        version: '5.0.0',
        description: 'BullMQ job queue with Redis backend',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/queue.ts',
            template: `import { Queue, Worker, QueueEvents } from 'bullmq';
import { Redis } from 'ioredis';

const connection = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  maxRetriesPerRequest: null
});

// Define queue names
export const QUEUE_NAMES = {
  EMAIL: 'email',
  IMAGE_PROCESSING: 'image-processing',
  DATA_IMPORT: 'data-import',
  NOTIFICATIONS: 'notifications'
} as const;

// Create queues
export const emailQueue = new Queue(QUEUE_NAMES.EMAIL, { connection });
export const imageQueue = new Queue(QUEUE_NAMES.IMAGE_PROCESSING, { connection });
export const dataQueue = new Queue(QUEUE_NAMES.DATA_IMPORT, { connection });
export const notificationQueue = new Queue(QUEUE_NAMES.NOTIFICATIONS, { connection });

// Queue events for monitoring
export const emailQueueEvents = new QueueEvents(QUEUE_NAMES.EMAIL, { connection });
export const imageQueueEvents = new QueueEvents(QUEUE_NAMES.IMAGE_PROCESSING, { connection });

// Helper function to add job with defaults
export async function addJob<T>(
  queue: Queue,
  name: string,
  data: T,
  options?: {
    delay?: number;
    attempts?: number;
    backoff?: { type: 'exponential' | 'fixed'; delay: number };
    removeOnComplete?: boolean | number;
    removeOnFail?: boolean | number;
  }
) {
  return queue.add(name, data, {
    attempts: options?.attempts || 3,
    backoff: options?.backoff || { type: 'exponential', delay: 2000 },
    removeOnComplete: options?.removeOnComplete ?? 100,
    removeOnFail: options?.removeOnFail ?? 50,
    delay: options?.delay
  });
}

// Get queue metrics
export async function getQueueMetrics(queue: Queue) {
  const [waiting, active, completed, failed, delayed, paused] = await Promise.all([
    queue.getWaitingCount(),
    queue.getActiveCount(),
    queue.getCompletedCount(),
    queue.getFailedCount(),
    queue.getDelayedCount(),
    queue.getPausedCount()
  ]);

  return {
    waiting,
    active,
    completed,
    failed,
    delayed,
    paused,
    total: waiting + active + delayed + paused
  };
}

// Clean old jobs
export async function cleanQueue(queue: Queue, grace: number = 3600000) {
  await queue.clean(grace, 100, 'completed');
  await queue.clean(grace, 100, 'failed');
}`,
            priority: 80
          },
          {
            type: 'file-create',
            target: 'src/workers/email.worker.ts',
            template: `import { Worker, Job } from 'bullmq';
import { Redis } from 'ioredis';
import { QUEUE_NAMES } from '../lib/queue.js';
// Import your email service
// import { sendEmail } from '../lib/email.js';

const connection = new Redis(process.env.REDIS_URL || 'redis://localhost:6379', {
  maxRetriesPerRequest: null
});

export const emailWorker = new Worker(
  QUEUE_NAMES.EMAIL,
  async (job: Job) => {
    const { to, subject, html, text } = job.data;
    
    console.log(\`Processing email job \${job.id}: \${subject} to \${to}\`);
    
    // Send email using your email service
    // await sendEmail({ to, subject, html, text });
    
    // Simulate email sending
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return { sent: true, timestamp: new Date() };
  },
  {
    connection,
    concurrency: 5,
    limiter: {
      max: 10,
      duration: 1000 // Max 10 jobs per second
    }
  }
);

emailWorker.on('completed', (job) => {
  console.log(\`Email job \${job.id} completed\`);
});

emailWorker.on('failed', (job, err) => {
  console.error(\`Email job \${job?.id} failed:\`, err);
});

console.log('Email worker started');`,
            priority: 75
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "bullmq": "^5.0.0",
    "ioredis": "^5.0.0"
  },
  "scripts": {
    "worker:email": "tsx src/workers/email.worker.ts",
    "workers": "concurrently \\"npm:worker:*\\""
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'REDIS_URL',
            description: 'Redis connection URL for BullMQ',
            required: true,
            type: 'url',
            sensitive: true,
            defaultValue: 'redis://localhost:6379'
          }
        ],
        dependencies: [
          {
            serviceType: 'cache',
            provider: 'redis',
            required: true
          }
        ],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Ensure Redis is running for BullMQ'
          },
          {
            type: 'manual',
            description: 'Create additional workers for other queues as needed'
          },
          {
            type: 'command',
            description: 'Install concurrently for running multiple workers',
            command: 'npm install -D concurrently'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express', 'hono'],
        databases: [],
        platforms: ['web'],
        tags: ['queue', 'jobs', 'background', 'bullmq', 'redis']
      },

      // Realtime - Socket.io
      {
        name: 'socket.io',
        type: 'realtime',
        provider: 'socket.io',
        version: '4.0.0',
        description: 'Socket.io for real-time bidirectional communication',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/socket-server.ts',
            template: `import { Server } from 'socket.io';
import { createServer } from 'http';
import type { Server as HTTPServer } from 'http';
import type { Express } from 'express';

let io: Server | null = null;

export function initializeSocketServer(
  app?: Express,
  httpServer?: HTTPServer
) {
  const server = httpServer || createServer(app);
  
  io = new Server(server, {
    cors: {
      origin: process.env.CLIENT_URL || 'http://localhost:3000',
      credentials: true
    },
    transports: ['websocket', 'polling']
  });

  io.on('connection', (socket) => {
    console.log(\`Client connected: \${socket.id}\`);

    // Join user to their personal room
    socket.on('join-room', (roomId: string) => {
      socket.join(roomId);
      console.log(\`Socket \${socket.id} joined room \${roomId}\`);
    });

    // Leave room
    socket.on('leave-room', (roomId: string) => {
      socket.leave(roomId);
      console.log(\`Socket \${socket.id} left room \${roomId}\`);
    });

    // Handle messages
    socket.on('message', async (data: {
      room: string;
      message: string;
      userId: string;
    }) => {
      // Broadcast to room
      io?.to(data.room).emit('new-message', {
        id: Date.now().toString(),
        message: data.message,
        userId: data.userId,
        timestamp: new Date()
      });
    });

    // Handle typing indicators
    socket.on('typing', (data: { room: string; userId: string }) => {
      socket.to(data.room).emit('user-typing', {
        userId: data.userId,
        typing: true
      });
    });

    socket.on('stop-typing', (data: { room: string; userId: string }) => {
      socket.to(data.room).emit('user-typing', {
        userId: data.userId,
        typing: false
      });
    });

    // Handle presence
    socket.on('user-online', (userId: string) => {
      socket.broadcast.emit('user-status', {
        userId,
        status: 'online'
      });
    });

    socket.on('disconnect', () => {
      console.log(\`Client disconnected: \${socket.id}\`);
    });
  });

  return { server, io };
}

// Helper functions for server-side emissions
export function emitToRoom(room: string, event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.to(room).emit(event, data);
}

export function emitToUser(userId: string, event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.to(\`user:\${userId}\`).emit(event, data);
}

export function broadcastToAll(event: string, data: any) {
  if (!io) {
    console.error('Socket.io not initialized');
    return;
  }
  io.emit(event, data);
}

export { io };`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/lib/socket-client.ts',
            template: `import { io, Socket } from 'socket.io-client';

let socket: Socket | null = null;

export function initializeSocket(userId?: string) {
  if (socket?.connected) {
    return socket;
  }

  socket = io(process.env.NEXT_PUBLIC_SOCKET_URL || 'http://localhost:3001', {
    transports: ['websocket', 'polling'],
    autoConnect: true
  });

  socket.on('connect', () => {
    console.log('Connected to socket server');
    
    if (userId) {
      socket?.emit('user-online', userId);
      socket?.emit('join-room', \`user:\${userId}\`);
    }
  });

  socket.on('disconnect', () => {
    console.log('Disconnected from socket server');
  });

  socket.on('error', (error) => {
    console.error('Socket error:', error);
  });

  return socket;
}

export function joinRoom(roomId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('join-room', roomId);
}

export function leaveRoom(roomId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('leave-room', roomId);
}

export function sendMessage(room: string, message: string, userId: string) {
  if (!socket?.connected) {
    console.error('Socket not connected');
    return;
  }
  socket.emit('message', { room, message, userId });
}

export function startTyping(room: string, userId: string) {
  if (!socket?.connected) return;
  socket.emit('typing', { room, userId });
}

export function stopTyping(room: string, userId: string) {
  if (!socket?.connected) return;
  socket.emit('stop-typing', { room, userId });
}

export function onMessage(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('new-message', callback);
}

export function onUserTyping(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('user-typing', callback);
}

export function onUserStatus(callback: (data: any) => void) {
  if (!socket) return;
  socket.on('user-status', callback);
}

export function disconnectSocket() {
  if (socket) {
    socket.disconnect();
    socket = null;
  }
}

export { socket };`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "socket.io": "^4.0.0",
    "socket.io-client": "^4.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'SOCKET_PORT',
            description: 'Port for Socket.io server',
            required: false,
            type: 'number',
            defaultValue: '3001'
          },
          {
            name: 'CLIENT_URL',
            description: 'Client URL for CORS',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          },
          {
            name: 'NEXT_PUBLIC_SOCKET_URL',
            description: 'Socket server URL for client',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:3001'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Socket.io server (standalone or with your HTTP server)'
          },
          {
            type: 'manual',
            description: 'Configure authentication middleware for Socket.io'
          },
          {
            type: 'manual',
            description: 'Implement room-based logic for your use case'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit', 'express'],
        databases: [],
        platforms: ['web'],
        tags: ['realtime', 'websocket', 'socket.io', 'chat', 'notifications']
      },

      // Realtime - Pusher
      {
        name: 'pusher',
        type: 'realtime',
        provider: 'pusher',
        version: '5.0.0',
        description: 'Pusher Channels for real-time features',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/pusher-server.ts',
            template: `import Pusher from 'pusher';

export const pusherServer = new Pusher({
  appId: process.env.PUSHER_APP_ID!,
  key: process.env.NEXT_PUBLIC_PUSHER_KEY!,
  secret: process.env.PUSHER_SECRET!,
  cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
  useTLS: true
});

// Trigger an event to a channel
export async function triggerEvent(
  channel: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(channel, event, data);
}

// Trigger to multiple channels
export async function triggerBatch(
  channels: string[],
  event: string,
  data: any
) {
  return pusherServer.trigger(channels, event, data);
}

// Trigger to a private channel
export async function triggerPrivate(
  userId: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(\`private-user-\${userId}\`, event, data);
}

// Trigger to a presence channel
export async function triggerPresence(
  channelName: string,
  event: string,
  data: any
) {
  return pusherServer.trigger(\`presence-\${channelName}\`, event, data);
}

// Authenticate private/presence channels
export function authenticateChannel(
  socketId: string,
  channel: string,
  presenceData?: {
    user_id: string;
    user_info?: Record<string, any>;
  }
) {
  if (channel.startsWith('presence-') && presenceData) {
    return pusherServer.authorizeChannel(socketId, channel, presenceData);
  }
  
  return pusherServer.authorizeChannel(socketId, channel);
}

// Get channel info
export async function getChannelInfo(channel: string) {
  return pusherServer.get({
    path: \`/channels/\${channel}\`,
    params: { info: 'subscription_count,user_count' }
  });
}

// Get all channels
export async function getChannels() {
  return pusherServer.get({
    path: '/channels',
    params: {}
  });
}`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/lib/pusher-client.ts',
            template: `import Pusher from 'pusher-js';

let pusherClient: Pusher | null = null;

export function initializePusher(userId?: string) {
  if (pusherClient) {
    return pusherClient;
  }

  pusherClient = new Pusher(process.env.NEXT_PUBLIC_PUSHER_KEY!, {
    cluster: process.env.NEXT_PUBLIC_PUSHER_CLUSTER!,
    authEndpoint: '/api/pusher/auth',
    auth: {
      params: { user_id: userId }
    }
  });

  // Enable logging in development
  if (process.env.NODE_ENV === 'development') {
    Pusher.logToConsole = true;
  }

  return pusherClient;
}

export function subscribeToChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(channelName);
}

export function subscribeToPrivateChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(\`private-\${channelName}\`);
}

export function subscribeToPresenceChannel(channelName: string) {
  if (!pusherClient) {
    throw new Error('Pusher not initialized');
  }
  
  return pusherClient.subscribe(\`presence-\${channelName}\`);
}

export function unsubscribe(channelName: string) {
  if (!pusherClient) return;
  
  pusherClient.unsubscribe(channelName);
}

export function bind(channel: any, event: string, callback: (data: any) => void) {
  channel.bind(event, callback);
}

export function unbind(channel: any, event: string, callback?: (data: any) => void) {
  if (callback) {
    channel.unbind(event, callback);
  } else {
    channel.unbind(event);
  }
}

export function disconnect() {
  if (pusherClient) {
    pusherClient.disconnect();
    pusherClient = null;
  }
}

// Hook for React
export function usePusherEvent(
  channelName: string,
  eventName: string,
  callback: (data: any) => void
) {
  if (typeof window === 'undefined') return;
  
  const channel = subscribeToChannel(channelName);
  
  // Subscribe to event
  bind(channel, eventName, callback);
  
  // Cleanup
  return () => {
    unbind(channel, eventName, callback);
    unsubscribe(channelName);
  };
}

export { pusherClient };`,
            priority: 80
          },
          {
            type: 'json-merge',
            target: 'package.json',
            template: `{
  "dependencies": {
    "pusher": "^5.0.0",
    "pusher-js": "^8.0.0"
  }
}`,
            priority: 70
          }
        ],
        envVariables: [
          {
            name: 'PUSHER_APP_ID',
            description: 'Pusher App ID',
            required: true,
            type: 'string'
          },
          {
            name: 'PUSHER_SECRET',
            description: 'Pusher Secret',
            required: true,
            type: 'secret',
            sensitive: true
          },
          {
            name: 'NEXT_PUBLIC_PUSHER_KEY',
            description: 'Pusher Key (public)',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_PUSHER_CLUSTER',
            description: 'Pusher Cluster',
            required: true,
            type: 'string',
            defaultValue: 'eu'
          }
        ],
        dependencies: [],
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Pusher account and app at pusher.com'
          },
          {
            type: 'manual',
            description: 'Create API endpoint for channel authentication (/api/pusher/auth)'
          },
          {
            type: 'manual',
            description: 'Implement presence channel logic if needed'
          }
        ],
        frameworks: ['next', 'remix', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['realtime', 'pusher', 'websocket', 'channels', 'presence']
      },

      // CMS - Strapi
      {
        name: 'strapi',
        type: 'cms',
        provider: 'strapi',
        version: '4.0.0',
        description: 'Leading open-source headless CMS',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/strapi.ts',
            template: `import axios from 'axios';

const strapiUrl = process.env.STRAPI_URL || 'http://localhost:1337';
const strapiToken = process.env.STRAPI_API_TOKEN;

const strapiClient = axios.create({
  baseURL: \`\${strapiUrl}/api\`,
  headers: {
    'Authorization': \`Bearer \${strapiToken}\`,
    'Content-Type': 'application/json'
  }
});

export interface StrapiResponse<T> {
  data: T;
  meta: {
    pagination?: {
      page: number;
      pageSize: number;
      pageCount: number;
      total: number;
    };
  };
}

export async function getEntries<T>(
  contentType: string,
  params?: Record<string, any>
): Promise<StrapiResponse<T[]>> {
  const response = await strapiClient.get(\`/\${contentType}\`, { params });
  return response.data;
}

export async function getEntry<T>(
  contentType: string,
  id: string | number,
  params?: Record<string, any>
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.get(\`/\${contentType}/\${id}\`, { params });
  return response.data;
}

export async function createEntry<T>(
  contentType: string,
  data: any
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.post(\`/\${contentType}\`, { data });
  return response.data;
}

export async function updateEntry<T>(
  contentType: string,
  id: string | number,
  data: any
): Promise<StrapiResponse<T>> {
  const response = await strapiClient.put(\`/\${contentType}/\${id}\`, { data });
  return response.data;
}

export async function deleteEntry(
  contentType: string,
  id: string | number
): Promise<void> {
  await strapiClient.delete(\`/\${contentType}/\${id}\`);
}

export async function uploadFile(file: File): Promise<any> {
  const formData = new FormData();
  formData.append('files', file);

  const response = await strapiClient.post('/upload', formData, {
    headers: {
      'Content-Type': 'multipart/form-data'
    }
  });

  return response.data;
}

export { strapiClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'STRAPI_URL',
            description: 'Strapi server URL',
            required: true,
            type: 'url',
            defaultValue: 'http://localhost:1337'
          },
          {
            name: 'STRAPI_API_TOKEN',
            description: 'Strapi API token',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          axios: '^1.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Strapi backend at https://strapi.io'
          },
          {
            type: 'manual',
            description: 'Create API token in Strapi admin panel'
          },
          {
            type: 'manual',
            description: 'Configure content types and permissions'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'strapi', 'api']
      },

      // CMS - Contentful
      {
        name: 'contentful',
        type: 'cms',
        provider: 'contentful',
        version: '10.0.0',
        description: 'API-first content management platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/contentful.ts',
            template: `import { createClient, Entry, Asset } from 'contentful';

const client = createClient({
  space: process.env.CONTENTFUL_SPACE_ID!,
  accessToken: process.env.CONTENTFUL_ACCESS_TOKEN!,
  environment: process.env.CONTENTFUL_ENVIRONMENT || 'master'
});

const previewClient = createClient({
  space: process.env.CONTENTFUL_SPACE_ID!,
  accessToken: process.env.CONTENTFUL_PREVIEW_TOKEN!,
  environment: process.env.CONTENTFUL_ENVIRONMENT || 'master',
  host: 'preview.contentful.com'
});

export function getClient(preview = false) {
  return preview ? previewClient : client;
}

export interface ContentfulCollection<T> {
  items: T[];
  total: number;
  skip: number;
  limit: number;
}

export async function getEntries<T extends Entry<any>>(
  contentType: string,
  query?: any,
  preview = false
): Promise<ContentfulCollection<T>> {
  const entries = await getClient(preview).getEntries({
    content_type: contentType,
    ...query
  });

  return entries as ContentfulCollection<T>;
}

export async function getEntry<T extends Entry<any>>(
  id: string,
  query?: any,
  preview = false
): Promise<T> {
  const entry = await getClient(preview).getEntry(id, query);
  return entry as T;
}

export async function getAsset(
  id: string,
  preview = false
): Promise<Asset> {
  return await getClient(preview).getAsset(id);
}

export async function getAssets(
  query?: any,
  preview = false
): Promise<ContentfulCollection<Asset>> {
  const assets = await getClient(preview).getAssets(query);
  return assets as ContentfulCollection<Asset>;
}

// Rich text renderer helper
export { documentToReactComponents } from '@contentful/rich-text-react-renderer';
export { BLOCKS, MARKS, INLINES } from '@contentful/rich-text-types';`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'CONTENTFUL_SPACE_ID',
            description: 'Contentful space ID',
            required: true,
            type: 'string'
          },
          {
            name: 'CONTENTFUL_ACCESS_TOKEN',
            description: 'Contentful delivery API token',
            required: true,
            type: 'secret'
          },
          {
            name: 'CONTENTFUL_PREVIEW_TOKEN',
            description: 'Contentful preview API token',
            required: false,
            type: 'secret'
          },
          {
            name: 'CONTENTFUL_ENVIRONMENT',
            description: 'Contentful environment',
            required: false,
            type: 'string',
            defaultValue: 'master'
          }
        ],
        dependencies: {
          contentful: '^10.0.0',
          '@contentful/rich-text-react-renderer': '^15.0.0',
          '@contentful/rich-text-types': '^16.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Contentful space at https://www.contentful.com'
          },
          {
            type: 'manual',
            description: 'Set up content models in Contentful'
          },
          {
            type: 'manual',
            description: 'Generate API tokens from Settings > API keys'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'contentful', 'api']
      },

      // CMS - Sanity
      {
        name: 'sanity',
        type: 'cms',
        provider: 'sanity',
        version: '3.0.0',
        description: 'Platform for structured content',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/sanity/client.ts',
            template: `import { createClient } from '@sanity/client';
import imageUrlBuilder from '@sanity/image-url';

export const sanityClient = createClient({
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET || 'production',
  apiVersion: '2024-01-01',
  useCdn: process.env.NODE_ENV === 'production',
  token: process.env.SANITY_API_TOKEN
});

const builder = imageUrlBuilder(sanityClient);

export function urlFor(source: any) {
  return builder.image(source);
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'src/lib/sanity/queries.ts',
            template: `import { groq } from 'next-sanity';

// Example queries
export const postsQuery = groq\`
  *[_type == "post" && defined(slug.current)]{
    _id,
    title,
    slug,
    excerpt,
    mainImage,
    publishedAt,
    "author": author->name
  } | order(publishedAt desc)
\`;

export const postBySlugQuery = groq\`
  *[_type == "post" && slug.current == $slug][0]{
    _id,
    title,
    slug,
    excerpt,
    mainImage,
    body,
    publishedAt,
    "author": author->{
      name,
      image
    }
  }
\`;

export const pagesQuery = groq\`
  *[_type == "page" && defined(slug.current)]{
    _id,
    title,
    slug,
    content
  }
\`;`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'sanity.config.ts',
            template: `import { defineConfig } from 'sanity';
import { deskTool } from 'sanity/desk';
import { visionTool } from '@sanity/vision';
import { schemaTypes } from './sanity/schemas';

export default defineConfig({
  name: 'default',
  title: process.env.NEXT_PUBLIC_SANITY_PROJECT_TITLE || 'My Project',
  projectId: process.env.NEXT_PUBLIC_SANITY_PROJECT_ID!,
  dataset: process.env.NEXT_PUBLIC_SANITY_DATASET || 'production',
  plugins: [deskTool(), visionTool()],
  schema: {
    types: schemaTypes,
  },
});`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_SANITY_PROJECT_ID',
            description: 'Sanity project ID',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_SANITY_DATASET',
            description: 'Sanity dataset name',
            required: false,
            type: 'string',
            defaultValue: 'production'
          },
          {
            name: 'SANITY_API_TOKEN',
            description: 'Sanity API token (for mutations)',
            required: false,
            type: 'secret'
          },
          {
            name: 'NEXT_PUBLIC_SANITY_PROJECT_TITLE',
            description: 'Sanity studio title',
            required: false,
            type: 'string'
          }
        ],
        dependencies: {
          '@sanity/client': '^6.0.0',
          '@sanity/image-url': '^1.0.0',
          'next-sanity': '^7.0.0',
          sanity: '^3.0.0',
          '@sanity/vision': '^3.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Initialize Sanity studio',
            command: 'npx sanity init'
          },
          {
            type: 'manual',
            description: 'Create schemas in sanity/schemas directory'
          },
          {
            type: 'manual',
            description: 'Deploy Sanity studio with: npx sanity deploy'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'headless', 'content', 'sanity', 'groq']
      },

      // CMS - Payload
      {
        name: 'payload',
        type: 'cms',
        provider: 'payload',
        version: '2.0.0',
        description: 'TypeScript headless CMS',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/payload.config.ts',
            template: `import { buildConfig } from 'payload/config';
import path from 'path';
import Users from './collections/Users';
import Media from './collections/Media';

export default buildConfig({
  serverURL: process.env.PAYLOAD_PUBLIC_SERVER_URL || 'http://localhost:3000',
  admin: {
    user: Users.slug,
    bundler: 'webpack',
  },
  collections: [Users, Media],
  typescript: {
    outputFile: path.resolve(__dirname, 'payload-types.ts'),
  },
  graphQL: {
    schemaOutputFile: path.resolve(__dirname, 'generated-schema.graphql'),
  },
  cors: '*',
  csrf: [
    process.env.PAYLOAD_PUBLIC_SERVER_URL || 'http://localhost:3000',
  ],
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'src/collections/Users.ts',
            template: `import { CollectionConfig } from 'payload/types';

const Users: CollectionConfig = {
  slug: 'users',
  auth: true,
  admin: {
    useAsTitle: 'email',
  },
  fields: [
    {
      name: 'name',
      type: 'text',
      required: true,
    },
    {
      name: 'role',
      type: 'select',
      options: [
        { label: 'Admin', value: 'admin' },
        { label: 'Editor', value: 'editor' },
        { label: 'User', value: 'user' },
      ],
      defaultValue: 'user',
      required: true,
    },
  ],
};

export default Users;`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/collections/Media.ts',
            template: `import { CollectionConfig } from 'payload/types';

const Media: CollectionConfig = {
  slug: 'media',
  upload: {
    staticURL: '/media',
    staticDir: 'media',
    imageSizes: [
      {
        name: 'thumbnail',
        width: 400,
        height: 300,
        position: 'centre',
      },
      {
        name: 'card',
        width: 768,
        height: 1024,
        position: 'centre',
      },
      {
        name: 'tablet',
        width: 1024,
        height: undefined,
        position: 'centre',
      },
    ],
    adminThumbnail: 'thumbnail',
    mimeTypes: ['image/*'],
  },
  fields: [
    {
      name: 'alt',
      type: 'text',
    },
  ],
};

export default Media;`,
            priority: 95
          }
        ],
        envVariables: [
          {
            name: 'PAYLOAD_PUBLIC_SERVER_URL',
            description: 'Payload server URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          },
          {
            name: 'PAYLOAD_SECRET',
            description: 'Payload secret key',
            required: true,
            type: 'secret'
          },
          {
            name: 'MONGODB_URI',
            description: 'MongoDB connection string',
            required: true,
            type: 'connection_string'
          }
        ],
        dependencies: {
          payload: '^2.0.0',
          '@payloadcms/bundler-webpack': '^1.0.0',
          '@payloadcms/db-mongodb': '^1.0.0',
          '@payloadcms/richtext-slate': '^1.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MongoDB database'
          },
          {
            type: 'manual',
            description: 'Create collections in src/collections directory'
          },
          {
            type: 'manual',
            description: 'Configure admin UI and access control'
          }
        ],
        frameworks: ['next', 'express'],
        databases: ['mongodb'],
        platforms: ['web'],
        tags: ['cms', 'headless', 'typescript', 'payload', 'admin']
      },

      // CMS - Ghost
      {
        name: 'ghost',
        type: 'cms',
        provider: 'ghost',
        version: '5.0.0',
        description: 'Professional publishing platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ghost.ts',
            template: `import GhostContentAPI from '@tryghost/content-api';
import GhostAdminAPI from '@tryghost/admin-api';

// Content API for public content
export const ghostContent = new GhostContentAPI({
  url: process.env.GHOST_URL!,
  key: process.env.GHOST_CONTENT_API_KEY!,
  version: 'v5.0'
});

// Admin API for content management (optional)
export const ghostAdmin = process.env.GHOST_ADMIN_API_KEY
  ? new GhostAdminAPI({
      url: process.env.GHOST_URL!,
      key: process.env.GHOST_ADMIN_API_KEY,
      version: 'v5.0'
    })
  : null;

// Helper functions
export async function getPosts(options = {}) {
  return await ghostContent.posts.browse({
    limit: 'all',
    include: ['tags', 'authors'],
    ...options
  });
}

export async function getPost(slug: string) {
  return await ghostContent.posts.read(
    { slug },
    { include: ['tags', 'authors'] }
  );
}

export async function getPages(options = {}) {
  return await ghostContent.pages.browse({
    limit: 'all',
    ...options
  });
}

export async function getPage(slug: string) {
  return await ghostContent.pages.read({ slug });
}

export async function getTags(options = {}) {
  return await ghostContent.tags.browse({
    limit: 'all',
    ...options
  });
}

export async function getAuthors(options = {}) {
  return await ghostContent.authors.browse({
    limit: 'all',
    ...options
  });
}`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'GHOST_URL',
            description: 'Ghost instance URL',
            required: true,
            type: 'url'
          },
          {
            name: 'GHOST_CONTENT_API_KEY',
            description: 'Ghost Content API key',
            required: true,
            type: 'secret'
          },
          {
            name: 'GHOST_ADMIN_API_KEY',
            description: 'Ghost Admin API key (optional)',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          '@tryghost/content-api': '^1.11.0',
          '@tryghost/admin-api': '^1.13.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Ghost instance (self-hosted or Ghost Pro)'
          },
          {
            type: 'manual',
            description: 'Generate API keys from Ghost Admin > Integrations'
          },
          {
            type: 'manual',
            description: 'Configure webhooks for content updates (optional)'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['cms', 'blog', 'publishing', 'ghost', 'content']
      },

      // Search - Elasticsearch
      {
        name: 'elasticsearch',
        type: 'search',
        provider: 'elasticsearch',
        version: '8.0.0',
        description: 'Distributed search and analytics engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/elasticsearch.ts',
            template: `import { Client } from '@elastic/elasticsearch';

const client = new Client({
  node: process.env.ELASTICSEARCH_URL || 'http://localhost:9200',
  auth: process.env.ELASTICSEARCH_API_KEY
    ? { apiKey: process.env.ELASTICSEARCH_API_KEY }
    : process.env.ELASTICSEARCH_USERNAME
    ? {
        username: process.env.ELASTICSEARCH_USERNAME,
        password: process.env.ELASTICSEARCH_PASSWORD || ''
      }
    : undefined
});

export interface SearchResult<T = any> {
  hits: {
    total: { value: number; relation: string };
    hits: Array<{
      _id: string;
      _index: string;
      _score: number;
      _source: T;
      highlight?: Record<string, string[]>;
    }>;
  };
  aggregations?: any;
}

export async function search<T = any>(
  index: string,
  query: any,
  options?: {
    from?: number;
    size?: number;
    sort?: any[];
    highlight?: any;
    aggs?: any;
  }
): Promise<SearchResult<T>> {
  const response = await client.search({
    index,
    body: {
      query,
      ...options
    }
  });

  return response.body as SearchResult<T>;
}

export async function index<T = any>(
  index: string,
  id: string,
  document: T,
  refresh?: boolean
): Promise<void> {
  await client.index({
    index,
    id,
    body: document,
    refresh: refresh ? 'true' : undefined
  });
}

export async function bulkIndex<T = any>(
  index: string,
  documents: Array<{ id: string; document: T }>
): Promise<void> {
  const body = documents.flatMap(({ id, document }) => [
    { index: { _index: index, _id: id } },
    document
  ]);

  await client.bulk({ body, refresh: true });
}

export async function deleteDocument(
  index: string,
  id: string
): Promise<void> {
  await client.delete({ index, id });
}

export async function createIndex(
  index: string,
  mappings?: any,
  settings?: any
): Promise<void> {
  await client.indices.create({
    index,
    body: {
      mappings,
      settings
    }
  });
}

export async function deleteIndex(index: string): Promise<void> {
  await client.indices.delete({ index });
}

export { client as elasticsearchClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'ELASTICSEARCH_URL',
            description: 'Elasticsearch cluster URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:9200'
          },
          {
            name: 'ELASTICSEARCH_API_KEY',
            description: 'Elasticsearch API key',
            required: false,
            type: 'secret'
          },
          {
            name: 'ELASTICSEARCH_USERNAME',
            description: 'Elasticsearch username',
            required: false,
            type: 'string'
          },
          {
            name: 'ELASTICSEARCH_PASSWORD',
            description: 'Elasticsearch password',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          '@elastic/elasticsearch': '^8.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Elasticsearch cluster (local or cloud)'
          },
          {
            type: 'manual',
            description: 'Create indices and mappings for your data'
          },
          {
            type: 'manual',
            description: 'Configure authentication and security'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'elasticsearch', 'full-text', 'analytics', 'distributed']
      },

      // Search - Algolia
      {
        name: 'algolia',
        type: 'search',
        provider: 'algolia',
        version: '4.0.0',
        description: 'Hosted search API',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/algolia.ts',
            template: `import algoliasearch from 'algoliasearch';
import { SearchClient, SearchIndex } from 'algoliasearch';

const client: SearchClient = algoliasearch(
  process.env.NEXT_PUBLIC_ALGOLIA_APP_ID!,
  process.env.ALGOLIA_ADMIN_KEY!
);

// Client-side search (read-only)
export const searchClient = algoliasearch(
  process.env.NEXT_PUBLIC_ALGOLIA_APP_ID!,
  process.env.NEXT_PUBLIC_ALGOLIA_SEARCH_KEY!
);

export function getIndex(indexName: string): SearchIndex {
  return client.initIndex(indexName);
}

export interface AlgoliaSearchResult<T = any> {
  hits: T[];
  nbHits: number;
  page: number;
  nbPages: number;
  hitsPerPage: number;
  processingTimeMS: number;
  query: string;
}

export async function search<T = any>(
  indexName: string,
  query: string,
  options?: {
    page?: number;
    hitsPerPage?: number;
    filters?: string;
    facets?: string[];
    attributesToRetrieve?: string[];
    attributesToHighlight?: string[];
  }
): Promise<AlgoliaSearchResult<T>> {
  const index = searchClient.initIndex(indexName);
  const result = await index.search<T>(query, options);
  return result;
}

export async function saveObject<T extends { objectID?: string }>(
  indexName: string,
  object: T
): Promise<string> {
  const index = getIndex(indexName);
  const result = await index.saveObject(object, {
    autoGenerateObjectIDIfNotExist: true
  });
  return result.objectID;
}

export async function saveObjects<T extends { objectID?: string }>(
  indexName: string,
  objects: T[]
): Promise<string[]> {
  const index = getIndex(indexName);
  const result = await index.saveObjects(objects, {
    autoGenerateObjectIDIfNotExist: true
  });
  return result.objectIDs;
}

export async function deleteObject(
  indexName: string,
  objectID: string
): Promise<void> {
  const index = getIndex(indexName);
  await index.deleteObject(objectID);
}

export async function deleteObjects(
  indexName: string,
  objectIDs: string[]
): Promise<void> {
  const index = getIndex(indexName);
  await index.deleteObjects(objectIDs);
}

export async function clearIndex(indexName: string): Promise<void> {
  const index = getIndex(indexName);
  await index.clearObjects();
}

// React InstantSearch components
export { InstantSearch, SearchBox, Hits, Pagination, RefinementList } from 'react-instantsearch';`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'NEXT_PUBLIC_ALGOLIA_APP_ID',
            description: 'Algolia Application ID',
            required: true,
            type: 'string'
          },
          {
            name: 'NEXT_PUBLIC_ALGOLIA_SEARCH_KEY',
            description: 'Algolia Search-Only API Key',
            required: true,
            type: 'secret'
          },
          {
            name: 'ALGOLIA_ADMIN_KEY',
            description: 'Algolia Admin API Key',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          algoliasearch: '^4.0.0',
          'react-instantsearch': '^7.0.0',
          'instantsearch.js': '^4.0.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Create Algolia account at https://www.algolia.com'
          },
          {
            type: 'manual',
            description: 'Set up indices and configure searchable attributes'
          },
          {
            type: 'manual',
            description: 'Configure relevance and ranking rules'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['search', 'algolia', 'hosted', 'instant-search', 'facets']
      },

      // Search - MeiliSearch
      {
        name: 'meilisearch',
        type: 'search',
        provider: 'meilisearch',
        version: '1.0.0',
        description: 'Lightning fast search engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/meilisearch.ts',
            template: `import { MeiliSearch, Index, SearchResponse } from 'meilisearch';

const client = new MeiliSearch({
  host: process.env.MEILISEARCH_URL || 'http://localhost:7700',
  apiKey: process.env.MEILISEARCH_API_KEY
});

export function getIndex<T = any>(indexUid: string): Index<T> {
  return client.index<T>(indexUid);
}

export interface MeiliSearchResult<T = any> extends SearchResponse<T> {
  hits: T[];
  offset: number;
  limit: number;
  estimatedTotalHits: number;
  processingTimeMs: number;
  query: string;
}

export async function search<T = any>(
  indexUid: string,
  query: string,
  options?: {
    offset?: number;
    limit?: number;
    filter?: string | string[];
    facets?: string[];
    attributesToRetrieve?: string[];
    attributesToHighlight?: string[];
    attributesToCrop?: string[];
    cropLength?: number;
    sort?: string[];
  }
): Promise<MeiliSearchResult<T>> {
  const index = getIndex<T>(indexUid);
  const result = await index.search(query, options);
  return result as MeiliSearchResult<T>;
}

export async function addDocuments<T extends { id?: string | number }>(
  indexUid: string,
  documents: T[],
  primaryKey?: string
): Promise<void> {
  const index = getIndex<T>(indexUid);
  await index.addDocuments(documents, { primaryKey });
}

export async function updateDocuments<T extends { id?: string | number }>(
  indexUid: string,
  documents: T[]
): Promise<void> {
  const index = getIndex<T>(indexUid);
  await index.updateDocuments(documents);
}

export async function deleteDocument(
  indexUid: string,
  documentId: string | number
): Promise<void> {
  const index = getIndex(indexUid);
  await index.deleteDocument(documentId);
}

export async function deleteDocuments(
  indexUid: string,
  documentIds: (string | number)[]
): Promise<void> {
  const index = getIndex(indexUid);
  await index.deleteDocuments(documentIds);
}

export async function createIndex(
  uid: string,
  options?: { primaryKey?: string }
): Promise<void> {
  await client.createIndex(uid, options);
}

export async function updateIndexSettings(
  indexUid: string,
  settings: {
    searchableAttributes?: string[];
    displayedAttributes?: string[];
    filterableAttributes?: string[];
    sortableAttributes?: string[];
    rankingRules?: string[];
    stopWords?: string[];
    synonyms?: Record<string, string[]>;
  }
): Promise<void> {
  const index = getIndex(indexUid);
  await index.updateSettings(settings);
}

export { client as meilisearchClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'MEILISEARCH_URL',
            description: 'MeiliSearch server URL',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:7700'
          },
          {
            name: 'MEILISEARCH_API_KEY',
            description: 'MeiliSearch master key',
            required: false,
            type: 'secret'
          }
        ],
        dependencies: {
          meilisearch: '^0.37.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up MeiliSearch server (Docker or cloud)'
          },
          {
            type: 'manual',
            description: 'Create indices and configure settings'
          },
          {
            type: 'manual',
            description: 'Set up API keys for production'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'meilisearch', 'typo-tolerant', 'fast', 'self-hosted']
      },

      // Search - Typesense
      {
        name: 'typesense',
        type: 'search',
        provider: 'typesense',
        version: '1.0.0',
        description: 'Fast, typo-tolerant search engine',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/typesense.ts',
            template: `import Typesense from 'typesense';
import { SearchClient } from 'typesense';

const client = new Typesense.Client({
  nodes: [
    {
      host: process.env.TYPESENSE_HOST || 'localhost',
      port: parseInt(process.env.TYPESENSE_PORT || '8108'),
      protocol: process.env.TYPESENSE_PROTOCOL || 'http'
    }
  ],
  apiKey: process.env.TYPESENSE_API_KEY!,
  connectionTimeoutSeconds: 2
});

export interface TypesenseSearchResult<T = any> {
  found: number;
  hits: Array<{
    document: T;
    highlights: Array<{
      field: string;
      snippet: string;
      value: string;
    }>;
    text_match: number;
  }>;
  facet_counts?: Array<{
    field_name: string;
    counts: Array<{
      count: number;
      highlighted: string;
      value: string;
    }>;
  }>;
  page: number;
  request_params: {
    collection_name: string;
    q: string;
  };
  search_time_ms: number;
}

export async function search<T = any>(
  collection: string,
  query: string,
  options?: {
    query_by: string;
    filter_by?: string;
    sort_by?: string;
    page?: number;
    per_page?: number;
    facet_by?: string;
    include_fields?: string;
    exclude_fields?: string;
    highlight_fields?: string;
    num_typos?: number;
  }
): Promise<TypesenseSearchResult<T>> {
  const searchParameters = {
    q: query,
    query_by: options?.query_by || '*',
    ...options
  };

  const result = await client
    .collections(collection)
    .documents()
    .search(searchParameters);

  return result as TypesenseSearchResult<T>;
}

export async function createDocument<T extends { id?: string }>(
  collection: string,
  document: T
): Promise<T> {
  const result = await client
    .collections(collection)
    .documents()
    .create(document);
  
  return result as T;
}

export async function upsertDocument<T extends { id?: string }>(
  collection: string,
  document: T
): Promise<T> {
  const result = await client
    .collections(collection)
    .documents()
    .upsert(document);
  
  return result as T;
}

export async function deleteDocument(
  collection: string,
  id: string
): Promise<void> {
  await client
    .collections(collection)
    .documents(id)
    .delete();
}

export async function createCollection(schema: {
  name: string;
  fields: Array<{
    name: string;
    type: 'string' | 'int32' | 'int64' | 'float' | 'bool' | 'string[]' | 'int32[]' | 'int64[]' | 'float[]' | 'bool[]' | 'auto';
    facet?: boolean;
    optional?: boolean;
    index?: boolean;
  }>;
  default_sorting_field?: string;
}): Promise<void> {
  await client.collections().create(schema);
}

export async function deleteCollection(name: string): Promise<void> {
  await client.collections(name).delete();
}

export { client as typesenseClient };`,
            priority: 100
          }
        ],
        envVariables: [
          {
            name: 'TYPESENSE_HOST',
            description: 'Typesense server host',
            required: false,
            type: 'string',
            defaultValue: 'localhost'
          },
          {
            name: 'TYPESENSE_PORT',
            description: 'Typesense server port',
            required: false,
            type: 'number',
            defaultValue: '8108'
          },
          {
            name: 'TYPESENSE_PROTOCOL',
            description: 'Typesense server protocol',
            required: false,
            type: 'string',
            defaultValue: 'http'
          },
          {
            name: 'TYPESENSE_API_KEY',
            description: 'Typesense API key',
            required: true,
            type: 'secret'
          }
        ],
        dependencies: {
          typesense: '^1.7.0'
        },
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Set up Typesense server (Docker or Typesense Cloud)'
          },
          {
            type: 'manual',
            description: 'Create collections with schema definitions'
          },
          {
            type: 'manual',
            description: 'Configure search-only API keys for client-side usage'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['search', 'typesense', 'typo-tolerant', 'faceted', 'fast']
      },

      // Testing - Jest
      {
        name: 'jest',
        type: 'testing',
        provider: 'jest',
        version: '29.0.0',
        description: 'Delightful JavaScript testing framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'jest.config.js',
            template: `/** @type {import('jest').Config} */
module.exports = {
  testEnvironment: 'node',
  transform: {
    '^.+\\.(t|j)sx?$': ['@swc/jest'],
  },
  extensionsToTreatAsEsm: ['.ts', '.tsx'],
  moduleNameMapper: {
    '^@/(.*)$': '<rootDir>/src/$1',
    '^~/(.*)$': '<rootDir>/$1'
  },
  testMatch: [
    '**/__tests__/**/*.(test|spec).(ts|tsx|js)',
    '**/*.(test|spec).(ts|tsx|js)'
  ],
  collectCoverageFrom: [
    'src/**/*.{ts,tsx,js,jsx}',
    '!src/**/*.d.ts',
    '!src/**/*.stories.tsx',
    '!src/**/index.ts'
  ],
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  },
  setupFilesAfterEnv: ['<rootDir>/jest.setup.js']
};`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'jest.setup.js',
            template: `// Add custom jest matchers
import '@testing-library/jest-dom';

// Mock environment variables
process.env.NODE_ENV = 'test';

// Global test utilities
global.testUtils = {
  waitFor: (ms) => new Promise(resolve => setTimeout(resolve, ms))
};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/__tests__/example.test.ts',
            template: `describe('Example Test Suite', () => {
  it('should pass a basic test', () => {
    expect(true).toBe(true);
  });

  it('should test async operations', async () => {
    const result = await Promise.resolve('success');
    expect(result).toBe('success');
  });

  it('should test with mocks', () => {
    const mockFn = jest.fn();
    mockFn('test');
    expect(mockFn).toHaveBeenCalledWith('test');
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          jest: '^29.0.0',
          '@types/jest': '^29.0.0',
          '@swc/jest': '^0.2.0',
          '@testing-library/jest-dom': '^6.0.0',
          '@testing-library/react': '^14.0.0',
          '@testing-library/user-event': '^14.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test script to package.json',
            command: 'npm pkg set scripts.test="jest" scripts.test:watch="jest --watch" scripts.test:coverage="jest --coverage"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'jest', 'unit-test', 'coverage', 'mocking']
      },

      // Testing - Vitest
      {
        name: 'vitest',
        type: 'testing',
        provider: 'vitest',
        version: '1.0.0',
        description: 'Blazing fast unit test framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'vitest.config.ts',
            template: `import { defineConfig } from 'vitest/config';
import path from 'path';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./vitest.setup.ts'],
    include: ['**/*.{test,spec}.{js,mjs,cjs,ts,mts,cts,jsx,tsx}'],
    coverage: {
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/',
        'dist/',
        '**/*.d.ts',
        '**/*.config.*',
        '**/mockData/**',
        '**/*.stories.tsx'
      ],
      thresholds: {
        global: {
          branches: 80,
          functions: 80,
          lines: 80,
          statements: 80
        }
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
      '~': path.resolve(__dirname, './')
    }
  }
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'vitest.setup.ts',
            template: `import { expect, afterEach } from 'vitest';
import { cleanup } from '@testing-library/react';
import * as matchers from '@testing-library/jest-dom/matchers';

// Extend Vitest's expect with jest-dom matchers
expect.extend(matchers);

// Cleanup after each test
afterEach(() => {
  cleanup();
});

// Mock environment variables
process.env.NODE_ENV = 'test';

// Global test utilities
globalThis.testUtils = {
  waitFor: (ms: number) => new Promise(resolve => setTimeout(resolve, ms))
};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'src/__tests__/example.test.ts',
            template: `import { describe, it, expect, vi } from 'vitest';

describe('Example Test Suite', () => {
  it('should pass a basic test', () => {
    expect(true).toBe(true);
  });

  it('should test async operations', async () => {
    const result = await Promise.resolve('success');
    expect(result).toBe('success');
  });

  it('should test with mocks', () => {
    const mockFn = vi.fn();
    mockFn('test');
    expect(mockFn).toHaveBeenCalledWith('test');
  });

  it('should test with spies', () => {
    const obj = {
      method: () => 'original'
    };
    const spy = vi.spyOn(obj, 'method');
    obj.method();
    expect(spy).toHaveBeenCalled();
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          vitest: '^1.0.0',
          '@vitest/ui': '^1.0.0',
          '@vitest/coverage-v8': '^1.0.0',
          '@testing-library/react': '^14.0.0',
          '@testing-library/jest-dom': '^6.0.0',
          '@testing-library/user-event': '^14.0.0',
          jsdom: '^23.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test="vitest" scripts.test:ui="vitest --ui" scripts.test:coverage="vitest --coverage"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'vitest', 'unit-test', 'vite', 'fast']
      },

      // Testing - Playwright
      {
        name: 'playwright',
        type: 'testing',
        provider: 'playwright',
        version: '1.40.0',
        description: 'End-to-end testing framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'playwright.config.ts',
            template: `import { defineConfig, devices } from '@playwright/test';

export default defineConfig({
  testDir: './e2e',
  fullyParallel: true,
  forbidOnly: !!process.env.CI,
  retries: process.env.CI ? 2 : 0,
  workers: process.env.CI ? 1 : undefined,
  reporter: 'html',
  use: {
    baseURL: 'http://localhost:3000',
    trace: 'on-first-retry',
    screenshot: 'only-on-failure',
    video: 'retain-on-failure'
  },
  projects: [
    {
      name: 'chromium',
      use: { ...devices['Desktop Chrome'] },
    },
    {
      name: 'firefox',
      use: { ...devices['Desktop Firefox'] },
    },
    {
      name: 'webkit',
      use: { ...devices['Desktop Safari'] },
    },
    {
      name: 'Mobile Chrome',
      use: { ...devices['Pixel 5'] },
    },
    {
      name: 'Mobile Safari',
      use: { ...devices['iPhone 12'] },
    },
  ],
  webServer: {
    command: 'npm run dev',
    port: 3000,
    reuseExistingServer: !process.env.CI,
  },
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'e2e/example.spec.ts',
            template: `import { test, expect } from '@playwright/test';

test.describe('Example E2E Tests', () => {
  test.beforeEach(async ({ page }) => {
    await page.goto('/');
  });

  test('should display homepage', async ({ page }) => {
    await expect(page).toHaveTitle(/Home/);
    await expect(page.locator('h1')).toBeVisible();
  });

  test('should navigate to about page', async ({ page }) => {
    await page.click('text=About');
    await expect(page).toHaveURL(/.*about/);
  });

  test('should fill and submit form', async ({ page }) => {
    await page.fill('input[name="email"]', 'test@example.com');
    await page.fill('input[name="password"]', 'password123');
    await page.click('button[type="submit"]');
    
    await expect(page.locator('.success-message')).toBeVisible();
  });

  test('should handle API responses', async ({ page }) => {
    // Mock API response
    await page.route('**/api/users', route => {
      route.fulfill({
        status: 200,
        body: JSON.stringify({ users: [] })
      });
    });

    await page.goto('/users');
    await expect(page.locator('.user-list')).toBeVisible();
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          '@playwright/test': '^1.40.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Install Playwright browsers',
            command: 'npx playwright install'
          },
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test:e2e="playwright test" scripts.test:e2e:ui="playwright test --ui"'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['testing', 'e2e', 'playwright', 'browser', 'automation']
      },

      // Testing - Cypress
      {
        name: 'cypress',
        type: 'testing',
        provider: 'cypress',
        version: '13.0.0',
        description: 'Fast, easy and reliable testing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'cypress.config.ts',
            template: `import { defineConfig } from 'cypress';

export default defineConfig({
  e2e: {
    baseUrl: 'http://localhost:3000',
    supportFile: 'cypress/support/e2e.ts',
    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',
    viewportWidth: 1280,
    viewportHeight: 720,
    video: true,
    screenshotOnRunFailure: true,
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
  },
  component: {
    devServer: {
      framework: 'react',
      bundler: 'vite',
    },
    specPattern: 'src/**/*.cy.{js,jsx,ts,tsx}',
  },
});`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'cypress/support/commands.ts',
            template: `// Custom commands
Cypress.Commands.add('login', (email: string, password: string) => {
  cy.visit('/login');
  cy.get('input[name="email"]').type(email);
  cy.get('input[name="password"]').type(password);
  cy.get('button[type="submit"]').click();
});

Cypress.Commands.add('waitForApi', (alias: string) => {
  cy.intercept('GET', '/api/**').as(alias);
  cy.wait(\`@\${alias}\`);
});

// TypeScript support
declare global {
  namespace Cypress {
    interface Chainable {
      login(email: string, password: string): Chainable<void>;
      waitForApi(alias: string): Chainable<void>;
    }
  }
}

export {};`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'cypress/e2e/example.cy.ts',
            template: `describe('Example E2E Tests', () => {
  beforeEach(() => {
    cy.visit('/');
  });

  it('displays homepage', () => {
    cy.contains('h1', 'Welcome');
    cy.title().should('include', 'Home');
  });

  it('navigates to about page', () => {
    cy.contains('About').click();
    cy.url().should('include', '/about');
    cy.contains('h1', 'About Us');
  });

  it('submits contact form', () => {
    cy.visit('/contact');
    
    cy.get('input[name="name"]').type('John Doe');
    cy.get('input[name="email"]').type('john@example.com');
    cy.get('textarea[name="message"]').type('Test message');
    
    cy.get('form').submit();
    
    cy.contains('.success', 'Thank you').should('be.visible');
  });

  it('handles API data', () => {
    cy.intercept('GET', '/api/products', { fixture: 'products.json' }).as('getProducts');
    
    cy.visit('/products');
    cy.wait('@getProducts');
    
    cy.get('.product-card').should('have.length.greaterThan', 0);
  });

  it('tests responsive design', () => {
    // Mobile view
    cy.viewport('iphone-x');
    cy.get('.mobile-menu').should('be.visible');
    
    // Desktop view
    cy.viewport(1920, 1080);
    cy.get('.desktop-menu').should('be.visible');
  });
});`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {
          cypress: '^13.0.0',
          '@cypress/react': '^8.0.0',
          '@cypress/vue': '^6.0.0'
        },
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.cy:open="cypress open" scripts.cy:run="cypress run"'
          },
          {
            type: 'manual',
            description: 'Create cypress/fixtures, cypress/downloads, and cypress/screenshots directories'
          }
        ],
        frameworks: ['next', 'remix', 'react', 'vue', 'nuxt', 'sveltekit'],
        databases: [],
        platforms: ['web'],
        tags: ['testing', 'e2e', 'cypress', 'browser', 'component']
      },

      // Testing - k6
      {
        name: 'k6',
        type: 'testing',
        provider: 'k6',
        version: '0.48.0',
        description: 'Modern load testing tool',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'k6/load-test.js',
            template: `import http from 'k6/http';
import { check, sleep } from 'k6';
import { Rate } from 'k6/metrics';

// Custom metrics
const errorRate = new Rate('errors');

// Test configuration
export const options = {
  stages: [
    { duration: '30s', target: 10 },  // Ramp up to 10 users
    { duration: '1m', target: 10 },   // Stay at 10 users
    { duration: '30s', target: 20 },  // Ramp up to 20 users
    { duration: '1m', target: 20 },   // Stay at 20 users
    { duration: '30s', target: 0 },   // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(95)<500'], // 95% of requests must complete below 500ms
    errors: ['rate<0.1'],             // Error rate must be below 10%
  },
};

// Main test function
export default function () {
  // Test homepage
  const homeRes = http.get(__ENV.BASE_URL || 'http://localhost:3000');
  check(homeRes, {
    'homepage status is 200': (r) => r.status === 200,
    'homepage loads quickly': (r) => r.timings.duration < 200,
  });
  errorRate.add(homeRes.status !== 200);

  sleep(1);

  // Test API endpoint
  const apiRes = http.get(\`\${__ENV.BASE_URL || 'http://localhost:3000'}/api/health\`);
  check(apiRes, {
    'API status is 200': (r) => r.status === 200,
    'API response has data': (r) => JSON.parse(r.body).status === 'ok',
  });
  errorRate.add(apiRes.status !== 200);

  sleep(1);
}

// Setup function (runs once per VU)
export function setup() {
  console.log('Starting load test...');
  return { startTime: new Date().toISOString() };
}

// Teardown function (runs once)
export function teardown(data) {
  console.log(\`Load test completed at \${new Date().toISOString()}\`);
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'k6/stress-test.js',
            template: `import http from 'k6/http';
import { check } from 'k6';

export const options = {
  stages: [
    { duration: '2m', target: 100 },  // Ramp up to 100 users
    { duration: '5m', target: 100 },  // Stay at 100 users
    { duration: '2m', target: 200 },  // Ramp up to 200 users
    { duration: '5m', target: 200 },  // Stay at 200 users
    { duration: '2m', target: 300 },  // Ramp up to 300 users
    { duration: '5m', target: 300 },  // Stay at 300 users
    { duration: '2m', target: 0 },    // Ramp down to 0 users
  ],
  thresholds: {
    http_req_duration: ['p(99)<1500'], // 99% of requests must complete below 1.5s
  },
};

export default function () {
  const responses = http.batch([
    ['GET', \`\${__ENV.BASE_URL}/\`],
    ['GET', \`\${__ENV.BASE_URL}/api/products\`],
    ['GET', \`\${__ENV.BASE_URL}/api/users\`],
  ]);

  responses.forEach((res, index) => {
    check(res, {
      \`request \${index} status is 200\`: (r) => r.status === 200,
    });
  });
}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'k6/spike-test.js',
            template: `import http from 'k6/http';
import { check, sleep } from 'k6';

export const options = {
  stages: [
    { duration: '10s', target: 100 },  // Ramp up to 100 users quickly
    { duration: '1m', target: 100 },   // Stay at 100 users
    { duration: '10s', target: 1000 }, // Spike to 1000 users
    { duration: '3m', target: 1000 },  // Stay at 1000 users
    { duration: '10s', target: 100 },  // Scale down to 100 users
    { duration: '3m', target: 100 },   // Stay at 100 users
    { duration: '10s', target: 0 },    // Ramp down to 0 users
  ],
};

export default function () {
  const res = http.get(__ENV.BASE_URL || 'http://localhost:3000');
  check(res, {
    'status is 200': (r) => r.status === 200,
  });
  sleep(1);
}`,
            priority: 90
          }
        ],
        envVariables: [
          {
            name: 'BASE_URL',
            description: 'Base URL for load testing',
            required: false,
            type: 'url',
            defaultValue: 'http://localhost:3000'
          }
        ],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Install k6 from https://k6.io/docs/getting-started/installation/'
          },
          {
            type: 'command',
            description: 'Add test scripts to package.json',
            command: 'npm pkg set scripts.test:load="k6 run k6/load-test.js" scripts.test:stress="k6 run k6/stress-test.js" scripts.test:spike="k6 run k6/spike-test.js"'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['testing', 'performance', 'load-testing', 'k6', 'stress']
      },

      // DevOps - Docker
      {
        name: 'docker',
        type: 'devops',
        provider: 'docker',
        version: '24.0.0',
        description: 'Containerization platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'Dockerfile',
            template: `# Multi-stage build for optimized image size
FROM node:20-alpine AS deps
# Check https://github.com/nodejs/docker-node/tree/b4117f9333da4138b03a546ec926ef50a31506c3#nodealpine
RUN apk add --no-cache libc6-compat
WORKDIR /app

# Install dependencies based on the preferred package manager
COPY package.json yarn.lock* package-lock.json* pnpm-lock.yaml* ./
RUN \\
  if [ -f yarn.lock ]; then yarn --frozen-lockfile; \\
  elif [ -f package-lock.json ]; then npm ci; \\
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm i --frozen-lockfile; \\
  else echo "Lockfile not found." && exit 1; \\
  fi

# Rebuild the source code only when needed
FROM node:20-alpine AS builder
WORKDIR /app
COPY --from=deps /app/node_modules ./node_modules
COPY . .

# Build the application
RUN \\
  if [ -f yarn.lock ]; then yarn build; \\
  elif [ -f package-lock.json ]; then npm run build; \\
  elif [ -f pnpm-lock.yaml ]; then corepack enable pnpm && pnpm build; \\
  else echo "Lockfile not found." && exit 1; \\
  fi

# Production image, copy all the files and run
FROM node:20-alpine AS runner
WORKDIR /app

ENV NODE_ENV=production

RUN addgroup --system --gid 1001 nodejs
RUN adduser --system --uid 1001 nodejs

# Copy built application
COPY --from=builder /app/dist ./dist
COPY --from=builder /app/package.json ./package.json
COPY --from=builder /app/node_modules ./node_modules

USER nodejs

EXPOSE 3000

ENV PORT=3000

CMD ["node", "dist/index.js"]`,
            priority: 100
          },
          {
            type: 'file-create',
            target: '.dockerignore',
            template: `node_modules
npm-debug.log
.env.local
.env
.DS_Store
*.log
.next
.nuxt
dist
.cache
.vscode
.idea
coverage
.nyc_output
*.test.js
*.spec.js
__tests__
.git
.gitignore
README.md
.editorconfig
.eslintrc
.prettierrc
docker-compose*.yml
Dockerfile
.dockerignore`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'docker-compose.yml',
            template: `version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:password@db:5432/myapp
    depends_on:
      - db
      - redis
    networks:
      - app-network

  db:
    image: postgres:16-alpine
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
      POSTGRES_DB: myapp
    volumes:
      - postgres_data:/var/lib/postgresql/data
    ports:
      - "5432:5432"
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    networks:
      - app-network

volumes:
  postgres_data:

networks:
  app-network:
    driver: bridge`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Build Docker image',
            command: 'docker build -t myapp .'
          },
          {
            type: 'command',
            description: 'Run with docker-compose',
            command: 'docker-compose up -d'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['devops', 'docker', 'container', 'deployment', 'orchestration']
      },

      // DevOps - GitHub Actions
      {
        name: 'github-actions',
        type: 'devops',
        provider: 'github',
        version: '3.0.0',
        description: 'CI/CD workflows for GitHub',
        injectionPoints: [
          {
            type: 'file-create',
            target: '.github/workflows/ci.yml',
            template: `name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  NODE_VERSION: '20'

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run linter
        run: npm run lint

  test:
    name: Test
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20, 21]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js \${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: \${{ matrix.node-version }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Run tests
        run: npm test -- --coverage
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          token: \${{ secrets.CODECOV_TOKEN }}

  build:
    name: Build
    runs-on: ubuntu-latest
    needs: [lint, test]
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Build
        run: npm run build
      
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: dist
          path: dist/`,
            priority: 100
          },
          {
            type: 'file-create',
            target: '.github/workflows/deploy.yml',
            template: `name: Deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch:

env:
  NODE_VERSION: '20'

jobs:
  deploy:
    name: Deploy to Production
    runs-on: ubuntu-latest
    environment: production
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: \${{ env.NODE_VERSION }}
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci --production
      
      - name: Build
        run: npm run build
        env:
          NODE_ENV: production
      
      # Deploy to Vercel
      - name: Deploy to Vercel
        if: \${{ vars.DEPLOY_TARGET == 'vercel' }}
        uses: amondnet/vercel-action@v25
        with:
          vercel-token: \${{ secrets.VERCEL_TOKEN }}
          vercel-org-id: \${{ secrets.VERCEL_ORG_ID }}
          vercel-project-id: \${{ secrets.VERCEL_PROJECT_ID }}
          vercel-args: '--prod'
      
      # Deploy to Docker Registry
      - name: Build and push Docker image
        if: \${{ vars.DEPLOY_TARGET == 'docker' }}
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            \${{ secrets.DOCKER_REGISTRY }}/\${{ github.repository }}:latest
            \${{ secrets.DOCKER_REGISTRY }}/\${{ github.repository }}:\${{ github.sha }}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: '.github/workflows/security.yml',
            template: `name: Security

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 1'  # Weekly on Monday

jobs:
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-results.sarif'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
      
      - name: Run npm audit
        run: npm audit --production
      
      - name: Run Snyk to check for vulnerabilities
        uses: snyk/actions/node@master
        env:
          SNYK_TOKEN: \${{ secrets.SNYK_TOKEN }}`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'manual',
            description: 'Add secrets to GitHub repository settings'
          },
          {
            type: 'manual',
            description: 'Configure branch protection rules'
          }
        ],
        frameworks: ['next', 'remix', 'express', 'fastify', 'hono'],
        databases: [],
        platforms: ['web', 'api'],
        tags: ['devops', 'ci-cd', 'github-actions', 'automation', 'deployment']
      },

      // DevOps - Terraform
      {
        name: 'terraform',
        type: 'devops',
        provider: 'terraform',
        version: '1.6.0',
        description: 'Infrastructure as Code',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'terraform/main.tf',
            template: `terraform {
  required_version = ">= 1.6.0"
  
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = "~> 5.0"
    }
  }
  
  backend "s3" {
    bucket = "terraform-state-bucket"
    key    = "prod/terraform.tfstate"
    region = "us-east-1"
  }
}

provider "aws" {
  region = var.aws_region
}

# VPC Configuration
module "vpc" {
  source = "terraform-aws-modules/vpc/aws"
  version = "5.0.0"
  
  name = "\${var.project_name}-vpc"
  cidr = "10.0.0.0/16"
  
  azs             = data.aws_availability_zones.available.names
  private_subnets = ["10.0.1.0/24", "10.0.2.0/24"]
  public_subnets  = ["10.0.101.0/24", "10.0.102.0/24"]
  
  enable_nat_gateway = true
  enable_vpn_gateway = true
  
  tags = local.common_tags
}

# ECS Cluster
resource "aws_ecs_cluster" "main" {
  name = "\${var.project_name}-cluster"
  
  setting {
    name  = "containerInsights"
    value = "enabled"
  }
  
  tags = local.common_tags
}

# Load Balancer
resource "aws_lb" "main" {
  name               = "\${var.project_name}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = module.vpc.public_subnets
  
  enable_deletion_protection = var.environment == "production"
  
  tags = local.common_tags
}`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'terraform/variables.tf',
            template: `variable "aws_region" {
  description = "AWS region"
  type        = string
  default     = "us-east-1"
}

variable "project_name" {
  description = "Name of the project"
  type        = string
}

variable "environment" {
  description = "Environment name"
  type        = string
  validation {
    condition     = contains(["development", "staging", "production"], var.environment)
    error_message = "Environment must be development, staging, or production."
  }
}

variable "instance_type" {
  description = "EC2 instance type"
  type        = string
  default     = "t3.micro"
}

variable "database_instance_class" {
  description = "RDS instance class"
  type        = string
  default     = "db.t3.micro"
}

variable "min_size" {
  description = "Minimum number of instances"
  type        = number
  default     = 1
}

variable "max_size" {
  description = "Maximum number of instances"
  type        = number
  default     = 3
}`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'terraform/outputs.tf',
            template: `output "vpc_id" {
  description = "ID of the VPC"
  value       = module.vpc.vpc_id
}

output "load_balancer_url" {
  description = "URL of the load balancer"
  value       = aws_lb.main.dns_name
}

output "ecs_cluster_name" {
  description = "Name of the ECS cluster"
  value       = aws_ecs_cluster.main.name
}

output "database_endpoint" {
  description = "RDS instance endpoint"
  value       = aws_db_instance.main.endpoint
  sensitive   = true
}

output "redis_endpoint" {
  description = "ElastiCache Redis endpoint"
  value       = aws_elasticache_cluster.redis.cache_nodes[0].address
  sensitive   = true
}`,
            priority: 90
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Initialize Terraform',
            command: 'cd terraform && terraform init'
          },
          {
            type: 'command',
            description: 'Plan infrastructure changes',
            command: 'cd terraform && terraform plan'
          },
          {
            type: 'manual',
            description: 'Review and apply infrastructure changes with: terraform apply'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['infrastructure'],
        tags: ['devops', 'terraform', 'iac', 'infrastructure', 'aws']
      },

      // DevOps - Kubernetes
      {
        name: 'kubernetes',
        type: 'devops',
        provider: 'kubernetes',
        version: '1.28.0',
        description: 'Container orchestration platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'k8s/deployment.yaml',
            template: `apiVersion: apps/v1
kind: Deployment
metadata:
  name: app-deployment
  labels:
    app: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: myapp
  template:
    metadata:
      labels:
        app: myapp
    spec:
      containers:
      - name: app
        image: myapp:latest
        ports:
        - containerPort: 3000
        env:
        - name: NODE_ENV
          value: "production"
        - name: DATABASE_URL
          valueFrom:
            secretKeyRef:
              name: app-secrets
              key: database-url
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
        livenessProbe:
          httpGet:
            path: /health
            port: 3000
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 3000
          initialDelaySeconds: 5
          periodSeconds: 5`,
            priority: 100
          },
          {
            type: 'file-create',
            target: 'k8s/service.yaml',
            template: `apiVersion: v1
kind: Service
metadata:
  name: app-service
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 80
      targetPort: 3000
  type: LoadBalancer
---
apiVersion: v1
kind: Service
metadata:
  name: app-service-internal
spec:
  selector:
    app: myapp
  ports:
    - protocol: TCP
      port: 3000
      targetPort: 3000
  type: ClusterIP`,
            priority: 95
          },
          {
            type: 'file-create',
            target: 'k8s/ingress.yaml',
            template: `apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-ingress
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
spec:
  tls:
  - hosts:
    - myapp.example.com
    secretName: myapp-tls
  rules:
  - host: myapp.example.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: app-service
            port:
              number: 80`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'k8s/configmap.yaml',
            template: `apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  app.properties: |
    server.port=3000
    app.name=myapp
    app.environment=production`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'k8s/secret.yaml',
            template: `apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
type: Opaque
stringData:
  database-url: "postgresql://user:password@postgres:5432/myapp"
  redis-url: "redis://redis:6379"
  api-key: "your-api-key-here"`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'k8s/hpa.yaml',
            template: `apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: app-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: app-deployment
  minReplicas: 2
  maxReplicas: 10
  metrics:
  - type: Resource
    resource:
      name: cpu
      target:
        type: Utilization
        averageUtilization: 70
  - type: Resource
    resource:
      name: memory
      target:
        type: Utilization
        averageUtilization: 80`,
            priority: 80
          }
        ],
        envVariables: [],
        dependencies: {},
        postInjectionSteps: [
          {
            type: 'command',
            description: 'Apply Kubernetes configurations',
            command: 'kubectl apply -f k8s/'
          },
          {
            type: 'manual',
            description: 'Set up Kubernetes cluster (local with kind/minikube or cloud)'
          },
          {
            type: 'manual',
            description: 'Configure kubectl context'
          }
        ],
        frameworks: [],
        databases: [],
        platforms: ['infrastructure'],
        tags: ['devops', 'kubernetes', 'k8s', 'orchestration', 'container']
      },

      // RBAC (Role-Based Access Control) Services
      {
        name: 'casbin',
        type: 'rbac',
        provider: 'casbin',
        version: '5.0.0',
        description: 'Authorization library that supports access control models',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth/rbac.ts',
            template: `import { newEnforcer } from 'casbin';
import { PrismaAdapter } from 'casbin-prisma-adapter';
import { prisma } from '@/lib/prisma';

// Casbin RBAC configuration
const modelText = \`
[request_definition]
r = sub, obj, act

[policy_definition]
p = sub, obj, act

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub) && r.obj == p.obj && r.act == p.act
\`;

export class RBACService {
  private enforcer: any;

  async initialize() {
    const adapter = await PrismaAdapter.newAdapter(prisma);
    this.enforcer = await newEnforcer(modelText, adapter);
    
    // Initialize default policies
    await this.setupDefaultPolicies();
  }

  private async setupDefaultPolicies() {
    // Admin role can do everything
    await this.enforcer.addPolicy('admin', '*', '*');
    
    // User role permissions
    await this.enforcer.addPolicy('user', 'profile', 'read');
    await this.enforcer.addPolicy('user', 'profile', 'update');
    
    // Guest role permissions
    await this.enforcer.addPolicy('guest', 'public', 'read');
    
    // Role inheritance
    await this.enforcer.addGroupingPolicy('admin', 'user');
    await this.enforcer.addGroupingPolicy('user', 'guest');
  }

  async checkPermission(userId: string, resource: string, action: string): Promise<boolean> {
    return await this.enforcer.enforce(userId, resource, action);
  }

  async assignRole(userId: string, role: string) {
    await this.enforcer.addGroupingPolicy(userId, role);
  }

  async removeRole(userId: string, role: string) {
    await this.enforcer.removeGroupingPolicy(userId, role);
  }

  async getUserRoles(userId: string): Promise<string[]> {
    return await this.enforcer.getRolesForUser(userId);
  }

  async getRolePermissions(role: string): Promise<string[][]> {
    return await this.enforcer.getPermissionsForUser(role);
  }
}

export const rbac = new RBACService();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/rbac.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { rbac } from '@/lib/auth/rbac';
import { getSession } from '@/lib/auth';

export function withRBAC(resource: string, action: string) {
  return async function middleware(req: NextRequest) {
    try {
      const session = await getSession(req);
      
      if (!session?.userId) {
        return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
      }
      
      const hasPermission = await rbac.checkPermission(
        session.userId,
        resource,
        action
      );
      
      if (!hasPermission) {
        return NextResponse.json({ error: 'Forbidden' }, { status: 403 });
      }
      
      return NextResponse.next();
    } catch (error) {
      console.error('RBAC middleware error:', error);
      return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
    }
  };
}
`
          },
          {
            type: 'dependency',
            packages: {
              'casbin': '^5.0.0',
              'casbin-prisma-adapter': '^1.0.0'
            }
          }
        ],
        documentation: 'https://casbin.org/',
        complexity: 'medium',
        tags: ['authorization', 'access-control', 'rbac', 'permissions']
      },
      {
        name: 'opa',
        type: 'rbac',
        provider: 'open-policy-agent',
        version: '0.50.0',
        description: 'Policy-based control for cloud native environments',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/auth/opa.ts',
            template: `import axios from 'axios';

interface OPAInput {
  user: {
    id: string;
    roles: string[];
    attributes?: Record<string, any>;
  };
  resource: {
    type: string;
    id?: string;
    attributes?: Record<string, any>;
  };
  action: string;
}

export class OPAService {
  private baseURL: string;

  constructor(baseURL = process.env.OPA_URL || 'http://localhost:8181') {
    this.baseURL = baseURL;
  }

  async evaluatePolicy(
    policyPath: string,
    input: OPAInput
  ): Promise<boolean> {
    try {
      const response = await axios.post(
        \`\${this.baseURL}/v1/data/\${policyPath}\`,
        { input }
      );
      
      return response.data.result?.allow || false;
    } catch (error) {
      console.error('OPA evaluation error:', error);
      return false;
    }
  }

  async checkPermission(
    userId: string,
    userRoles: string[],
    resource: string,
    action: string,
    resourceAttributes?: Record<string, any>
  ): Promise<boolean> {
    const input: OPAInput = {
      user: {
        id: userId,
        roles: userRoles
      },
      resource: {
        type: resource,
        attributes: resourceAttributes
      },
      action
    };

    return await this.evaluatePolicy('app/rbac', input);
  }

  async uploadPolicy(name: string, policy: string): Promise<void> {
    await axios.put(
      \`\${this.baseURL}/v1/policies/\${name}\`,
      policy,
      {
        headers: {
          'Content-Type': 'text/plain'
        }
      }
    );
  }
}

export const opa = new OPAService();
`
          },
          {
            type: 'file-create',
            target: 'policies/rbac.rego',
            template: `package app.rbac

import future.keywords.contains
import future.keywords.if
import future.keywords.in

# Default deny
default allow := false

# Admin can do everything
allow if {
    "admin" in input.user.roles
}

# User role permissions
allow if {
    "user" in input.user.roles
    input.resource.type == "profile"
    input.action in ["read", "update"]
    input.resource.id == input.user.id
}

# Moderator permissions
allow if {
    "moderator" in input.user.roles
    input.resource.type in ["post", "comment"]
    input.action in ["read", "update", "delete"]
}

# Owner permissions
allow if {
    input.resource.attributes.ownerId == input.user.id
    input.action in ["read", "update", "delete"]
}

# Public read permissions
allow if {
    input.resource.attributes.visibility == "public"
    input.action == "read"
}

# Role hierarchy
user_has_role(user_id, role) if {
    role in input.user.roles
}

user_has_role(user_id, "user") if {
    "admin" in input.user.roles
}

user_has_role(user_id, "guest") if {
    "user" in input.user.roles
}
`
          },
          {
            type: 'file-create',
            target: 'docker-compose.opa.yml',
            template: `version: '3.8'

services:
  opa:
    image: openpolicyagent/opa:latest-envoy
    ports:
      - "8181:8181"
    command:
      - "run"
      - "--server"
      - "--log-level=debug"
      - "/policies"
    volumes:
      - ./policies:/policies
    environment:
      - OPA_LOG_LEVEL=debug
`
          },
          {
            type: 'dependency',
            packages: {
              'axios': '^1.6.0'
            }
          }
        ],
        documentation: 'https://www.openpolicyagent.org/',
        complexity: 'high',
        tags: ['policy', 'authorization', 'rbac', 'cloud-native']
      },
      {
        name: 'custom-rbac',
        type: 'rbac',
        provider: 'custom',
        version: '1.0.0',
        description: 'Custom role-based access control implementation',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/rbac/index.ts',
            template: `import { prisma } from '@/lib/prisma';

export interface Permission {
  id: string;
  name: string;
  resource: string;
  action: string;
  description?: string;
}

export interface Role {
  id: string;
  name: string;
  description?: string;
  permissions: Permission[];
}

export class CustomRBAC {
  async createRole(name: string, description?: string): Promise<Role> {
    return await prisma.role.create({
      data: {
        name,
        description
      },
      include: {
        permissions: true
      }
    });
  }

  async createPermission(
    name: string,
    resource: string,
    action: string,
    description?: string
  ): Promise<Permission> {
    return await prisma.permission.create({
      data: {
        name,
        resource,
        action,
        description
      }
    });
  }

  async assignPermissionToRole(roleId: string, permissionId: string): Promise<void> {
    await prisma.rolePermission.create({
      data: {
        roleId,
        permissionId
      }
    });
  }

  async assignRoleToUser(userId: string, roleId: string): Promise<void> {
    await prisma.userRole.create({
      data: {
        userId,
        roleId
      }
    });
  }

  async getUserPermissions(userId: string): Promise<Permission[]> {
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          include: {
            permissions: {
              include: {
                permission: true
              }
            }
          }
        }
      }
    });

    const permissions = new Map<string, Permission>();
    
    for (const userRole of userRoles) {
      for (const rolePermission of userRole.role.permissions) {
        const perm = rolePermission.permission;
        permissions.set(perm.id, perm);
      }
    }

    return Array.from(permissions.values());
  }

  async checkPermission(
    userId: string,
    resource: string,
    action: string
  ): Promise<boolean> {
    const permissions = await this.getUserPermissions(userId);
    
    return permissions.some(
      p => p.resource === resource && p.action === action
    );
  }

  async checkPermissions(
    userId: string,
    requiredPermissions: Array<{ resource: string; action: string }>
  ): Promise<boolean> {
    const userPermissions = await this.getUserPermissions(userId);
    
    return requiredPermissions.every(required =>
      userPermissions.some(
        p => p.resource === required.resource && p.action === required.action
      )
    );
  }

  async getUserRoles(userId: string): Promise<Role[]> {
    const userRoles = await prisma.userRole.findMany({
      where: { userId },
      include: {
        role: {
          include: {
            permissions: {
              include: {
                permission: true
              }
            }
          }
        }
      }
    });

    return userRoles.map(ur => ({
      ...ur.role,
      permissions: ur.role.permissions.map(rp => rp.permission)
    }));
  }
}

export const rbac = new CustomRBAC();
`
          },
          {
            type: 'file-create',
            target: 'prisma/schema.rbac.prisma',
            template: `// Add these models to your schema.prisma

model Role {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  permissions RolePermission[]
  users       UserRole[]
}

model Permission {
  id          String   @id @default(cuid())
  name        String   @unique
  resource    String
  action      String
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  
  roles RolePermission[]
  
  @@unique([resource, action])
  @@index([resource])
}

model RolePermission {
  roleId       String
  permissionId String
  createdAt    DateTime @default(now())
  
  role       Role       @relation(fields: [roleId], references: [id], onDelete: Cascade)
  permission Permission @relation(fields: [permissionId], references: [id], onDelete: Cascade)
  
  @@id([roleId, permissionId])
}

model UserRole {
  userId    String
  roleId    String
  createdAt DateTime @default(now())
  
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  role Role @relation(fields: [roleId], references: [id], onDelete: Cascade)
  
  @@id([userId, roleId])
  @@index([userId])
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/rbac/seed.ts',
            template: `import { rbac } from './index';

export async function seedRBAC() {
  // Create permissions
  const permissions = [
    // User permissions
    { name: 'user.profile.read', resource: 'user.profile', action: 'read' },
    { name: 'user.profile.update', resource: 'user.profile', action: 'update' },
    { name: 'user.settings.read', resource: 'user.settings', action: 'read' },
    { name: 'user.settings.update', resource: 'user.settings', action: 'update' },
    
    // Admin permissions
    { name: 'admin.users.read', resource: 'admin.users', action: 'read' },
    { name: 'admin.users.create', resource: 'admin.users', action: 'create' },
    { name: 'admin.users.update', resource: 'admin.users', action: 'update' },
    { name: 'admin.users.delete', resource: 'admin.users', action: 'delete' },
    { name: 'admin.roles.manage', resource: 'admin.roles', action: 'manage' },
    
    // Content permissions
    { name: 'content.posts.read', resource: 'content.posts', action: 'read' },
    { name: 'content.posts.create', resource: 'content.posts', action: 'create' },
    { name: 'content.posts.update', resource: 'content.posts', action: 'update' },
    { name: 'content.posts.delete', resource: 'content.posts', action: 'delete' },
  ];

  const createdPermissions = new Map();
  for (const perm of permissions) {
    const created = await rbac.createPermission(
      perm.name,
      perm.resource,
      perm.action
    );
    createdPermissions.set(perm.name, created);
  }

  // Create roles
  const adminRole = await rbac.createRole('admin', 'Full system access');
  const userRole = await rbac.createRole('user', 'Regular user access');
  const guestRole = await rbac.createRole('guest', 'Limited guest access');

  // Assign permissions to roles
  // Admin gets all permissions
  for (const [_, permission] of createdPermissions) {
    await rbac.assignPermissionToRole(adminRole.id, permission.id);
  }

  // User role permissions
  const userPermissions = [
    'user.profile.read',
    'user.profile.update',
    'user.settings.read',
    'user.settings.update',
    'content.posts.read',
    'content.posts.create'
  ];

  for (const permName of userPermissions) {
    const perm = createdPermissions.get(permName);
    if (perm) {
      await rbac.assignPermissionToRole(userRole.id, perm.id);
    }
  }

  // Guest role permissions
  const guestPermissions = [
    'content.posts.read'
  ];

  for (const permName of guestPermissions) {
    const perm = createdPermissions.get(permName);
    if (perm) {
      await rbac.assignPermissionToRole(guestRole.id, perm.id);
    }
  }

  console.log('RBAC seed completed successfully');
}
`
          }
        ],
        documentation: 'Custom RBAC implementation guide',
        complexity: 'medium',
        tags: ['custom', 'rbac', 'permissions', 'roles']
      },

      // Multi-tenancy Services
      {
        name: 'schema-separation',
        type: 'multiTenancy',
        provider: 'schema-separation',
        version: '1.0.0',
        description: 'Multi-tenancy using database schema separation',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/tenancy/schema-manager.ts',
            template: `import { PrismaClient } from '@prisma/client';

export class SchemaManager {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createTenantSchema(tenantId: string): Promise<void> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    try {
      // Create schema
      await this.prisma.$executeRawUnsafe(
        \`CREATE SCHEMA IF NOT EXISTS "\${schemaName}"\`
      );
      
      // Run migrations for the schema
      await this.runMigrationsForSchema(schemaName);
      
      console.log(\`Created schema for tenant: \${tenantId}\`);
    } catch (error) {
      console.error(\`Error creating schema for tenant \${tenantId}:\`, error);
      throw error;
    }
  }

  async deleteTenantSchema(tenantId: string): Promise<void> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    try {
      await this.prisma.$executeRawUnsafe(
        \`DROP SCHEMA IF EXISTS "\${schemaName}" CASCADE\`
      );
      
      console.log(\`Deleted schema for tenant: \${tenantId}\`);
    } catch (error) {
      console.error(\`Error deleting schema for tenant \${tenantId}:\`, error);
      throw error;
    }
  }

  async runMigrationsForSchema(schemaName: string): Promise<void> {
    // Create tables in the tenant schema
    const tables = [
      \`CREATE TABLE IF NOT EXISTS "\${schemaName}"."User" (
        id TEXT PRIMARY KEY,
        email TEXT UNIQUE NOT NULL,
        name TEXT,
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )\`,
      \`CREATE TABLE IF NOT EXISTS "\${schemaName}"."Product" (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        description TEXT,
        price DECIMAL(10,2),
        createdAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updatedAt TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      )\`,
      // Add more tables as needed
    ];

    for (const query of tables) {
      await this.prisma.$executeRawUnsafe(query);
    }
  }

  getTenantSchemaName(tenantId: string): string {
    return \`tenant_\${tenantId.replace(/-/g, '_')}\`;
  }

  async getTenantPrismaClient(tenantId: string): Promise<PrismaClient> {
    const schemaName = this.getTenantSchemaName(tenantId);
    
    // Create a new Prisma client with the tenant's schema
    return new PrismaClient({
      datasources: {
        db: {
          url: \`\${process.env.DATABASE_URL}?schema=\${schemaName}\`
        }
      }
    });
  }
}

export const schemaManager = new SchemaManager();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/tenant.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { schemaManager } from '@/lib/tenancy/schema-manager';

export async function withTenant(req: NextRequest) {
  try {
    // Extract tenant ID from subdomain, header, or JWT
    const tenantId = extractTenantId(req);
    
    if (!tenantId) {
      return NextResponse.json({ error: 'Tenant not found' }, { status: 400 });
    }
    
    // Get tenant-specific Prisma client
    const tenantPrisma = await schemaManager.getTenantPrismaClient(tenantId);
    
    // Attach to request for use in API routes
    (req as any).tenantPrisma = tenantPrisma;
    (req as any).tenantId = tenantId;
    
    return NextResponse.next();
  } catch (error) {
    console.error('Tenant middleware error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

function extractTenantId(req: NextRequest): string | null {
  // Option 1: From subdomain
  const host = req.headers.get('host') || '';
  const subdomain = host.split('.')[0];
  if (subdomain && subdomain !== 'www' && subdomain !== 'app') {
    return subdomain;
  }
  
  // Option 2: From header
  const tenantHeader = req.headers.get('x-tenant-id');
  if (tenantHeader) {
    return tenantHeader;
  }
  
  // Option 3: From JWT token
  // Implementation depends on your auth setup
  
  return null;
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/tenant-service.ts',
            template: `import { PrismaClient } from '@prisma/client';
import { schemaManager } from './schema-manager';

export interface Tenant {
  id: string;
  name: string;
  subdomain: string;
  plan: 'free' | 'starter' | 'pro' | 'enterprise';
  status: 'active' | 'suspended' | 'deleted';
  createdAt: Date;
  updatedAt: Date;
}

export class TenantService {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async createTenant(data: {
    name: string;
    subdomain: string;
    plan?: 'free' | 'starter' | 'pro' | 'enterprise';
  }): Promise<Tenant> {
    // Create tenant record in master database
    const tenant = await this.prisma.tenant.create({
      data: {
        name: data.name,
        subdomain: data.subdomain,
        plan: data.plan || 'free',
        status: 'active'
      }
    });

    // Create tenant schema
    await schemaManager.createTenantSchema(tenant.id);

    return tenant;
  }

  async getTenant(id: string): Promise<Tenant | null> {
    return await this.prisma.tenant.findUnique({
      where: { id }
    });
  }

  async getTenantBySubdomain(subdomain: string): Promise<Tenant | null> {
    return await this.prisma.tenant.findUnique({
      where: { subdomain }
    });
  }

  async updateTenant(id: string, data: Partial<Tenant>): Promise<Tenant> {
    return await this.prisma.tenant.update({
      where: { id },
      data
    });
  }

  async deleteTenant(id: string): Promise<void> {
    // Soft delete tenant
    await this.prisma.tenant.update({
      where: { id },
      data: { status: 'deleted' }
    });

    // Optionally delete schema (consider archiving instead)
    // await schemaManager.deleteTenantSchema(id);
  }

  async listTenants(params?: {
    status?: 'active' | 'suspended' | 'deleted';
    plan?: 'free' | 'starter' | 'pro' | 'enterprise';
  }): Promise<Tenant[]> {
    return await this.prisma.tenant.findMany({
      where: params
    });
  }
}

export const tenantService = new TenantService();
`
          }
        ],
        documentation: 'https://www.postgresql.org/docs/current/ddl-schemas.html',
        complexity: 'high',
        tags: ['multi-tenancy', 'schema-separation', 'postgresql', 'isolation']
      },
      {
        name: 'row-level-security',
        type: 'multiTenancy',
        provider: 'row-level-security',
        version: '1.0.0',
        description: 'Multi-tenancy using row-level security (RLS)',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'prisma/migrations/enable_rls.sql',
            template: `-- Enable Row Level Security on all tenant-scoped tables

-- Users table
ALTER TABLE "User" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "User"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Products table  
ALTER TABLE "Product" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "Product"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Orders table
ALTER TABLE "Order" ENABLE ROW LEVEL SECURITY;

CREATE POLICY tenant_isolation_policy ON "Order"
  FOR ALL
  USING (tenant_id = current_setting('app.current_tenant')::TEXT);

-- Add tenant_id column to all tables
ALTER TABLE "User" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;
ALTER TABLE "Product" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;
ALTER TABLE "Order" ADD COLUMN IF NOT EXISTS tenant_id TEXT NOT NULL;

-- Create indexes for performance
CREATE INDEX IF NOT EXISTS idx_user_tenant_id ON "User"(tenant_id);
CREATE INDEX IF NOT EXISTS idx_product_tenant_id ON "Product"(tenant_id);
CREATE INDEX IF NOT EXISTS idx_order_tenant_id ON "Order"(tenant_id);
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/rls-client.ts',
            template: `import { PrismaClient } from '@prisma/client';

export class RLSPrismaClient {
  private prisma: PrismaClient;

  constructor() {
    this.prisma = new PrismaClient();
  }

  async getClientForTenant(tenantId: string): Promise<PrismaClient> {
    const client = new PrismaClient({
      datasources: {
        db: {
          url: process.env.DATABASE_URL
        }
      }
    });

    // Set the tenant context for RLS
    await client.$executeRawUnsafe(
      \`SET app.current_tenant = '\${tenantId}'\`
    );

    return client;
  }

  async withTenant<T>(
    tenantId: string,
    callback: (prisma: PrismaClient) => Promise<T>
  ): Promise<T> {
    const client = await this.getClientForTenant(tenantId);
    
    try {
      const result = await callback(client);
      return result;
    } finally {
      await client.$disconnect();
    }
  }
}

export const rlsClient = new RLSPrismaClient();

// Extended Prisma Client with tenant context
export function createTenantPrismaClient(tenantId: string) {
  const prisma = new PrismaClient();

  // Middleware to automatically set tenant context
  prisma.$use(async (params, next) => {
    if (params.model && !['Tenant', 'System'].includes(params.model)) {
      // Set tenant context before each query
      await prisma.$executeRawUnsafe(
        \`SET app.current_tenant = '\${tenantId}'\`
      );
    }
    
    return next(params);
  });

  return prisma;
}
`
          },
          {
            type: 'file-create',
            target: 'src/middleware/rls-tenant.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { createTenantPrismaClient } from '@/lib/tenancy/rls-client';
import { getSession } from '@/lib/auth';

export async function withRLSTenant(req: NextRequest) {
  try {
    const session = await getSession(req);
    
    if (!session?.tenantId) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    
    // Create tenant-specific Prisma client with RLS
    const tenantPrisma = createTenantPrismaClient(session.tenantId);
    
    // Attach to request
    (req as any).prisma = tenantPrisma;
    (req as any).tenantId = session.tenantId;
    
    return NextResponse.next();
  } catch (error) {
    console.error('RLS tenant middleware error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/lib/tenancy/rls-helpers.ts',
            template: `// Helper functions for RLS-based multi-tenancy

export async function setTenantContext(
  prisma: any,
  tenantId: string
): Promise<void> {
  await prisma.$executeRawUnsafe(
    \`SET LOCAL app.current_tenant = '\${tenantId}'\`
  );
}

export async function clearTenantContext(prisma: any): Promise<void> {
  await prisma.$executeRawUnsafe(
    \`RESET app.current_tenant\`
  );
}

// Wrapper for transactions with tenant context
export async function tenantTransaction<T>(
  prisma: any,
  tenantId: string,
  callback: (tx: any) => Promise<T>
): Promise<T> {
  return await prisma.$transaction(async (tx: any) => {
    await tx.$executeRawUnsafe(
      \`SET LOCAL app.current_tenant = '\${tenantId}'\`
    );
    
    return await callback(tx);
  });
}

// Automatically add tenant_id to all create/update operations
export function addTenantId<T extends Record<string, any>>(
  data: T,
  tenantId: string
): T & { tenant_id: string } {
  return {
    ...data,
    tenant_id: tenantId
  };
}
`
          }
        ],
        documentation: 'https://www.postgresql.org/docs/current/ddl-rowsecurity.html',
        complexity: 'medium',
        tags: ['multi-tenancy', 'row-level-security', 'rls', 'postgresql']
      },
      {
        name: 'tenant-routing',
        type: 'multiTenancy',
        provider: 'tenant-routing',
        version: '1.0.0',
        description: 'Multi-tenancy using subdomain/path routing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/tenancy/tenant-resolver.ts',
            template: `import { NextRequest } from 'next/server';

export interface TenantInfo {
  id: string;
  identifier: string;
  type: 'subdomain' | 'path' | 'header' | 'custom';
}

export class TenantResolver {
  async resolveTenant(req: NextRequest): Promise<TenantInfo | null> {
    // Try different resolution strategies in order
    const strategies = [
      this.resolveFromSubdomain,
      this.resolveFromPath,
      this.resolveFromHeader,
      this.resolveFromCustomDomain
    ];

    for (const strategy of strategies) {
      const tenant = await strategy.call(this, req);
      if (tenant) {
        return tenant;
      }
    }

    return null;
  }

  private async resolveFromSubdomain(req: NextRequest): Promise<TenantInfo | null> {
    const host = req.headers.get('host') || '';
    const parts = host.split('.');
    
    // Skip if no subdomain or common subdomains
    if (parts.length < 2 || ['www', 'app', 'api'].includes(parts[0])) {
      return null;
    }

    const subdomain = parts[0];
    
    // Verify tenant exists
    const tenant = await this.verifyTenant(subdomain, 'subdomain');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: subdomain,
        type: 'subdomain'
      };
    }

    return null;
  }

  private async resolveFromPath(req: NextRequest): Promise<TenantInfo | null> {
    const pathname = req.nextUrl.pathname;
    const match = pathname.match(/^\\/tenant\\/([^/]+)/);
    
    if (!match) {
      return null;
    }

    const tenantSlug = match[1];
    
    const tenant = await this.verifyTenant(tenantSlug, 'path');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: tenantSlug,
        type: 'path'
      };
    }

    return null;
  }

  private async resolveFromHeader(req: NextRequest): Promise<TenantInfo | null> {
    const tenantId = req.headers.get('x-tenant-id');
    
    if (!tenantId) {
      return null;
    }

    const tenant = await this.verifyTenant(tenantId, 'header');
    if (tenant) {
      return {
        id: tenant.id,
        identifier: tenantId,
        type: 'header'
      };
    }

    return null;
  }

  private async resolveFromCustomDomain(req: NextRequest): Promise<TenantInfo | null> {
    const host = req.headers.get('host') || '';
    
    // Check if this is a custom domain
    const tenant = await this.verifyCustomDomain(host);
    if (tenant) {
      return {
        id: tenant.id,
        identifier: host,
        type: 'custom'
      };
    }

    return null;
  }

  private async verifyTenant(
    identifier: string,
    type: string
  ): Promise<{ id: string } | null> {
    // Implementation depends on your database
    // This is a placeholder
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();
      
      const tenant = await prisma.tenant.findFirst({
        where: {
          OR: [
            { subdomain: identifier },
            { slug: identifier },
            { id: identifier }
          ],
          status: 'active'
        }
      });

      await prisma.$disconnect();
      
      return tenant;
    } catch (error) {
      console.error('Error verifying tenant:', error);
      return null;
    }
  }

  private async verifyCustomDomain(domain: string): Promise<{ id: string } | null> {
    try {
      const { PrismaClient } = await import('@prisma/client');
      const prisma = new PrismaClient();
      
      const customDomain = await prisma.customDomain.findUnique({
        where: { domain },
        include: { tenant: true }
      });

      await prisma.$disconnect();
      
      return customDomain?.tenant || null;
    } catch (error) {
      console.error('Error verifying custom domain:', error);
      return null;
    }
  }
}

export const tenantResolver = new TenantResolver();
`
          },
          {
            type: 'file-create',
            target: 'src/middleware.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { tenantResolver } from '@/lib/tenancy/tenant-resolver';

export async function middleware(req: NextRequest) {
  // Skip tenant resolution for static assets and API routes
  if (
    req.nextUrl.pathname.startsWith('/_next') ||
    req.nextUrl.pathname.startsWith('/api/public') ||
    req.nextUrl.pathname.startsWith('/static')
  ) {
    return NextResponse.next();
  }

  try {
    // Resolve tenant
    const tenant = await tenantResolver.resolveTenant(req);
    
    if (!tenant) {
      // Redirect to main site or show error
      return NextResponse.redirect(new URL('/no-tenant', req.url));
    }

    // Add tenant info to headers for downstream use
    const response = NextResponse.next();
    response.headers.set('x-tenant-id', tenant.id);
    response.headers.set('x-tenant-type', tenant.type);
    
    // For path-based tenancy, you might want to rewrite the URL
    if (tenant.type === 'path') {
      const url = req.nextUrl.clone();
      url.pathname = url.pathname.replace(/^\\/tenant\\/[^/]+/, '');
      return NextResponse.rewrite(url);
    }

    return response;
  } catch (error) {
    console.error('Tenant resolution error:', error);
    return NextResponse.json({ error: 'Internal Server Error' }, { status: 500 });
  }
}

export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useTenant.ts',
            template: `import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';

export interface TenantContext {
  tenantId: string | null;
  tenantName: string | null;
  tenantPlan: 'free' | 'starter' | 'pro' | 'enterprise' | null;
  isLoading: boolean;
}

export function useTenant(): TenantContext {
  const [tenant, setTenant] = useState<TenantContext>({
    tenantId: null,
    tenantName: null,
    tenantPlan: null,
    isLoading: true
  });
  
  const router = useRouter();

  useEffect(() => {
    async function loadTenant() {
      try {
        const response = await fetch('/api/tenant/current');
        const data = await response.json();
        
        setTenant({
          tenantId: data.id,
          tenantName: data.name,
          tenantPlan: data.plan,
          isLoading: false
        });
      } catch (error) {
        console.error('Error loading tenant:', error);
        setTenant(prev => ({ ...prev, isLoading: false }));
      }
    }

    loadTenant();
  }, [router.asPath]);

  return tenant;
}

// React Context for tenant information
import { createContext, useContext, ReactNode } from 'react';

const TenantContext = createContext<TenantContext | undefined>(undefined);

export function TenantProvider({ 
  children,
  tenant 
}: { 
  children: ReactNode;
  tenant: TenantContext;
}) {
  return (
    <TenantContext.Provider value={tenant}>
      {children}
    </TenantContext.Provider>
  );
}

export function useTenantContext(): TenantContext {
  const context = useContext(TenantContext);
  if (context === undefined) {
    throw new Error('useTenantContext must be used within a TenantProvider');
  }
  return context;
}
`
          }
        ],
        documentation: 'Multi-tenancy routing guide',
        complexity: 'medium',
        tags: ['multi-tenancy', 'routing', 'subdomain', 'middleware']
      },

      // Subscription/Billing Services
      {
        name: 'paddle',
        type: 'subscriptions',
        provider: 'paddle',
        version: '2.0.0',
        description: 'Complete payments, tax, and subscription management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/billing/paddle.ts',
            template: `import { Paddle, PaddleProduct, PaddlePrice, PaddleSubscription } from '@paddle/paddle-js';

export class PaddleBilling {
  private paddle: Paddle;

  constructor() {
    this.paddle = new Paddle({
      environment: process.env.PADDLE_ENVIRONMENT as 'sandbox' | 'production' || 'sandbox',
      token: process.env.PADDLE_API_KEY!,
      pwCustomerId: process.env.PADDLE_CUSTOMER_ID
    });
  }

  // Product Management
  async createProduct(data: {
    name: string;
    description?: string;
    taxCategory: string;
    imageUrl?: string;
  }): Promise<PaddleProduct> {
    return await this.paddle.products.create({
      name: data.name,
      description: data.description,
      tax_category: data.taxCategory,
      image_url: data.imageUrl
    });
  }

  async listProducts(): Promise<PaddleProduct[]> {
    const response = await this.paddle.products.list();
    return response.data;
  }

  // Price Management
  async createPrice(data: {
    productId: string;
    amount: string;
    currency: string;
    description?: string;
    billingCycle?: {
      interval: 'day' | 'week' | 'month' | 'year';
      frequency: number;
    };
  }): Promise<PaddlePrice> {
    return await this.paddle.prices.create({
      product_id: data.productId,
      unit_price: {
        amount: data.amount,
        currency_code: data.currency
      },
      description: data.description,
      billing_cycle: data.billingCycle
    });
  }

  // Subscription Management
  async createSubscription(data: {
    customerId: string;
    priceIds: string[];
    currencyCode?: string;
    collectionMode?: 'automatic' | 'manual';
  }): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.create({
      customer_id: data.customerId,
      items: data.priceIds.map(id => ({ price_id: id, quantity: 1 })),
      currency_code: data.currencyCode,
      collection_mode: data.collectionMode
    });
  }

  async getSubscription(subscriptionId: string): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.get(subscriptionId);
  }

  async updateSubscription(
    subscriptionId: string,
    data: {
      priceIds?: string[];
      quantity?: number;
      proration?: 'full_immediately' | 'full_next_billing_period' | 'do_not_bill';
    }
  ): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.update(subscriptionId, {
      items: data.priceIds?.map(id => ({ price_id: id, quantity: data.quantity || 1 })),
      proration: data.proration
    });
  }

  async cancelSubscription(
    subscriptionId: string,
    effectiveFrom?: 'immediately' | 'next_billing_period'
  ): Promise<PaddleSubscription> {
    return await this.paddle.subscriptions.cancel(subscriptionId, {
      effective_from: effectiveFrom
    });
  }

  // Customer Management
  async createCustomer(data: {
    email: string;
    name?: string;
    customData?: Record<string, any>;
  }) {
    return await this.paddle.customers.create({
      email: data.email,
      name: data.name,
      custom_data: data.customData
    });
  }

  // Checkout
  async createCheckoutUrl(data: {
    priceIds: string[];
    customerId?: string;
    successUrl?: string;
    customData?: Record<string, any>;
  }): Promise<string> {
    const transaction = await this.paddle.transactions.create({
      items: data.priceIds.map(id => ({ price_id: id, quantity: 1 })),
      customer_id: data.customerId,
      checkout: {
        url: data.successUrl
      },
      custom_data: data.customData
    });

    return transaction.checkout?.url || '';
  }

  // Webhooks
  async handleWebhook(
    signature: string,
    payload: string,
    secret: string
  ): Promise<any> {
    // Verify webhook signature
    const isValid = this.paddle.webhooks.verify(signature, payload, secret);
    
    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = JSON.parse(payload);
    
    // Handle different event types
    switch (event.event_type) {
      case 'subscription.created':
        return this.handleSubscriptionCreated(event);
      case 'subscription.updated':
        return this.handleSubscriptionUpdated(event);
      case 'subscription.canceled':
        return this.handleSubscriptionCanceled(event);
      case 'transaction.completed':
        return this.handleTransactionCompleted(event);
      default:
        console.log(\`Unhandled event type: \${event.event_type}\`);
    }
  }

  private async handleSubscriptionCreated(event: any) {
    // Implementation for subscription created
    console.log('Subscription created:', event);
  }

  private async handleSubscriptionUpdated(event: any) {
    // Implementation for subscription updated
    console.log('Subscription updated:', event);
  }

  private async handleSubscriptionCanceled(event: any) {
    // Implementation for subscription canceled
    console.log('Subscription canceled:', event);
  }

  private async handleTransactionCompleted(event: any) {
    // Implementation for transaction completed
    console.log('Transaction completed:', event);
  }
}

export const paddleBilling = new PaddleBilling();
`
          },
          {
            type: 'file-create',
            target: 'src/app/api/webhooks/paddle/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { paddleBilling } from '@/lib/billing/paddle';

export async function POST(request: NextRequest) {
  try {
    const signature = request.headers.get('paddle-signature') || '';
    const rawBody = await request.text();
    const secret = process.env.PADDLE_WEBHOOK_SECRET!;

    await paddleBilling.handleWebhook(signature, rawBody, secret);

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Paddle webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 400 }
    );
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/billing/PaddleCheckout.tsx',
            template: `import { useEffect } from 'react';
import Script from 'next/script';

interface PaddleCheckoutProps {
  priceIds: string[];
  customerId?: string;
  successCallback?: () => void;
  closeCallback?: () => void;
}

export function PaddleCheckout({
  priceIds,
  customerId,
  successCallback,
  closeCallback
}: PaddleCheckoutProps) {
  useEffect(() => {
    if (typeof window !== 'undefined' && (window as any).Paddle) {
      const paddle = (window as any).Paddle;
      
      paddle.Setup({
        vendor: parseInt(process.env.NEXT_PUBLIC_PADDLE_VENDOR_ID!),
        environment: process.env.NEXT_PUBLIC_PADDLE_ENVIRONMENT
      });
    }
  }, []);

  const openCheckout = () => {
    if (typeof window !== 'undefined' && (window as any).Paddle) {
      const paddle = (window as any).Paddle;
      
      paddle.Checkout.open({
        items: priceIds.map(id => ({ price_id: id, quantity: 1 })),
        customer: customerId ? { id: customerId } : undefined,
        settings: {
          allowLogout: false,
          successUrl: window.location.origin + '/billing/success',
          theme: 'light'
        },
        customData: {
          userId: customerId
        },
        eventCallback: (event: any) => {
          if (event.name === 'checkout.completed') {
            successCallback?.();
          } else if (event.name === 'checkout.closed') {
            closeCallback?.();
          }
        }
      });
    }
  };

  return (
    <>
      <Script
        src="https://cdn.paddle.com/paddle/v2/paddle.js"
        strategy="afterInteractive"
      />
      <button
        onClick={openCheckout}
        className="px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700"
      >
        Subscribe Now
      </button>
    </>
  );
}
`
          },
          {
            type: 'dependency',
            packages: {
              '@paddle/paddle-js': '^1.0.0'
            }
          }
        ],
        documentation: 'https://developer.paddle.com/',
        complexity: 'medium',
        tags: ['billing', 'subscriptions', 'payments', 'saas', 'paddle']
      },
      {
        name: 'chargebee',
        type: 'subscriptions',
        provider: 'chargebee',
        version: '2.0.0',
        description: 'Subscription billing and revenue management',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/billing/chargebee.ts',
            template: `import { ChargeBee } from 'chargebee-typescript';

export class ChargebeeBilling {
  private chargebee: ChargeBee;

  constructor() {
    this.chargebee = new ChargeBee();
    this.chargebee.configure({
      site: process.env.CHARGEBEE_SITE!,
      api_key: process.env.CHARGEBEE_API_KEY!
    });
  }

  // Customer Management
  async createCustomer(data: {
    id?: string;
    email: string;
    firstName?: string;
    lastName?: string;
    company?: string;
    phone?: string;
    billingAddress?: {
      line1: string;
      city: string;
      state?: string;
      country: string;
      zip?: string;
    };
  }) {
    const result = await this.chargebee.customer.create({
      id: data.id,
      email: data.email,
      first_name: data.firstName,
      last_name: data.lastName,
      company: data.company,
      phone: data.phone,
      billing_address: data.billingAddress
    }).request();

    return result.customer;
  }

  async getCustomer(customerId: string) {
    const result = await this.chargebee.customer.retrieve(customerId).request();
    return result.customer;
  }

  async updateCustomer(customerId: string, data: any) {
    const result = await this.chargebee.customer.update(customerId, data).request();
    return result.customer;
  }

  // Subscription Management
  async createSubscription(data: {
    customerId: string;
    planId: string;
    couponIds?: string[];
    trialEnd?: number;
    billingCycles?: number;
    autoCollection?: 'on' | 'off';
    paymentMethodToken?: string;
  }) {
    const params: any = {
      customer_id: data.customerId,
      plan_id: data.planId,
      coupon_ids: data.couponIds,
      trial_end: data.trialEnd,
      billing_cycles: data.billingCycles,
      auto_collection: data.autoCollection
    };

    if (data.paymentMethodToken) {
      params.payment_method = {
        type: 'card',
        gateway_account_id: process.env.CHARGEBEE_GATEWAY_ACCOUNT_ID,
        reference_id: data.paymentMethodToken
      };
    }

    const result = await this.chargebee.subscription
      .createWithItems(data.customerId, {
        subscription_items: [{
          item_price_id: data.planId,
          quantity: 1
        }],
        ...params
      })
      .request();

    return result.subscription;
  }

  async getSubscription(subscriptionId: string) {
    const result = await this.chargebee.subscription
      .retrieve(subscriptionId)
      .request();
    
    return result.subscription;
  }

  async updateSubscription(subscriptionId: string, data: {
    planId?: string;
    quantity?: number;
    trialEnd?: number;
    prorationDate?: number;
  }) {
    const params: any = {};
    
    if (data.planId) {
      params.plan_id = data.planId;
    }
    
    if (data.quantity) {
      params.quantity = data.quantity;
    }
    
    if (data.trialEnd) {
      params.trial_end = data.trialEnd;
    }
    
    if (data.prorationDate) {
      params.prorate_from = data.prorationDate;
    }

    const result = await this.chargebee.subscription
      .update(subscriptionId, params)
      .request();
    
    return result.subscription;
  }

  async cancelSubscription(
    subscriptionId: string,
    options?: {
      endOfTerm?: boolean;
      creditOptionForCurrentTermCharges?: 'none' | 'prorate' | 'full';
    }
  ) {
    const params: any = {
      end_of_term: options?.endOfTerm ?? true,
      credit_option_for_current_term_charges: options?.creditOptionForCurrentTermCharges ?? 'prorate'
    };

    const result = await this.chargebee.subscription
      .cancel(subscriptionId, params)
      .request();
    
    return result.subscription;
  }

  async reactivateSubscription(subscriptionId: string) {
    const result = await this.chargebee.subscription
      .reactivate(subscriptionId)
      .request();
    
    return result.subscription;
  }

  // Plan Management
  async createPlan(data: {
    id: string;
    name: string;
    invoiceName?: string;
    description?: string;
    price: number;
    currencyCode: string;
    period: number;
    periodUnit: 'day' | 'week' | 'month' | 'year';
    trialPeriod?: number;
    trialPeriodUnit?: 'day' | 'week' | 'month' | 'year';
    setupCost?: number;
  }) {
    const result = await this.chargebee.itemPrice.create({
      id: data.id,
      item_id: data.id,
      name: data.name,
      invoice_name: data.invoiceName,
      description: data.description,
      price: data.price,
      currency_code: data.currencyCode,
      period: data.period,
      period_unit: data.periodUnit,
      trial_period: data.trialPeriod,
      trial_period_unit: data.trialPeriodUnit,
      setup_cost: data.setupCost,
      item_type: 'plan',
      pricing_model: 'per_unit'
    }).request();

    return result.item_price;
  }

  // Hosted Pages
  async createCheckoutNewUrl(data: {
    planId: string;
    customer?: {
      email: string;
      firstName?: string;
      lastName?: string;
    };
    successUrl?: string;
    cancelUrl?: string;
    passThruContent?: string;
  }) {
    const params: any = {
      subscription: {
        plan_id: data.planId
      },
      redirect_url: data.successUrl,
      cancel_url: data.cancelUrl,
      pass_thru_content: data.passThruContent
    };

    if (data.customer) {
      params.customer = {
        email: data.customer.email,
        first_name: data.customer.firstName,
        last_name: data.customer.lastName
      };
    }

    const result = await this.chargebee.hostedPage
      .checkoutNew(params)
      .request();

    return result.hosted_page;
  }

  async createPortalSession(customerId: string, options?: {
    redirectUrl?: string;
    forwardUrl?: string;
  }) {
    const result = await this.chargebee.portalSession.create({
      customer: {
        id: customerId
      },
      redirect_url: options?.redirectUrl,
      forward_url: options?.forwardUrl
    }).request();

    return result.portal_session;
  }

  // Webhook handling
  async handleWebhook(body: any, signature: string): Promise<void> {
    // Verify webhook (implement signature verification)
    const isValid = this.verifyWebhookSignature(body, signature);
    
    if (!isValid) {
      throw new Error('Invalid webhook signature');
    }

    const event = body;

    switch (event.event_type) {
      case 'subscription_created':
        await this.handleSubscriptionCreated(event);
        break;
      case 'subscription_updated':
        await this.handleSubscriptionUpdated(event);
        break;
      case 'subscription_cancelled':
        await this.handleSubscriptionCancelled(event);
        break;
      case 'invoice_generated':
        await this.handleInvoiceGenerated(event);
        break;
      case 'payment_succeeded':
        await this.handlePaymentSucceeded(event);
        break;
      case 'payment_failed':
        await this.handlePaymentFailed(event);
        break;
      default:
        console.log(\`Unhandled event type: \${event.event_type}\`);
    }
  }

  private verifyWebhookSignature(body: any, signature: string): boolean {
    // Implement Chargebee webhook signature verification
    // This is a placeholder - implement actual verification
    return true;
  }

  private async handleSubscriptionCreated(event: any) {
    console.log('Subscription created:', event.content.subscription);
  }

  private async handleSubscriptionUpdated(event: any) {
    console.log('Subscription updated:', event.content.subscription);
  }

  private async handleSubscriptionCancelled(event: any) {
    console.log('Subscription cancelled:', event.content.subscription);
  }

  private async handleInvoiceGenerated(event: any) {
    console.log('Invoice generated:', event.content.invoice);
  }

  private async handlePaymentSucceeded(event: any) {
    console.log('Payment succeeded:', event.content.transaction);
  }

  private async handlePaymentFailed(event: any) {
    console.log('Payment failed:', event.content.transaction);
  }
}

export const chargebeeBilling = new ChargebeeBilling();
`
          },
          {
            type: 'file-create',
            target: 'src/app/api/webhooks/chargebee/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { chargebeeBilling } from '@/lib/billing/chargebee';

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const signature = request.headers.get('x-chargebee-signature') || '';

    await chargebeeBilling.handleWebhook(body, signature);

    return NextResponse.json({ received: true });
  } catch (error) {
    console.error('Chargebee webhook error:', error);
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 400 }
    );
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              'chargebee-typescript': '^2.0.0'
            }
          }
        ],
        documentation: 'https://apidocs.chargebee.com/',
        complexity: 'medium',
        tags: ['billing', 'subscriptions', 'revenue', 'saas', 'chargebee']
      },

      // i18n (Internationalization) Services
      {
        name: 'next-intl',
        type: 'i18n',
        provider: 'next-intl',
        version: '3.0.0',
        description: 'Internationalization for Next.js with full TypeScript support',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n.ts',
            template: `import { getRequestConfig } from 'next-intl/server';
import { notFound } from 'next/navigation';

// Can be imported from a shared config
export const locales = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type Locale = (typeof locales)[number];

export const defaultLocale: Locale = 'en';

export default getRequestConfig(async ({ locale }) => {
  // Validate that the incoming \`locale\` parameter is valid
  if (!locales.includes(locale as any)) notFound();

  return {
    messages: (await import(\`./messages/\${locale}.json\`)).default
  };
});
`
          },
          {
            type: 'file-create',
            target: 'src/middleware.ts',
            template: `import createMiddleware from 'next-intl/middleware';
import { locales, defaultLocale } from './i18n';

export default createMiddleware({
  // A list of all locales that are supported
  locales,

  // Used when no locale matches
  defaultLocale,

  // Always use a locale prefix for routing
  localePrefix: 'as-needed'
});

export const config = {
  // Match only internationalized pathnames
  matcher: ['/', '/(en|nb|nn|fr|es|de|ar)/:path*']
};
`
          },
          {
            type: 'file-create',
            target: 'src/app/[locale]/layout.tsx',
            template: `import { NextIntlClientProvider } from 'next-intl';
import { getMessages } from 'next-intl/server';
import { notFound } from 'next/navigation';
import { locales } from '@/i18n';

export function generateStaticParams() {
  return locales.map((locale) => ({ locale }));
}

export default async function LocaleLayout({
  children,
  params: { locale }
}: {
  children: React.ReactNode;
  params: { locale: string };
}) {
  // Ensure that the incoming locale is valid
  if (!locales.includes(locale as any)) {
    notFound();
  }

  // Providing all messages to the client
  const messages = await getMessages();

  return (
    <html lang={locale} dir={locale === 'ar' ? 'rtl' : 'ltr'}>
      <body>
        <NextIntlClientProvider messages={messages}>
          {children}
        </NextIntlClientProvider>
      </body>
    </html>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/app/[locale]/page.tsx',
            template: `import { useTranslations } from 'next-intl';
import { Link } from 'next-intl/link';

export default function HomePage() {
  const t = useTranslations('HomePage');

  return (
    <div>
      <h1>{t('title')}</h1>
      <p>{t('description')}</p>
      
      <Link href="/about" locale="en">
        {t('navigation.about')}
      </Link>
    </div>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/messages/en.json',
            template: `{
  "HomePage": {
    "title": "Welcome to our application",
    "description": "This is a multilingual Next.js application",
    "navigation": {
      "about": "About Us",
      "contact": "Contact",
      "services": "Services"
    }
  },
  "common": {
    "loading": "Loading...",
    "error": "An error occurred",
    "retry": "Try again",
    "save": "Save",
    "cancel": "Cancel",
    "delete": "Delete",
    "edit": "Edit",
    "create": "Create",
    "search": "Search",
    "filter": "Filter",
    "sort": "Sort",
    "close": "Close"
  },
  "auth": {
    "login": "Log in",
    "logout": "Log out",
    "signup": "Sign up",
    "forgotPassword": "Forgot password?",
    "resetPassword": "Reset password"
  },
  "errors": {
    "required": "This field is required",
    "email": "Please enter a valid email",
    "minLength": "Must be at least {min} characters",
    "maxLength": "Must be no more than {max} characters"
  }
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/LocaleSwitcher.tsx',
            template: `'use client';

import { useLocale, useTranslations } from 'next-intl';
import { usePathname, useRouter } from 'next-intl/client';
import { locales } from '@/i18n';

export function LocaleSwitcher() {
  const t = useTranslations('LocaleSwitcher');
  const locale = useLocale();
  const router = useRouter();
  const pathname = usePathname();

  const handleChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newLocale = event.target.value;
    router.replace(pathname, { locale: newLocale });
  };

  return (
    <select
      value={locale}
      onChange={handleChange}
      className="px-3 py-2 border rounded-md"
      aria-label={t('label')}
    >
      {locales.map((loc) => (
        <option key={loc} value={loc}>
          {t('locale', { locale: loc })}
        </option>
      ))}
    </select>
  );
}
`
          },
          {
            type: 'dependency',
            packages: {
              'next-intl': '^3.0.0'
            }
          }
        ],
        documentation: 'https://next-intl-docs.vercel.app/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'nextjs', 'localization', 'typescript']
      },
      {
        name: 'react-i18next',
        type: 'i18n',
        provider: 'react-i18next',
        version: '13.0.0',
        description: 'Powerful internationalization framework for React',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n/config.ts',
            template: `import i18n from 'i18next';
import { initReactI18next } from 'react-i18next';
import LanguageDetector from 'i18next-browser-languagedetector';
import Backend from 'i18next-http-backend';

export const supportedLanguages = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type SupportedLanguage = typeof supportedLanguages[number];

i18n
  // Load translation using http backend
  .use(Backend)
  // Detect user language
  .use(LanguageDetector)
  // Pass the i18n instance to react-i18next
  .use(initReactI18next)
  // Initialize i18next
  .init({
    fallbackLng: 'en',
    debug: process.env.NODE_ENV === 'development',
    
    interpolation: {
      escapeValue: false // React already escapes values
    },

    backend: {
      loadPath: '/locales/{{lng}}/{{ns}}.json'
    },

    detection: {
      order: ['querystring', 'cookie', 'localStorage', 'navigator', 'htmlTag'],
      caches: ['localStorage', 'cookie']
    },

    supportedLngs: supportedLanguages,
    
    ns: ['common', 'auth', 'errors', 'navigation'],
    defaultNS: 'common',

    react: {
      useSuspense: false
    }
  });

export default i18n;
`
          },
          {
            type: 'file-create',
            target: 'src/app/layout.tsx',
            template: `import { I18nextProvider } from 'react-i18next';
import i18n from '@/i18n/config';

export default function RootLayout({
  children
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang={i18n.language} dir={i18n.language === 'ar' ? 'rtl' : 'ltr'}>
      <body>
        <I18nextProvider i18n={i18n}>
          {children}
        </I18nextProvider>
      </body>
    </html>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useTranslation.ts',
            template: `import { useTranslation as useI18nTranslation } from 'react-i18next';

export function useTranslation(namespace?: string) {
  return useI18nTranslation(namespace);
}

// Type-safe translation hook
export function useTypedTranslation<T extends Record<string, any>>(namespace: string) {
  const { t, ...rest } = useI18nTranslation(namespace);
  
  return {
    t: (key: keyof T, options?: any) => t(key as string, options),
    ...rest
  };
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/LanguageSwitcher.tsx',
            template: `import { useTranslation } from 'react-i18next';
import { supportedLanguages } from '@/i18n/config';

export function LanguageSwitcher() {
  const { i18n, t } = useTranslation();

  const handleLanguageChange = (event: React.ChangeEvent<HTMLSelectElement>) => {
    const newLang = event.target.value;
    i18n.changeLanguage(newLang);
    
    // Update HTML attributes
    document.documentElement.lang = newLang;
    document.documentElement.dir = newLang === 'ar' ? 'rtl' : 'ltr';
  };

  return (
    <select
      value={i18n.language}
      onChange={handleLanguageChange}
      className="px-3 py-2 border rounded-md"
      aria-label={t('languageSwitcher.label')}
    >
      {supportedLanguages.map((lang) => (
        <option key={lang} value={lang}>
          {t(\`languageSwitcher.languages.\${lang}\`)}
        </option>
      ))}
    </select>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'public/locales/en/common.json',
            template: `{
  "welcome": "Welcome",
  "loading": "Loading...",
  "error": "An error occurred",
  "retry": "Try again",
  "save": "Save",
  "cancel": "Cancel",
  "delete": "Delete",
  "edit": "Edit",
  "create": "Create",
  "search": "Search",
  "filter": "Filter",
  "sort": "Sort",
  "close": "Close",
  "languageSwitcher": {
    "label": "Select language",
    "languages": {
      "en": "English",
      "nb": "Norsk bokmål",
      "nn": "Norsk nynorsk",
      "fr": "Français",
      "es": "Español",
      "de": "Deutsch",
      "ar": "العربية"
    }
  }
}
`
          },
          {
            type: 'dependency',
            packages: {
              'react-i18next': '^13.0.0',
              'i18next': '^23.0.0',
              'i18next-browser-languagedetector': '^7.0.0',
              'i18next-http-backend': '^2.0.0'
            }
          }
        ],
        documentation: 'https://react.i18next.com/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'react', 'localization', 'translation']
      },
      {
        name: 'formatjs',
        type: 'i18n',
        provider: 'formatjs',
        version: '6.0.0',
        description: 'Internationalization libraries by FormatJS (React Intl)',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/i18n/provider.tsx',
            template: `import { IntlProvider } from 'react-intl';
import { ReactNode, useState, useEffect } from 'react';

type Messages = Record<string, string>;

interface I18nProviderProps {
  children: ReactNode;
  defaultLocale?: string;
}

export const supportedLocales = ['en', 'nb', 'nn', 'fr', 'es', 'de', 'ar'] as const;
export type SupportedLocale = typeof supportedLocales[number];

async function loadMessages(locale: string): Promise<Messages> {
  try {
    const messages = await import(\`../messages/\${locale}.json\`);
    return messages.default;
  } catch (error) {
    console.error(\`Failed to load messages for locale \${locale}\`, error);
    // Fallback to English
    const messages = await import('../messages/en.json');
    return messages.default;
  }
}

export function I18nProvider({ 
  children, 
  defaultLocale = 'en' 
}: I18nProviderProps) {
  const [locale, setLocale] = useState<string>(defaultLocale);
  const [messages, setMessages] = useState<Messages>({});
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    loadMessages(locale).then((loadedMessages) => {
      setMessages(loadedMessages);
      setLoading(false);
    });
  }, [locale]);

  if (loading) {
    return <div>Loading translations...</div>;
  }

  return (
    <IntlProvider
      locale={locale}
      messages={messages}
      onError={(err) => {
        if (err.code === 'MISSING_TRANSLATION') {
          console.warn(\`Missing translation: \${err.message}\`);
          return;
        }
        throw err;
      }}
    >
      {children}
    </IntlProvider>
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/hooks/useIntl.ts',
            template: `import { useIntl as useReactIntl, MessageDescriptor } from 'react-intl';

export function useIntl() {
  const intl = useReactIntl();

  // Enhanced formatMessage with type safety
  const formatMessage = (
    descriptor: MessageDescriptor,
    values?: Record<string, any>
  ) => {
    return intl.formatMessage(descriptor, values);
  };

  // Format number with currency
  const formatCurrency = (amount: number, currency = 'USD') => {
    return intl.formatNumber(amount, {
      style: 'currency',
      currency
    });
  };

  // Format relative time
  const formatRelativeTime = (date: Date | number, unit?: any) => {
    const rtf = new Intl.RelativeTimeFormat(intl.locale, {
      numeric: 'auto'
    });
    
    // Calculate relative time
    const now = new Date().getTime();
    const then = typeof date === 'number' ? date : date.getTime();
    const diff = then - now;
    
    const seconds = Math.floor(diff / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (Math.abs(days) > 0) return rtf.format(days, 'day');
    if (Math.abs(hours) > 0) return rtf.format(hours, 'hour');
    if (Math.abs(minutes) > 0) return rtf.format(minutes, 'minute');
    return rtf.format(seconds, 'second');
  };

  return {
    ...intl,
    formatMessage,
    formatCurrency,
    formatRelativeTime
  };
}
`
          },
          {
            type: 'file-create',
            target: 'src/components/FormattedMessage.tsx',
            template: `import { FormattedMessage as IntlFormattedMessage } from 'react-intl';

interface FormattedMessageProps {
  id: string;
  defaultMessage?: string;
  values?: Record<string, any>;
  description?: string;
}

export function FormattedMessage({
  id,
  defaultMessage,
  values,
  description
}: FormattedMessageProps) {
  return (
    <IntlFormattedMessage
      id={id}
      defaultMessage={defaultMessage}
      values={values}
      description={description}
    />
  );
}

// Type-safe message component
export function TypedMessage<T extends Record<string, any>>({
  id,
  values
}: {
  id: keyof T;
  values?: Record<string, any>;
}) {
  return (
    <IntlFormattedMessage
      id={id as string}
      values={values}
    />
  );
}
`
          },
          {
            type: 'file-create',
            target: 'src/messages/en.json',
            template: `{
  "app.title": "Welcome to our application",
  "app.description": "This is a multilingual application using FormatJS",
  "nav.home": "Home",
  "nav.about": "About",
  "nav.contact": "Contact",
  "nav.services": "Services",
  "common.loading": "Loading...",
  "common.error": "An error occurred",
  "common.retry": "Try again",
  "common.save": "Save",
  "common.cancel": "Cancel",
  "common.delete": "Delete",
  "common.edit": "Edit",
  "common.create": "Create",
  "common.search": "Search",
  "common.filter": "Filter",
  "common.sort": "Sort",
  "common.close": "Close",
  "auth.login": "Log in",
  "auth.logout": "Log out",
  "auth.signup": "Sign up",
  "auth.forgotPassword": "Forgot password?",
  "auth.resetPassword": "Reset password",
  "validation.required": "This field is required",
  "validation.email": "Please enter a valid email",
  "validation.minLength": "Must be at least {min} characters",
  "validation.maxLength": "Must be no more than {max} characters",
  "format.currency": "{amount, number, currency}",
  "format.date": "{date, date, long}",
  "format.time": "{time, time, short}",
  "format.relative": "{date, relative}"
}
`
          },
          {
            type: 'dependency',
            packages: {
              'react-intl': '^6.0.0',
              '@formatjs/intl-relativetimeformat': '^11.0.0',
              '@formatjs/intl-locale': '^3.0.0',
              '@formatjs/intl-pluralrules': '^5.0.0',
              '@formatjs/intl-numberformat': '^8.0.0'
            }
          }
        ],
        documentation: 'https://formatjs.io/',
        complexity: 'medium',
        tags: ['i18n', 'internationalization', 'react', 'formatjs', 'intl']
      },
      {
        name: 'crowdin',
        type: 'i18n',
        provider: 'crowdin',
        version: '1.0.0',
        description: 'Localization management platform integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'crowdin.yml',
            template: `project_id: '${CROWDIN_PROJECT_ID}'
api_token: '${CROWDIN_API_TOKEN}'

preserve_hierarchy: true

files:
  - source: /src/messages/en.json
    translation: /src/messages/%locale%.json
    
  - source: /public/locales/en/**/*.json
    translation: /public/locales/%locale%/**/%original_file_name%

  - source: /content/en/**/*.md
    translation: /content/%locale%/**/%original_file_name%

export_languages: ['nb', 'nn', 'fr', 'es', 'de', 'ar']

bundles:
  - mode: bundle
    name: app-translations
    format: react-intl
    sources:
      - /src/messages/en.json
    
  - mode: bundle
    name: content-translations
    format: markdown
    sources:
      - /content/en/**/*.md
`
          },
          {
            type: 'file-create',
            target: 'scripts/crowdin-sync.ts',
            template: `import crowdin, { SourceFilesModel } from '@crowdin/crowdin-api-client';
import * as fs from 'fs';
import * as path from 'path';

const { uploadStorageApi, sourceFilesApi, translationsApi } = new crowdin({
  token: process.env.CROWDIN_API_TOKEN!
});

const projectId = parseInt(process.env.CROWDIN_PROJECT_ID!);

interface SyncOptions {
  upload?: boolean;
  download?: boolean;
  languages?: string[];
}

export async function syncTranslations(options: SyncOptions = {}) {
  const { upload = true, download = true, languages = [] } = options;

  if (upload) {
    await uploadSourceFiles();
  }

  if (download) {
    await downloadTranslations(languages);
  }
}

async function uploadSourceFiles() {
  console.log('Uploading source files to Crowdin...');

  const sourceFiles = [
    'src/messages/en.json',
    'public/locales/en/common.json',
    'public/locales/en/auth.json',
    'public/locales/en/errors.json'
  ];

  for (const filePath of sourceFiles) {
    try {
      const fileContent = fs.readFileSync(filePath, 'utf8');
      const fileName = path.basename(filePath);
      
      // Upload file to storage
      const storageResponse = await uploadStorageApi.addStorage(
        fileName,
        fileContent
      );
      
      // Update or create source file
      try {
        await sourceFilesApi.updateOrCreateFile(projectId, {
          storageId: storageResponse.data.id,
          name: fileName,
          directoryId: undefined, // root directory
          title: fileName,
          type: 'json'
        });
        
        console.log(\`✓ Uploaded \${filePath}\`);
      } catch (error) {
        console.error(\`✗ Failed to upload \${filePath}:\`, error);
      }
    } catch (error) {
      console.error(\`✗ Failed to read \${filePath}:\`, error);
    }
  }
}

async function downloadTranslations(languages: string[]) {
  console.log('Downloading translations from Crowdin...');

  const targetLanguages = languages.length > 0 
    ? languages 
    : ['nb', 'nn', 'fr', 'es', 'de', 'ar'];

  for (const language of targetLanguages) {
    try {
      // Build translations
      const buildResponse = await translationsApi.buildProjectTranslation(
        projectId,
        { targetLanguageId: language }
      );
      
      // Wait for build to complete
      await waitForBuild(buildResponse.data.id);
      
      // Download translations
      const downloadUrl = await translationsApi.downloadTranslations(
        projectId,
        buildResponse.data.id
      );
      
      // Download and extract files
      await downloadAndExtractTranslations(downloadUrl.data.url, language);
      
      console.log(\`✓ Downloaded translations for \${language}\`);
    } catch (error) {
      console.error(\`✗ Failed to download \${language}:\`, error);
    }
  }
}

async function waitForBuild(buildId: number) {
  // Implementation to wait for build completion
  // Poll the build status until it's finished
}

async function downloadAndExtractTranslations(url: string, language: string) {
  // Implementation to download ZIP and extract translations
  // Place files in appropriate directories
}

// CLI usage
if (require.main === module) {
  const args = process.argv.slice(2);
  const options: SyncOptions = {};
  
  if (args.includes('--upload-only')) {
    options.download = false;
  }
  
  if (args.includes('--download-only')) {
    options.upload = false;
  }
  
  const langIndex = args.indexOf('--languages');
  if (langIndex !== -1 && args[langIndex + 1]) {
    options.languages = args[langIndex + 1].split(',');
  }
  
  syncTranslations(options)
    .then(() => console.log('✓ Sync complete'))
    .catch((error) => console.error('✗ Sync failed:', error));
}
`
          },
          {
            type: 'file-create',
            target: '.github/workflows/crowdin.yml',
            template: `name: Crowdin Sync

on:
  push:
    branches: [main]
    paths:
      - 'src/messages/en.json'
      - 'public/locales/en/**/*.json'
      - 'content/en/**/*.md'
  
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  
  workflow_dispatch:
    inputs:
      sync_type:
        description: 'Sync type'
        required: true
        default: 'both'
        type: choice
        options:
          - upload
          - download
          - both

jobs:
  sync:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      
      - name: Install dependencies
        run: npm ci
      
      - name: Upload sources
        if: \${{ github.event_name == 'push' || github.event.inputs.sync_type == 'upload' || github.event.inputs.sync_type == 'both' }}
        run: npm run crowdin:upload
        env:
          CROWDIN_PROJECT_ID: \${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: \${{ secrets.CROWDIN_API_TOKEN }}
      
      - name: Download translations
        if: \${{ github.event_name == 'schedule' || github.event.inputs.sync_type == 'download' || github.event.inputs.sync_type == 'both' }}
        run: npm run crowdin:download
        env:
          CROWDIN_PROJECT_ID: \${{ secrets.CROWDIN_PROJECT_ID }}
          CROWDIN_API_TOKEN: \${{ secrets.CROWDIN_API_TOKEN }}
      
      - name: Create Pull Request
        if: \${{ github.event_name == 'schedule' || github.event.inputs.sync_type == 'download' || github.event.inputs.sync_type == 'both' }}
        uses: peter-evans/create-pull-request@v5
        with:
          token: \${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore: update translations from Crowdin'
          title: '🌍 Update translations from Crowdin'
          body: |
            This PR updates translations from Crowdin.
            
            - Updated language files
            - Synchronized with latest translations
            
            Please review the changes before merging.
          branch: crowdin-translations
          delete-branch: true
`
          },
          {
            type: 'dependency',
            packages: {
              '@crowdin/crowdin-api-client': '^1.0.0'
            },
            devDependencies: {
              '@crowdin/cli': '^3.0.0'
            }
          }
        ],
        documentation: 'https://developer.crowdin.com/',
        complexity: 'high',
        tags: ['i18n', 'localization', 'translation-management', 'crowdin', 'ci-cd']
      },

      // AI Integration Services
      {
        name: 'openai',
        type: 'ai',
        provider: 'openai',
        version: '4.0.0',
        description: 'OpenAI API integration for GPT, DALL-E, and embeddings',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/openai.ts',
            template: `import OpenAI from 'openai';

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export interface ChatCompletionOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  systemPrompt?: string;
}

export async function generateChatCompletion(
  messages: OpenAI.Chat.ChatCompletionMessageParam[],
  options: ChatCompletionOptions = {}
) {
  const {
    model = 'gpt-4-turbo-preview',
    temperature = 0.7,
    maxTokens = 1000,
    systemPrompt
  } = options;

  const allMessages: OpenAI.Chat.ChatCompletionMessageParam[] = [];
  
  if (systemPrompt) {
    allMessages.push({ role: 'system', content: systemPrompt });
  }
  
  allMessages.push(...messages);

  const completion = await openai.chat.completions.create({
    model,
    messages: allMessages,
    temperature,
    max_tokens: maxTokens,
  });

  return completion.choices[0]?.message?.content || '';
}

export async function generateEmbedding(text: string) {
  const response = await openai.embeddings.create({
    model: 'text-embedding-3-small',
    input: text,
  });

  return response.data[0].embedding;
}

export async function generateImage(prompt: string, options?: {
  size?: '1024x1024' | '1792x1024' | '1024x1792';
  quality?: 'standard' | 'hd';
  n?: number;
}) {
  const response = await openai.images.generate({
    model: 'dall-e-3',
    prompt,
    size: options?.size || '1024x1024',
    quality: options?.quality || 'standard',
    n: options?.n || 1,
  });

  return response.data;
}

export async function streamChatCompletion(
  messages: OpenAI.Chat.ChatCompletionMessageParam[],
  options: ChatCompletionOptions = {}
) {
  const {
    model = 'gpt-4-turbo-preview',
    temperature = 0.7,
    maxTokens = 1000,
  } = options;

  const stream = await openai.chat.completions.create({
    model,
    messages,
    temperature,
    max_tokens: maxTokens,
    stream: true,
  });

  return stream;
}

export { openai };`
          },
          {
            type: 'dependency',
            packages: {
              'openai': '^4.0.0'
            }
          }
        ],
        envVariables: [
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key',
            required: true,
            type: 'string',
            sensitive: true
          }
        ],
        documentation: 'https://platform.openai.com/docs',
        complexity: 'low',
        tags: ['ai', 'openai', 'gpt', 'chatgpt', 'dalle', 'embeddings']
      },

      {
        name: 'anthropic',
        type: 'ai',
        provider: 'anthropic',
        version: '0.20.0',
        description: 'Anthropic Claude API integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/anthropic.ts',
            template: `import Anthropic from '@anthropic-ai/sdk';

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

export interface ClaudeCompletionOptions {
  model?: string;
  maxTokens?: number;
  temperature?: number;
  systemPrompt?: string;
}

export async function generateClaudeCompletion(
  prompt: string,
  options: ClaudeCompletionOptions = {}
) {
  const {
    model = 'claude-3-opus-20240229',
    maxTokens = 1000,
    temperature = 0.7,
    systemPrompt
  } = options;

  const message = await anthropic.messages.create({
    model,
    max_tokens: maxTokens,
    temperature,
    system: systemPrompt,
    messages: [
      {
        role: 'user',
        content: prompt
      }
    ]
  });

  return message.content[0].type === 'text' ? message.content[0].text : '';
}

export async function streamClaudeCompletion(
  prompt: string,
  options: ClaudeCompletionOptions = {}
) {
  const {
    model = 'claude-3-opus-20240229',
    maxTokens = 1000,
    temperature = 0.7,
    systemPrompt
  } = options;

  const stream = await anthropic.messages.create({
    model,
    max_tokens: maxTokens,
    temperature,
    system: systemPrompt,
    messages: [
      {
        role: 'user',
        content: prompt
      }
    ],
    stream: true
  });

  return stream;
}

export async function generateClaudeChat(
  messages: Array<{ role: 'user' | 'assistant'; content: string }>,
  options: ClaudeCompletionOptions = {}
) {
  const {
    model = 'claude-3-opus-20240229',
    maxTokens = 1000,
    temperature = 0.7,
    systemPrompt
  } = options;

  const response = await anthropic.messages.create({
    model,
    max_tokens: maxTokens,
    temperature,
    system: systemPrompt,
    messages
  });

  return response.content[0].type === 'text' ? response.content[0].text : '';
}

export { anthropic };`
          },
          {
            type: 'dependency',
            packages: {
              '@anthropic-ai/sdk': '^0.20.0'
            }
          }
        ],
        envVariables: [
          {
            name: 'ANTHROPIC_API_KEY',
            description: 'Anthropic API key',
            required: true,
            type: 'string',
            sensitive: true
          }
        ],
        documentation: 'https://docs.anthropic.com/',
        complexity: 'low',
        tags: ['ai', 'anthropic', 'claude', 'llm']
      },

      // AI Agent Services
      {
        name: 'langchain',
        type: 'ai-agent',
        provider: 'langchain',
        version: '0.1.0',
        description: 'Build applications with LLMs through composability',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/langchain.ts',
            template: `import { ChatOpenAI } from '@langchain/openai';
import { ChatAnthropic } from '@langchain/anthropic';
import { 
  ChatPromptTemplate, 
  SystemMessagePromptTemplate,
  HumanMessagePromptTemplate,
  MessagesPlaceholder
} from '@langchain/core/prompts';
import { ConversationChain } from 'langchain/chains';
import { BufferMemory, ConversationSummaryMemory } from 'langchain/memory';
import { createRetrievalChain } from 'langchain/chains/retrieval';
import { createStuffDocumentsChain } from 'langchain/chains/combine_documents';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { OpenAIEmbeddings } from '@langchain/openai';
import { Document } from '@langchain/core/documents';

// Initialize LLMs
export const openAIChat = new ChatOpenAI({
  modelName: 'gpt-4-turbo-preview',
  temperature: 0.7,
  openAIApiKey: process.env.OPENAI_API_KEY,
});

export const anthropicChat = new ChatAnthropic({
  modelName: 'claude-3-opus-20240229',
  temperature: 0.7,
  anthropicApiKey: process.env.ANTHROPIC_API_KEY,
});

// Create a conversational chain with memory
export async function createConversationChain(systemPrompt?: string) {
  const memory = new BufferMemory({
    returnMessages: true,
    memoryKey: 'chat_history',
  });

  const prompt = ChatPromptTemplate.fromMessages([
    SystemMessagePromptTemplate.fromTemplate(
      systemPrompt || 'You are a helpful AI assistant.'
    ),
    new MessagesPlaceholder('chat_history'),
    HumanMessagePromptTemplate.fromTemplate('{input}'),
  ]);

  const chain = new ConversationChain({
    llm: openAIChat,
    prompt,
    memory,
  });

  return chain;
}

// Create a RAG (Retrieval Augmented Generation) chain
export async function createRAGChain(documents: string[]) {
  // Split documents into chunks
  const textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: 1000,
    chunkOverlap: 200,
  });

  const docs = documents.map(
    (pageContent) => new Document({ pageContent })
  );

  const splitDocs = await textSplitter.splitDocuments(docs);

  // Create vector store
  const vectorStore = await MemoryVectorStore.fromDocuments(
    splitDocs,
    new OpenAIEmbeddings({ openAIApiKey: process.env.OPENAI_API_KEY })
  );

  // Create retriever
  const retriever = vectorStore.asRetriever();

  // Create prompt
  const prompt = ChatPromptTemplate.fromTemplate(\`
    Answer the question based only on the following context:
    {context}

    Question: {input}
  \`);

  // Create chains
  const documentChain = await createStuffDocumentsChain({
    llm: openAIChat,
    prompt,
  });

  const retrievalChain = await createRetrievalChain({
    combineDocsChain: documentChain,
    retriever,
  });

  return retrievalChain;
}

// Create an agent with tools
export async function createAgent() {
  const { initializeAgentExecutorWithOptions } = await import(
    'langchain/agents'
  );
  const { Calculator } = await import('langchain/tools/calculator');
  const { WebBrowser } = await import('langchain/tools/webbrowser');
  const { OpenAIEmbeddings } = await import('@langchain/openai');

  const tools = [
    new Calculator(),
    new WebBrowser({ 
      model: openAIChat, 
      embeddings: new OpenAIEmbeddings() 
    }),
  ];

  const agent = await initializeAgentExecutorWithOptions(tools, openAIChat, {
    agentType: 'openai-functions',
    verbose: true,
  });

  return agent;
}

// Function calling example
export async function callFunction(
  query: string,
  functions: any[]
) {
  const llm = new ChatOpenAI({
    modelName: 'gpt-4-turbo-preview',
    temperature: 0,
  }).bind({
    functions,
  });

  const result = await llm.invoke(query);
  return result;
}`
          },
          {
            type: 'dependency',
            packages: {
              'langchain': '^0.1.0',
              '@langchain/openai': '^0.0.10',
              '@langchain/anthropic': '^0.1.0',
              '@langchain/core': '^0.1.0',
              '@langchain/community': '^0.0.10'
            }
          }
        ],
        envVariables: [
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key for LangChain',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'ANTHROPIC_API_KEY',
            description: 'Anthropic API key for LangChain',
            required: false,
            type: 'string',
            sensitive: true
          }
        ],
        documentation: 'https://js.langchain.com/',
        complexity: 'high',
        tags: ['ai', 'langchain', 'agents', 'rag', 'chains', 'llm']
      },

      {
        name: 'agentic-rag',
        type: 'ai-agent',
        provider: 'custom',
        version: '1.0.0',
        description: 'Agentic RAG system with autonomous document processing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/agentic-rag.ts',
            template: `import { ChatOpenAI } from '@langchain/openai';
import { 
  ChatPromptTemplate,
  SystemMessagePromptTemplate,
  HumanMessagePromptTemplate 
} from '@langchain/core/prompts';
import { createRetrievalChain } from 'langchain/chains/retrieval';
import { createStuffDocumentsChain } from 'langchain/chains/combine_documents';
import { RecursiveCharacterTextSplitter } from 'langchain/text_splitter';
import { MemoryVectorStore } from 'langchain/vectorstores/memory';
import { OpenAIEmbeddings } from '@langchain/openai';
import { Document } from '@langchain/core/documents';
import { BaseMessage } from '@langchain/core/messages';

interface AgenticRAGOptions {
  systemPrompt?: string;
  chunkSize?: number;
  chunkOverlap?: number;
  maxIterations?: number;
  temperature?: number;
}

export class AgenticRAG {
  private llm: ChatOpenAI;
  private embeddings: OpenAIEmbeddings;
  private vectorStore: MemoryVectorStore | null = null;
  private options: AgenticRAGOptions;
  private conversationHistory: BaseMessage[] = [];

  constructor(options: AgenticRAGOptions = {}) {
    this.options = {
      systemPrompt: 'You are an intelligent RAG agent that can answer questions and perform analysis on documents.',
      chunkSize: 1000,
      chunkOverlap: 200,
      maxIterations: 5,
      temperature: 0.7,
      ...options
    };

    this.llm = new ChatOpenAI({
      modelName: 'gpt-4-turbo-preview',
      temperature: this.options.temperature,
      openAIApiKey: process.env.OPENAI_API_KEY,
    });

    this.embeddings = new OpenAIEmbeddings({
      openAIApiKey: process.env.OPENAI_API_KEY,
    });
  }

  async ingestDocuments(documents: string[] | Document[]) {
    const docs = documents.map(doc => 
      typeof doc === 'string' 
        ? new Document({ pageContent: doc })
        : doc
    );

    const textSplitter = new RecursiveCharacterTextSplitter({
      chunkSize: this.options.chunkSize,
      chunkOverlap: this.options.chunkOverlap,
    });

    const splitDocs = await textSplitter.splitDocuments(docs);

    this.vectorStore = await MemoryVectorStore.fromDocuments(
      splitDocs,
      this.embeddings
    );

    return splitDocs.length;
  }

  async query(question: string, context?: any) {
    if (!this.vectorStore) {
      throw new Error('No documents ingested. Call ingestDocuments first.');
    }

    // Agent loop for iterative refinement
    let currentQuery = question;
    let iterations = 0;
    let finalAnswer = '';

    while (iterations < this.options.maxIterations!) {
      // Retrieve relevant documents
      const retriever = this.vectorStore.asRetriever({
        k: 5,
        searchType: 'similarity',
      });

      const relevantDocs = await retriever.getRelevantDocuments(currentQuery);

      // Check if we need more information
      const needsMoreInfoPrompt = ChatPromptTemplate.fromTemplate(\`
        Based on the following context and question, determine if you need more information to answer accurately.
        
        Context: {context}
        Question: {question}
        
        Respond with either:
        1. "SUFFICIENT" if you have enough information
        2. "NEED_MORE: <specific question to search for>" if you need more information
      \`);

      const needsMoreInfoChain = await createStuffDocumentsChain({
        llm: this.llm,
        prompt: needsMoreInfoPrompt,
      });

      const checkResult = await needsMoreInfoChain.invoke({
        context: relevantDocs,
        question: currentQuery,
      });

      if (checkResult.startsWith('SUFFICIENT')) {
        // Generate final answer
        const answerPrompt = ChatPromptTemplate.fromTemplate(\`
          ${this.options.systemPrompt}
          
          Use the following context to answer the question comprehensively:
          {context}
          
          Question: {question}
          
          Provide a detailed, well-structured answer.
        \`);

        const answerChain = await createStuffDocumentsChain({
          llm: this.llm,
          prompt: answerPrompt,
        });

        finalAnswer = await answerChain.invoke({
          context: relevantDocs,
          question: currentQuery,
        });

        break;
      } else if (checkResult.startsWith('NEED_MORE:')) {
        // Extract the new query
        currentQuery = checkResult.split('NEED_MORE:')[1].trim();
        iterations++;
      } else {
        // Fallback
        break;
      }
    }

    // Store in conversation history
    this.conversationHistory.push({
      content: question,
      name: 'user',
    } as BaseMessage);
    
    this.conversationHistory.push({
      content: finalAnswer,
      name: 'assistant',
    } as BaseMessage);

    return {
      answer: finalAnswer,
      sources: await this.vectorStore.similaritySearch(question, 3),
      iterations: iterations + 1,
    };
  }

  async analyzeDocument(instruction: string) {
    if (!this.vectorStore) {
      throw new Error('No documents ingested. Call ingestDocuments first.');
    }

    const analysisPrompt = ChatPromptTemplate.fromTemplate(\`
      You are an expert document analyst. Analyze the provided documents according to the following instruction:
      
      Instruction: {instruction}
      
      Documents:
      {context}
      
      Provide a comprehensive analysis with:
      1. Key findings
      2. Important patterns or trends
      3. Recommendations
      4. Areas requiring further investigation
    \`);

    const retriever = this.vectorStore.asRetriever({
      k: 10,
      searchType: 'similarity',
    });

    const analysisChain = await createRetrievalChain({
      combineDocsChain: await createStuffDocumentsChain({
        llm: this.llm,
        prompt: analysisPrompt,
      }),
      retriever,
    });

    const result = await analysisChain.invoke({
      input: instruction,
    });

    return result;
  }

  async generateReport(topic: string) {
    if (!this.vectorStore) {
      throw new Error('No documents ingested. Call ingestDocuments first.');
    }

    const reportPrompt = ChatPromptTemplate.fromTemplate(\`
      Generate a comprehensive report on the following topic based on the available documents:
      
      Topic: {topic}
      
      Context:
      {context}
      
      The report should include:
      1. Executive Summary
      2. Detailed Findings
      3. Data Analysis
      4. Conclusions
      5. Recommendations
      
      Format the report professionally with clear sections and bullet points where appropriate.
    \`);

    const retriever = this.vectorStore.asRetriever({
      k: 15,
      searchType: 'mmr', // Maximum marginal relevance for diversity
    });

    const reportChain = await createRetrievalChain({
      combineDocsChain: await createStuffDocumentsChain({
        llm: this.llm,
        prompt: reportPrompt,
      }),
      retriever,
    });

    const report = await reportChain.invoke({
      input: topic,
    });

    return report;
  }

  getConversationHistory() {
    return this.conversationHistory;
  }

  clearConversationHistory() {
    this.conversationHistory = [];
  }
}

// Factory function
export function createAgenticRAG(options?: AgenticRAGOptions) {
  return new AgenticRAG(options);
}`
          },
          {
            type: 'dependency',
            packages: {
              'langchain': '^0.1.0',
              '@langchain/openai': '^0.0.10',
              '@langchain/core': '^0.1.0'
            }
          }
        ],
        documentation: 'https://js.langchain.com/docs/use_cases/question_answering',
        complexity: 'high',
        tags: ['ai', 'rag', 'agents', 'document-analysis', 'autonomous']
      },

      // AI Chatbot Services
      {
        name: 'vercel-ai',
        type: 'ai-chatbot',
        provider: 'vercel',
        version: '3.0.0',
        description: 'Build AI-powered apps with React, Svelte, Vue, and Solid',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/app/api/chat/route.ts',
            template: `import { OpenAIStream, StreamingTextResponse } from 'ai';
import { Configuration, OpenAIApi } from 'openai-edge';

const config = new Configuration({
  apiKey: process.env.OPENAI_API_KEY,
});
const openai = new OpenAIApi(config);

export const runtime = 'edge';

export async function POST(req: Request) {
  const { messages } = await req.json();

  const response = await openai.createChatCompletion({
    model: 'gpt-4-turbo-preview',
    stream: true,
    messages,
    temperature: 0.7,
    max_tokens: 1000,
  });

  const stream = OpenAIStream(response, {
    onStart: async () => {
      // This callback is called when the stream starts
      console.log('Stream started');
    },
    onToken: async (token) => {
      // This callback is called for each token in the stream
      console.log(token);
    },
    onCompletion: async (completion) => {
      // This callback is called when the stream completes
      console.log('Completion:', completion);
    },
  });

  return new StreamingTextResponse(stream);
}`
          },
          {
            type: 'file-create',
            target: 'src/components/Chat.tsx',
            template: `'use client';

import { useChat } from 'ai/react';
import { useState } from 'react';

export default function Chat() {
  const { messages, input, handleInputChange, handleSubmit, isLoading } = useChat();
  const [error, setError] = useState<string | null>(null);

  const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    setError(null);
    try {
      await handleSubmit(e);
    } catch (err) {
      setError('Failed to send message. Please try again.');
    }
  };

  return (
    <div className="flex flex-col h-screen max-w-4xl mx-auto p-4">
      <div className="flex-1 overflow-y-auto space-y-4 mb-4">
        {messages.map((message) => (
          <div
            key={message.id}
            className={\`flex \${
              message.role === 'user' ? 'justify-end' : 'justify-start'
            }\`}
          >
            <div
              className={\`max-w-xs lg:max-w-md px-4 py-2 rounded-lg \${
                message.role === 'user'
                  ? 'bg-blue-500 text-white'
                  : 'bg-gray-200 text-gray-900'
              }\`}
            >
              <p className="text-sm">{message.content}</p>
            </div>
          </div>
        ))}
        {isLoading && (
          <div className="flex justify-start">
            <div className="bg-gray-200 text-gray-900 px-4 py-2 rounded-lg">
              <p className="text-sm">Thinking...</p>
            </div>
          </div>
        )}
        {error && (
          <div className="text-red-500 text-center text-sm">{error}</div>
        )}
      </div>

      <form onSubmit={onSubmit} className="flex gap-2">
        <input
          type="text"
          value={input}
          onChange={handleInputChange}
          placeholder="Type your message..."
          className="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
          disabled={isLoading}
        />
        <button
          type="submit"
          disabled={isLoading}
          className="px-6 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Send
        </button>
      </form>
    </div>
  );
}`
          },
          {
            type: 'dependency',
            packages: {
              'ai': '^3.0.0',
              'openai-edge': '^1.0.0'
            }
          }
        ],
        documentation: 'https://sdk.vercel.ai/docs',
        complexity: 'low',
        tags: ['ai', 'chatbot', 'streaming', 'vercel', 'react', 'nextjs']
      },

      // WhatsApp Agent
      {
        name: 'whatsapp-agent',
        type: 'ai-agent',
        provider: 'twilio',
        version: '1.0.0',
        description: 'AI-powered WhatsApp agent using Twilio and LLMs',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/agents/whatsapp-agent.ts',
            template: `import twilio from 'twilio';
import { ChatOpenAI } from '@langchain/openai';
import { ConversationChain } from 'langchain/chains';
import { BufferMemory } from 'langchain/memory';
import { 
  ChatPromptTemplate,
  SystemMessagePromptTemplate,
  HumanMessagePromptTemplate,
  MessagesPlaceholder
} from '@langchain/core/prompts';

const accountSid = process.env.TWILIO_ACCOUNT_SID;
const authToken = process.env.TWILIO_AUTH_TOKEN;
const twilioClient = twilio(accountSid, authToken);

// Store conversation memories per phone number
const conversationMemories = new Map<string, BufferMemory>();

export class WhatsAppAgent {
  private llm: ChatOpenAI;
  private systemPrompt: string;

  constructor(systemPrompt?: string) {
    this.llm = new ChatOpenAI({
      modelName: 'gpt-4-turbo-preview',
      temperature: 0.7,
      openAIApiKey: process.env.OPENAI_API_KEY,
    });

    this.systemPrompt = systemPrompt || \`You are a helpful WhatsApp assistant. 
You provide concise, friendly responses suitable for mobile messaging. 
Keep your responses brief but informative.\`;
  }

  private getOrCreateMemory(phoneNumber: string): BufferMemory {
    if (!conversationMemories.has(phoneNumber)) {
      conversationMemories.set(phoneNumber, new BufferMemory({
        returnMessages: true,
        memoryKey: 'chat_history',
      }));
    }
    return conversationMemories.get(phoneNumber)!;
  }

  async processMessage(from: string, body: string) {
    try {
      const memory = this.getOrCreateMemory(from);

      const prompt = ChatPromptTemplate.fromMessages([
        SystemMessagePromptTemplate.fromTemplate(this.systemPrompt),
        new MessagesPlaceholder('chat_history'),
        HumanMessagePromptTemplate.fromTemplate('{input}'),
      ]);

      const chain = new ConversationChain({
        llm: this.llm,
        prompt,
        memory,
      });

      // Process special commands
      if (body.toLowerCase() === '/clear') {
        conversationMemories.delete(from);
        return 'Conversation history cleared. How can I help you?';
      }

      if (body.toLowerCase() === '/help') {
        return \`Available commands:
/clear - Clear conversation history
/help - Show this help message

Just send me any message and I'll help you!\`;
      }

      // Generate response
      const response = await chain.call({ input: body });
      
      // Truncate if too long for WhatsApp
      const maxLength = 1600; // WhatsApp message limit
      if (response.response.length > maxLength) {
        return response.response.substring(0, maxLength - 3) + '...';
      }

      return response.response;
    } catch (error) {
      console.error('Error processing WhatsApp message:', error);
      return 'Sorry, I encountered an error. Please try again.';
    }
  }

  async sendMessage(to: string, body: string) {
    try {
      const message = await twilioClient.messages.create({
        body,
        from: \`whatsapp:\${process.env.TWILIO_WHATSAPP_NUMBER}\`,
        to: \`whatsapp:\${to}\`,
      });
      return message.sid;
    } catch (error) {
      console.error('Error sending WhatsApp message:', error);
      throw error;
    }
  }

  async sendMediaMessage(to: string, body: string, mediaUrl: string) {
    try {
      const message = await twilioClient.messages.create({
        body,
        from: \`whatsapp:\${process.env.TWILIO_WHATSAPP_NUMBER}\`,
        to: \`whatsapp:\${to}\`,
        mediaUrl: [mediaUrl],
      });
      return message.sid;
    } catch (error) {
      console.error('Error sending WhatsApp media message:', error);
      throw error;
    }
  }

  clearUserHistory(phoneNumber: string) {
    conversationMemories.delete(phoneNumber);
  }

  getAllActiveConversations() {
    return Array.from(conversationMemories.keys());
  }
}`
          },
          {
            type: 'file-create',
            target: 'src/app/api/whatsapp/webhook/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { WhatsAppAgent } from '@/lib/agents/whatsapp-agent';

const agent = new WhatsAppAgent();

export async function POST(req: NextRequest) {
  try {
    const formData = await req.formData();
    const body = formData.get('Body') as string;
    const from = formData.get('From') as string;
    const to = formData.get('To') as string;
    const mediaUrl = formData.get('MediaUrl0') as string | null;

    // Remove 'whatsapp:' prefix
    const phoneNumber = from.replace('whatsapp:', '');

    console.log(\`Received WhatsApp message from \${phoneNumber}: \${body}\`);

    // Process message with AI agent
    let response: string;

    if (mediaUrl) {
      // Handle media messages
      response = 'I received your media. Currently, I can only process text messages. How can I help you with text?';
    } else {
      response = await agent.processMessage(phoneNumber, body);
    }

    // Send response back via Twilio
    await agent.sendMessage(phoneNumber, response);

    // Return empty response to Twilio
    return new Response('', { status: 200 });
  } catch (error) {
    console.error('WhatsApp webhook error:', error);
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// Twilio webhook verification
export async function GET(req: NextRequest) {
  return new Response('WhatsApp webhook is active', { status: 200 });
}`
          },
          {
            type: 'dependency',
            packages: {
              'twilio': '^4.0.0',
              'langchain': '^0.1.0',
              '@langchain/openai': '^0.0.10'
            }
          }
        ],
        envVariables: [
          {
            name: 'TWILIO_ACCOUNT_SID',
            description: 'Twilio Account SID',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'TWILIO_AUTH_TOKEN',
            description: 'Twilio Auth Token',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'TWILIO_WHATSAPP_NUMBER',
            description: 'Twilio WhatsApp number',
            required: true,
            type: 'string'
          },
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key',
            required: true,
            type: 'string',
            sensitive: true
          }
        ],
        documentation: 'https://www.twilio.com/docs/whatsapp',
        complexity: 'medium',
        tags: ['ai', 'whatsapp', 'agent', 'twilio', 'chatbot', 'messaging']
      },

      // Outlook Agent
      {
        name: 'outlook-agent',
        type: 'ai-agent',
        provider: 'microsoft',
        version: '1.0.0',
        description: 'AI-powered Outlook email agent with Microsoft Graph',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/agents/outlook-agent.ts',
            template: `import { Client } from '@microsoft/microsoft-graph-client';
import { ChatOpenAI } from '@langchain/openai';
import { 
  ChatPromptTemplate,
  SystemMessagePromptTemplate,
  HumanMessagePromptTemplate 
} from '@langchain/core/prompts';
import { z } from 'zod';
import { StructuredOutputParser } from 'langchain/output_parsers';

// Email action schema
const EmailActionSchema = z.object({
  action: z.enum(['reply', 'forward', 'archive', 'flag', 'categorize', 'ignore']),
  replyContent: z.string().optional(),
  forwardTo: z.array(z.string()).optional(),
  category: z.string().optional(),
  priority: z.enum(['high', 'normal', 'low']).optional(),
  summary: z.string(),
});

type EmailAction = z.infer<typeof EmailActionSchema>;

export class OutlookAgent {
  private graphClient: Client;
  private llm: ChatOpenAI;
  private parser: StructuredOutputParser<EmailAction>;

  constructor(accessToken: string) {
    this.graphClient = Client.init({
      authProvider: (done) => {
        done(null, accessToken);
      },
    });

    this.llm = new ChatOpenAI({
      modelName: 'gpt-4-turbo-preview',
      temperature: 0.3,
      openAIApiKey: process.env.OPENAI_API_KEY,
    });

    this.parser = StructuredOutputParser.fromZodSchema(EmailActionSchema);
  }

  async processInbox(maxEmails: number = 10) {
    try {
      // Fetch unread emails
      const messages = await this.graphClient
        .api('/me/mailFolders/inbox/messages')
        .filter('isRead eq false')
        .top(maxEmails)
        .select('id,subject,bodyPreview,from,toRecipients,importance,receivedDateTime')
        .get();

      const results = [];

      for (const message of messages.value) {
        const action = await this.analyzeEmail(message);
        await this.executeAction(message, action);
        results.push({ messageId: message.id, action });
      }

      return results;
    } catch (error) {
      console.error('Error processing inbox:', error);
      throw error;
    }
  }

  private async analyzeEmail(message: any): Promise<EmailAction> {
    const prompt = ChatPromptTemplate.fromMessages([
      SystemMessagePromptTemplate.fromTemplate(\`
        You are an intelligent email assistant. Analyze the email and determine the best action.
        Consider the sender, subject, content, and importance.
        
        {format_instructions}
      \`),
      HumanMessagePromptTemplate.fromTemplate(\`
        Email Details:
        From: {from}
        Subject: {subject}
        Content: {content}
        Importance: {importance}
        
        Determine the appropriate action and provide a brief summary.
      \`),
    ]);

    const chain = prompt.pipe(this.llm).pipe(this.parser);

    const result = await chain.invoke({
      from: message.from.emailAddress.address,
      subject: message.subject,
      content: message.bodyPreview,
      importance: message.importance,
      format_instructions: this.parser.getFormatInstructions(),
    });

    return result;
  }

  private async executeAction(message: any, action: EmailAction) {
    switch (action.action) {
      case 'reply':
        if (action.replyContent) {
          await this.replyToEmail(message.id, action.replyContent);
        }
        break;
      
      case 'forward':
        if (action.forwardTo && action.forwardTo.length > 0) {
          await this.forwardEmail(message.id, action.forwardTo, action.summary);
        }
        break;
      
      case 'archive':
        await this.archiveEmail(message.id);
        break;
      
      case 'flag':
        await this.flagEmail(message.id, action.priority || 'normal');
        break;
      
      case 'categorize':
        if (action.category) {
          await this.categorizeEmail(message.id, action.category);
        }
        break;
      
      case 'ignore':
        // Mark as read but take no other action
        await this.markAsRead(message.id);
        break;
    }
  }

  async replyToEmail(messageId: string, content: string) {
    const reply = {
      message: {
        body: {
          contentType: 'HTML',
          content: content,
        },
      },
    };

    await this.graphClient
      .api(\`/me/messages/\${messageId}/reply\`)
      .post(reply);
  }

  async forwardEmail(messageId: string, recipients: string[], comment: string) {
    const forward = {
      comment: comment,
      toRecipients: recipients.map(email => ({
        emailAddress: { address: email },
      })),
    };

    await this.graphClient
      .api(\`/me/messages/\${messageId}/forward\`)
      .post(forward);
  }

  async archiveEmail(messageId: string) {
    const archiveFolder = await this.graphClient
      .api('/me/mailFolders')
      .filter("displayName eq 'Archive'")
      .get();

    if (archiveFolder.value.length > 0) {
      await this.graphClient
        .api(\`/me/messages/\${messageId}/move\`)
        .post({ destinationId: archiveFolder.value[0].id });
    }
  }

  async flagEmail(messageId: string, importance: string) {
    await this.graphClient
      .api(\`/me/messages/\${messageId}\`)
      .patch({
        flag: { flagStatus: 'flagged' },
        importance: importance,
      });
  }

  async categorizeEmail(messageId: string, category: string) {
    await this.graphClient
      .api(\`/me/messages/\${messageId}\`)
      .patch({
        categories: [category],
      });
  }

  async markAsRead(messageId: string) {
    await this.graphClient
      .api(\`/me/messages/\${messageId}\`)
      .patch({ isRead: true });
  }

  async generateEmailDraft(context: string, recipient: string) {
    const prompt = ChatPromptTemplate.fromTemplate(\`
      Write a professional email based on the following context:
      
      Context: {context}
      Recipient: {recipient}
      
      Generate a complete email with:
      1. Appropriate subject line
      2. Professional greeting
      3. Clear and concise body
      4. Professional closing
      
      Format as JSON with 'subject' and 'body' fields.
    \`);

    const response = await this.llm.invoke(
      await prompt.format({ context, recipient })
    );

    const emailData = JSON.parse(response.content as string);

    const draft = {
      subject: emailData.subject,
      body: {
        contentType: 'HTML',
        content: emailData.body,
      },
      toRecipients: [
        {
          emailAddress: { address: recipient },
        },
      ],
    };

    const createdDraft = await this.graphClient
      .api('/me/messages')
      .post(draft);

    return createdDraft;
  }

  async searchEmails(query: string, maxResults: number = 10) {
    const searchPrompt = ChatPromptTemplate.fromTemplate(\`
      Convert this natural language query into a Microsoft Graph search filter:
      Query: {query}
      
      Return only the filter string, no explanation.
    \`);

    const filterString = await this.llm.invoke(
      await searchPrompt.format({ query })
    );

    const results = await this.graphClient
      .api('/me/messages')
      .filter(filterString.content as string)
      .top(maxResults)
      .get();

    return results.value;
  }
}`
          },
          {
            type: 'file-create',
            target: 'src/app/api/outlook/process/route.ts',
            template: `import { NextRequest, NextResponse } from 'next/server';
import { OutlookAgent } from '@/lib/agents/outlook-agent';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

export async function POST(req: NextRequest) {
  try {
    const session = await getServerSession(authOptions);
    
    if (!session?.accessToken) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const { maxEmails = 10 } = await req.json();
    
    const agent = new OutlookAgent(session.accessToken);
    const results = await agent.processInbox(maxEmails);

    return NextResponse.json({
      processed: results.length,
      results,
    });
  } catch (error) {
    console.error('Outlook processing error:', error);
    return NextResponse.json(
      { error: 'Failed to process emails' },
      { status: 500 }
    );
  }
}`
          },
          {
            type: 'dependency',
            packages: {
              '@microsoft/microsoft-graph-client': '^3.0.0',
              'langchain': '^0.1.0',
              '@langchain/openai': '^0.0.10',
              'zod': '^3.22.0'
            }
          }
        ],
        envVariables: [
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'AZURE_AD_CLIENT_ID',
            description: 'Azure AD application client ID',
            required: true,
            type: 'string'
          },
          {
            name: 'AZURE_AD_CLIENT_SECRET',
            description: 'Azure AD application client secret',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'AZURE_AD_TENANT_ID',
            description: 'Azure AD tenant ID',
            required: true,
            type: 'string'
          }
        ],
        documentation: 'https://docs.microsoft.com/graph/',
        complexity: 'high',
        tags: ['ai', 'outlook', 'email', 'agent', 'microsoft', 'graph']
      },

      // Vector Databases for AI
      {
        name: 'pinecone',
        type: 'vector-db',
        provider: 'pinecone',
        version: '2.0.0',
        description: 'Vector database for AI applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/pinecone.ts',
            template: `import { Pinecone } from '@pinecone-database/pinecone';
import { OpenAIEmbeddings } from '@langchain/openai';

const pinecone = new Pinecone({
  apiKey: process.env.PINECONE_API_KEY!,
});

export interface VectorDocument {
  id: string;
  content: string;
  metadata?: Record<string, any>;
}

export class PineconeVectorStore {
  private index: any;
  private embeddings: OpenAIEmbeddings;
  private namespace: string;

  constructor(indexName: string, namespace: string = 'default') {
    this.index = pinecone.index(indexName);
    this.namespace = namespace;
    this.embeddings = new OpenAIEmbeddings({
      openAIApiKey: process.env.OPENAI_API_KEY,
    });
  }

  async upsertDocuments(documents: VectorDocument[]) {
    const vectors = await Promise.all(
      documents.map(async (doc) => {
        const embedding = await this.embeddings.embedQuery(doc.content);
        return {
          id: doc.id,
          values: embedding,
          metadata: {
            ...doc.metadata,
            content: doc.content,
          },
        };
      })
    );

    await this.index.namespace(this.namespace).upsert(vectors);
    return vectors.length;
  }

  async similaritySearch(
    query: string,
    k: number = 5,
    filter?: Record<string, any>
  ) {
    const queryEmbedding = await this.embeddings.embedQuery(query);
    
    const results = await this.index.namespace(this.namespace).query({
      vector: queryEmbedding,
      topK: k,
      includeMetadata: true,
      filter,
    });

    return results.matches.map((match: any) => ({
      id: match.id,
      score: match.score,
      content: match.metadata.content,
      metadata: match.metadata,
    }));
  }

  async deleteDocuments(ids: string[]) {
    await this.index.namespace(this.namespace).deleteMany(ids);
  }

  async deleteAll() {
    await this.index.namespace(this.namespace).deleteAll();
  }
}

export async function createIndex(
  name: string,
  dimension: number = 1536,
  metric: 'cosine' | 'euclidean' | 'dotproduct' = 'cosine'
) {
  await pinecone.createIndex({
    name,
    dimension,
    metric,
    spec: {
      serverless: {
        cloud: 'aws',
        region: 'us-east-1',
      },
    },
  });
}

export { pinecone };`
          },
          {
            type: 'dependency',
            packages: {
              '@pinecone-database/pinecone': '^2.0.0',
              '@langchain/openai': '^0.0.10'
            }
          }
        ],
        envVariables: [
          {
            name: 'PINECONE_API_KEY',
            description: 'Pinecone API key',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key for embeddings',
            required: true,
            type: 'string',
            sensitive: true
          }
        ],
        documentation: 'https://docs.pinecone.io/',
        complexity: 'medium',
        tags: ['ai', 'vector-database', 'embeddings', 'similarity-search']
      },

      // AI Observability
      {
        name: 'langfuse',
        type: 'ai-observability',
        provider: 'langfuse',
        version: '3.0.0',
        description: 'Open source LLM engineering platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/langfuse.ts',
            template: `import { Langfuse } from 'langfuse';
import { CallbackHandler } from 'langfuse-langchain';

// Initialize Langfuse client
export const langfuse = new Langfuse({
  publicKey: process.env.LANGFUSE_PUBLIC_KEY!,
  secretKey: process.env.LANGFUSE_SECRET_KEY!,
  baseUrl: process.env.LANGFUSE_BASE_URL,
});

// Create a callback handler for LangChain
export function getLangfuseCallbackHandler(
  sessionId?: string,
  userId?: string
) {
  return new CallbackHandler({
    publicKey: process.env.LANGFUSE_PUBLIC_KEY!,
    secretKey: process.env.LANGFUSE_SECRET_KEY!,
    baseUrl: process.env.LANGFUSE_BASE_URL,
    sessionId,
    userId,
  });
}

// Trace a simple LLM call
export async function traceLLMCall(
  name: string,
  input: string,
  output: string,
  metadata?: Record<string, any>
) {
  const trace = langfuse.trace({
    name,
    metadata,
  });

  const generation = trace.generation({
    name: 'llm-generation',
    input,
    output,
    model: metadata?.model || 'unknown',
    modelParameters: {
      temperature: metadata?.temperature,
      maxTokens: metadata?.maxTokens,
    },
  });

  await generation.end();
  await trace.end();
  
  return trace.id;
}

// Score a generation
export async function scoreGeneration(
  traceId: string,
  name: string,
  value: number,
  comment?: string
) {
  await langfuse.score({
    traceId,
    name,
    value,
    comment,
  });
}

// Track user feedback
export async function trackFeedback(
  traceId: string,
  rating: number,
  comment?: string
) {
  await langfuse.score({
    traceId,
    name: 'user-feedback',
    value: rating,
    comment,
  });
}

// Create a custom event
export async function trackEvent(
  name: string,
  metadata: Record<string, any>,
  userId?: string
) {
  const trace = langfuse.trace({
    name: 'custom-event',
    userId,
    metadata: {
      eventName: name,
      ...metadata,
    },
  });

  await trace.end();
  return trace.id;
}

// Flush all pending requests
export async function flush() {
  await langfuse.flush();
}`
          },
          {
            type: 'file-create',
            target: 'src/lib/ai/traced-llm.ts',
            template: `import { ChatOpenAI } from '@langchain/openai';
import { getLangfuseCallbackHandler } from './langfuse';

export function getTracedLLM(
  sessionId?: string,
  userId?: string,
  modelName: string = 'gpt-4-turbo-preview'
) {
  const callbackHandler = getLangfuseCallbackHandler(sessionId, userId);

  return new ChatOpenAI({
    modelName,
    temperature: 0.7,
    openAIApiKey: process.env.OPENAI_API_KEY,
    callbacks: [callbackHandler],
  });
}

// Example usage with automatic tracing
export async function generateWithTracing(
  prompt: string,
  sessionId?: string,
  userId?: string
) {
  const llm = getTracedLLM(sessionId, userId);
  
  const response = await llm.invoke(prompt);
  
  return response.content;
}`
          },
          {
            type: 'dependency',
            packages: {
              'langfuse': '^3.0.0',
              'langfuse-langchain': '^3.0.0'
            }
          }
        ],
        envVariables: [
          {
            name: 'LANGFUSE_PUBLIC_KEY',
            description: 'Langfuse public key',
            required: true,
            type: 'string'
          },
          {
            name: 'LANGFUSE_SECRET_KEY',
            description: 'Langfuse secret key',
            required: true,
            type: 'string',
            sensitive: true
          },
          {
            name: 'LANGFUSE_BASE_URL',
            description: 'Langfuse base URL (optional for self-hosted)',
            required: false,
            type: 'string',
            defaultValue: 'https://cloud.langfuse.com'
          }
        ],
        documentation: 'https://langfuse.com/docs',
        complexity: 'low',
        tags: ['ai', 'observability', 'monitoring', 'tracing', 'llm']
      },

      // Additional AI Integration Services
      {
        name: 'google-ai',
        type: 'ai',
        provider: 'google',
        version: '0.2.0',
        description: 'Google AI Platform integration for Gemini and PaLM models',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/google-ai.ts',
            template: `import { GoogleGenerativeAI } from '@google/generative-ai';

const genAI = new GoogleGenerativeAI(process.env.GOOGLE_AI_API_KEY!);

export interface GeminiOptions {
  model?: string;
  temperature?: number;
  maxOutputTokens?: number;
  topP?: number;
  topK?: number;
}

export async function generateContent(
  prompt: string,
  options: GeminiOptions = {}
) {
  const {
    model = 'gemini-pro',
    temperature = 0.7,
    maxOutputTokens = 1000,
    topP = 0.8,
    topK = 40
  } = options;

  const modelInstance = genAI.getGenerativeModel({ 
    model,
    generationConfig: {
      temperature,
      maxOutputTokens,
      topP,
      topK
    }
  });

  const result = await modelInstance.generateContent(prompt);
  const response = await result.response;
  return response.text();
}

export async function generateContentStream(
  prompt: string,
  options: GeminiOptions = {}
) {
  const {
    model = 'gemini-pro',
    temperature = 0.7,
    maxOutputTokens = 1000
  } = options;

  const modelInstance = genAI.getGenerativeModel({ 
    model,
    generationConfig: {
      temperature,
      maxOutputTokens
    }
  });

  const result = await modelInstance.generateContentStream(prompt);
  return result.stream;
}

export async function chat(messages: Array<{ role: string; parts: string }>) {
  const model = genAI.getGenerativeModel({ model: 'gemini-pro' });
  const chat = model.startChat({
    history: messages.slice(0, -1).map(msg => ({
      role: msg.role === 'user' ? 'user' : 'model',
      parts: [{ text: msg.parts }]
    }))
  });

  const lastMessage = messages[messages.length - 1];
  const result = await chat.sendMessage(lastMessage.parts);
  const response = await result.response;
  return response.text();
}`,
            priority: 80
          },
          {
            type: 'file-create',
            target: 'src/types/google-ai.ts',
            template: `export interface GeminiModel {
  name: string;
  displayName: string;
  description: string;
  inputTokenLimit: number;
  outputTokenLimit: number;
  supportedGenerationMethods: string[];
}

export interface GeminiResponse {
  candidates: Array<{
    content: {
      parts: Array<{
        text: string;
      }>;
      role: string;
    };
    finishReason: string;
    index: number;
  }>;
  promptFeedback?: {
    safetyRatings: Array<{
      category: string;
      probability: string;
    }>;
  };
}`,
            priority: 70
          }
        ],
        dependencies: {
          npm: {
            '@google/generative-ai': '^0.2.0'
          }
        },
        environmentVariables: [
          {
            name: 'GOOGLE_AI_API_KEY',
            description: 'Google AI API key',
            required: true,
            type: 'string'
          }
        ],
        documentation: 'https://ai.google.dev/docs',
        complexity: 'medium',
        tags: ['ai', 'google', 'gemini', 'palm', 'llm']
      },

      {
        name: 'cohere',
        type: 'ai',
        provider: 'cohere',
        version: '7.0.0',
        description: 'Cohere AI platform for natural language processing',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/cohere.ts',
            template: `import { CohereClient } from 'cohere-ai';

const cohere = new CohereClient({
  token: process.env.COHERE_API_KEY!,
});

export interface CohereGenerateOptions {
  model?: string;
  temperature?: number;
  maxTokens?: number;
  k?: number;
  p?: number;
  frequencyPenalty?: number;
  presencePenalty?: number;
}

export async function generate(
  prompt: string,
  options: CohereGenerateOptions = {}
) {
  const {
    model = 'command',
    temperature = 0.7,
    maxTokens = 1000,
    k = 0,
    p = 0.75,
    frequencyPenalty = 0,
    presencePenalty = 0
  } = options;

  const response = await cohere.generate({
    model,
    prompt,
    temperature,
    maxTokens,
    k,
    p,
    frequencyPenalty,
    presencePenalty
  });

  return response.generations[0]?.text || '';
}

export async function chat(
  messages: Array<{ role: string; message: string }>,
  options: { model?: string; temperature?: number } = {}
) {
  const { model = 'command', temperature = 0.7 } = options;

  const response = await cohere.chat({
    model,
    message: messages[messages.length - 1].message,
    chatHistory: messages.slice(0, -1).map(msg => ({
      role: msg.role as 'USER' | 'CHATBOT',
      message: msg.message
    })),
    temperature
  });

  return response.text;
}

export async function embed(texts: string[], model = 'embed-english-v3.0') {
  const response = await cohere.embed({
    texts,
    model,
    inputType: 'search_document'
  });

  return response.embeddings;
}

export async function classify(
  inputs: string[],
  examples: Array<{ text: string; label: string }>,
  model = 'embed-multilingual-v2.0'
) {
  const response = await cohere.classify({
    inputs,
    examples,
    model
  });

  return response.classifications;
}

export async function rerank(
  query: string,
  documents: Array<{ text: string }>,
  model = 'rerank-english-v2.0'
) {
  const response = await cohere.rerank({
    query,
    documents,
    model,
    topN: documents.length
  });

  return response.results;
}`,
            priority: 80
          }
        ],
        dependencies: {
          npm: {
            'cohere-ai': '^7.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'COHERE_API_KEY',
            description: 'Cohere API key',
            required: true,
            type: 'string'
          }
        ],
        documentation: 'https://docs.cohere.com/',
        complexity: 'medium',
        tags: ['ai', 'cohere', 'nlp', 'embeddings', 'classification']
      },

      {
        name: 'huggingface',
        type: 'ai',
        provider: 'huggingface',
        version: '2.0.0',
        description: 'Hugging Face transformers and inference API integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/huggingface.ts',
            template: `import { HfInference } from '@huggingface/inference';

const hf = new HfInference(process.env.HF_API_TOKEN);

export interface TextGenerationOptions {
  model?: string;
  temperature?: number;
  maxNewTokens?: number;
  topP?: number;
  repetitionPenalty?: number;
}

export async function generateText(
  prompt: string,
  options: TextGenerationOptions = {}
) {
  const {
    model = 'microsoft/DialoGPT-medium',
    temperature = 0.7,
    maxNewTokens = 100,
    topP = 0.9,
    repetitionPenalty = 1.0
  } = options;

  const response = await hf.textGeneration({
    model,
    inputs: prompt,
    parameters: {
      temperature,
      max_new_tokens: maxNewTokens,
      top_p: topP,
      repetition_penalty: repetitionPenalty,
      return_full_text: false
    }
  });

  return response.generated_text;
}

export async function chatCompletion(
  messages: Array<{ role: string; content: string }>,
  model = 'microsoft/DialoGPT-medium'
) {
  const prompt = messages.map(msg => 
    \`\${msg.role === 'user' ? 'User' : 'Assistant'}: \${msg.content}\`
  ).join('\\n') + '\\nAssistant:';

  return generateText(prompt, { model, maxNewTokens: 200 });
}

export async function getEmbedding(
  text: string,
  model = 'sentence-transformers/all-MiniLM-L6-v2'
) {
  const response = await hf.featureExtraction({
    model,
    inputs: text
  });

  return Array.isArray(response) ? response : [response];
}

export async function classifyText(
  text: string,
  model = 'cardiffnlp/twitter-roberta-base-sentiment-latest'
) {
  const response = await hf.textClassification({
    model,
    inputs: text
  });

  return response;
}

export async function summarizeText(
  text: string,
  model = 'facebook/bart-large-cnn'
) {
  const response = await hf.summarization({
    model,
    inputs: text,
    parameters: {
      max_length: 150,
      min_length: 30
    }
  });

  return response.summary_text;
}

export async function translateText(
  text: string,
  model = 'Helsinki-NLP/opus-mt-en-fr'
) {
  const response = await hf.translation({
    model,
    inputs: text
  });

  return response.translation_text;
}

export async function answerQuestion(
  question: string,
  context: string,
  model = 'deepset/roberta-base-squad2'
) {
  const response = await hf.questionAnswering({
    model,
    inputs: {
      question,
      context
    }
  });

  return response;
}`,
            priority: 80
          }
        ],
        dependencies: {
          npm: {
            '@huggingface/inference': '^2.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'HF_API_TOKEN',
            description: 'Hugging Face API token',
            required: true,
            type: 'string'
          }
        ],
        documentation: 'https://huggingface.co/docs/huggingface.js',
        complexity: 'medium',
        tags: ['ai', 'huggingface', 'transformers', 'nlp', 'inference']
      },

      // AI Chatbot Services  
      {
        name: 'botpress',
        type: 'ai-chatbot',
        provider: 'botpress',
        version: '12.26.0',
        description: 'Botpress conversational AI platform integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/chatbot/botpress.ts',
            template: `import axios from 'axios';

export interface BotpressConfig {
  serverUrl: string;
  botId: string;
  clientId?: string;
  clientSecret?: string;
}

export class BotpressClient {
  private config: BotpressConfig;
  private token?: string;

  constructor(config: BotpressConfig) {
    this.config = config;
  }

  async authenticate() {
    if (this.config.clientId && this.config.clientSecret) {
      const response = await axios.post(\`\${this.config.serverUrl}/api/v1/auth/login\`, {
        email: this.config.clientId,
        password: this.config.clientSecret
      });
      this.token = response.data.payload.jwt;
    }
  }

  async sendMessage(userId: string, message: string, channel = 'web') {
    const endpoint = \`\${this.config.serverUrl}/api/v1/bots/\${this.config.botId}/converse/\${userId}\`;
    
    const response = await axios.post(endpoint, {
      type: 'text',
      text: message,
      channel
    }, {
      headers: this.token ? { Authorization: \`Bearer \${this.token}\` } : {}
    });

    return response.data;
  }

  async getConversationHistory(userId: string, limit = 50) {
    const endpoint = \`\${this.config.serverUrl}/api/v1/bots/\${this.config.botId}/conversations/\${userId}/messages\`;
    
    const response = await axios.get(endpoint, {
      params: { limit },
      headers: this.token ? { Authorization: \`Bearer \${this.token}\` } : {}
    });

    return response.data;
  }

  async createBot(botConfig: {
    name: string;
    description?: string;
    category?: string;
    details?: any;
  }) {
    const endpoint = \`\${this.config.serverUrl}/api/v1/admin/workspace/bots\`;
    
    const response = await axios.post(endpoint, botConfig, {
      headers: this.token ? { Authorization: \`Bearer \${this.token}\` } : {}
    });

    return response.data;
  }

  async updateBotConfig(config: any) {
    const endpoint = \`\${this.config.serverUrl}/api/v1/bots/\${this.config.botId}/config\`;
    
    const response = await axios.post(endpoint, config, {
      headers: this.token ? { Authorization: \`Bearer \${this.token}\` } : {}
    });

    return response.data;
  }

  async trainBot(trainingData: Array<{
    input: string;
    output: string;
    intent?: string;
  }>) {
    // Implementation for training the bot with new data
    const endpoint = \`\${this.config.serverUrl}/api/v1/bots/\${this.config.botId}/mod/nlu/train\`;
    
    const response = await axios.post(endpoint, {
      language: 'en',
      data: trainingData
    }, {
      headers: this.token ? { Authorization: \`Bearer \${this.token}\` } : {}
    });

    return response.data;
  }
}

export function createBotpressClient(config: BotpressConfig) {
  return new BotpressClient(config);
}`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/components/BotpressWidget.tsx',
            template: `import React, { useEffect } from 'react';

interface BotpressWidgetProps {
  botId: string;
  hostUrl: string;
  messagingUrl?: string;
  clientId?: string;
  hideWidget?: boolean;
  disableAnimations?: boolean;
  theme?: 'light' | 'dark';
  className?: string;
}

export const BotpressWidget: React.FC<BotpressWidgetProps> = ({
  botId,
  hostUrl,
  messagingUrl,
  clientId,
  hideWidget = false,
  disableAnimations = false,
  theme = 'light',
  className = ''
}) => {
  useEffect(() => {
    // Load Botpress webchat script
    const script = document.createElement('script');
    script.src = 'https://cdn.botpress.cloud/webchat/v1/inject.js';
    script.async = true;
    
    script.onload = () => {
      (window as any).botpressWebChat.init({
        botId,
        hostUrl,
        messagingUrl: messagingUrl || \`\${hostUrl}/api/v1/bots/\${botId}\`,
        clientId,
        hideWidget,
        disableAnimations,
        theme,
        containerWidth: '100%',
        layoutWidth: '100%'
      });
    };
    
    document.body.appendChild(script);
    
    return () => {
      document.body.removeChild(script);
    };
  }, [botId, hostUrl, messagingUrl, clientId, hideWidget, disableAnimations, theme]);

  return (
    <div 
      id="bp-web-widget" 
      className={className}
      style={{ 
        width: '100%', 
        height: '100%',
        minHeight: '400px'
      }}
    />
  );
};`,
            priority: 80
          }
        ],
        dependencies: {
          npm: {
            'axios': '^1.6.0'
          }
        },
        environmentVariables: [
          {
            name: 'BOTPRESS_SERVER_URL',
            description: 'Botpress server URL',
            required: true,
            type: 'string'
          },
          {
            name: 'BOTPRESS_BOT_ID',
            description: 'Botpress bot ID',
            required: true,
            type: 'string'
          },
          {
            name: 'BOTPRESS_CLIENT_ID',
            description: 'Botpress client ID (optional)',
            required: false,
            type: 'string'
          },
          {
            name: 'BOTPRESS_CLIENT_SECRET',
            description: 'Botpress client secret (optional)',
            required: false,
            type: 'string'
          }
        ],
        documentation: 'https://botpress.com/docs',
        complexity: 'high',
        tags: ['ai', 'chatbot', 'botpress', 'conversational-ai', 'nlu']
      },

      {
        name: 'rasa',
        type: 'ai-chatbot',
        provider: 'rasa',
        version: '3.6.0',
        description: 'Rasa Open Source conversational AI framework',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/chatbot/rasa.ts',
            template: `import axios from 'axios';

export interface RasaConfig {
  serverUrl: string;
  token?: string;
}

export interface RasaMessage {
  text: string;
  parse_data?: any;
}

export interface RasaResponse {
  recipient_id: string;
  text?: string;
  image?: string;
  buttons?: Array<{
    title: string;
    payload: string;
  }>;
  elements?: any[];
}

export class RasaClient {
  private config: RasaConfig;

  constructor(config: RasaConfig) {
    this.config = config;
  }

  async sendMessage(
    message: string,
    sender: string,
    metadata?: any
  ): Promise<RasaResponse[]> {
    const endpoint = \`\${this.config.serverUrl}/webhooks/rest/webhook\`;
    
    const response = await axios.post(endpoint, {
      sender,
      message,
      metadata
    }, {
      headers: this.config.token ? {
        'Authorization': \`Bearer \${this.config.token}\`
      } : {}
    });

    return response.data;
  }

  async parseMessage(message: string): Promise<any> {
    const endpoint = \`\${this.config.serverUrl}/model/parse\`;
    
    const response = await axios.post(endpoint, {
      text: message
    }, {
      headers: this.config.token ? {
        'Authorization': \`Bearer \${this.config.token}\`
      } : {}
    });

    return response.data;
  }

  async getConversationHistory(sender: string): Promise<any[]> {
    const endpoint = \`\${this.config.serverUrl}/conversations/\${sender}/tracker\`;
    
    const response = await axios.get(endpoint, {
      headers: this.config.token ? {
        'Authorization': \`Bearer \${this.config.token}\`
      } : {}
    });

    return response.data.events || [];
  }

  async addTrainingData(
    intent: string,
    examples: string[],
    entities?: Array<{
      start: number;
      end: number;
      value: string;
      entity: string;
    }>[]
  ) {
    // This would typically interact with Rasa X or custom training endpoint
    const trainingData = {
      rasa_nlu_data: {
        common_examples: examples.map((text, index) => ({
          text,
          intent,
          entities: entities?.[index] || []
        }))
      }
    };

    return trainingData;
  }

  async trainModel() {
    const endpoint = \`\${this.config.serverUrl}/model/train\`;
    
    const response = await axios.post(endpoint, {}, {
      headers: this.config.token ? {
        'Authorization': \`Bearer \${this.config.token}\`
      } : {}
    });

    return response.data;
  }

  async getModelStatus() {
    const endpoint = \`\${this.config.serverUrl}/status\`;
    
    const response = await axios.get(endpoint);
    return response.data;
  }
}

export function createRasaClient(config: RasaConfig) {
  return new RasaClient(config);
}`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'config/domain.yml',
            template: `version: '3.1'

intents:
  - greet
  - goodbye
  - affirm
  - deny
  - mood_great
  - mood_unhappy
  - bot_challenge

responses:
  utter_greet:
  - text: "Hey! How are you?"

  utter_cheer_up:
  - text: "Here is something to cheer you up:"
    image: "https://i.imgur.com/nGF1K8f.jpg"

  utter_did_that_help:
  - text: "Did that help you?"

  utter_happy:
  - text: "Great, carry on!"

  utter_goodbye:
  - text: "Bye"

  utter_iamabot:
  - text: "I am a bot, powered by Rasa."

session_config:
  session_expiration_time: 60
  carry_over_slots_to_new_session: true`,
            priority: 90
          },
          {
            type: 'file-create',
            target: 'data/nlu.yml',
            template: `version: "3.1"

nlu:
- intent: greet
  examples: |
    - hey
    - hello
    - hi
    - hello there
    - good morning
    - good evening
    - moin
    - hey there
    - let's go
    - hey dude
    - goodmorning
    - goodevening
    - good afternoon

- intent: goodbye
  examples: |
    - cu
    - good by
    - cee you later
    - good night
    - bye
    - goodbye
    - have a nice day
    - see you around
    - bye bye
    - see you later

- intent: affirm
  examples: |
    - yes
    - y
    - indeed
    - of course
    - that sounds good
    - correct

- intent: deny
  examples: |
    - no
    - n
    - never
    - I don't think so
    - don't like that
    - no way
    - not really

- intent: mood_great
  examples: |
    - perfect
    - great
    - amazing
    - feeling like a king
    - wonderful
    - I am feeling very good
    - I am great
    - I am amazing
    - I am going to save the world
    - super stoked
    - extremely good
    - so so perfect
    - so good
    - so perfect

- intent: mood_unhappy
  examples: |
    - my day was horrible
    - I am sad
    - I don't feel very well
    - I am disappointed
    - super sad
    - I'm so sad
    - sad
    - very sad
    - unhappy
    - not good
    - not very good
    - extremly sad
    - so saad
    - so sad

- intent: bot_challenge
  examples: |
    - are you a bot?
    - are you a human?
    - am I talking to a bot?
    - am I talking to a human?`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            'axios': '^1.6.0'
          }
        },
        environmentVariables: [
          {
            name: 'RASA_SERVER_URL',
            description: 'Rasa server URL',
            required: true,
            type: 'string',
            defaultValue: 'http://localhost:5005'
          },
          {
            name: 'RASA_TOKEN',
            description: 'Rasa authentication token (optional)',
            required: false,
            type: 'string'
          }
        ],
        documentation: 'https://rasa.com/docs/',
        complexity: 'high',
        tags: ['ai', 'chatbot', 'rasa', 'nlu', 'conversational-ai', 'open-source']
      },

      {
        name: 'dialogflow',
        type: 'ai-chatbot',
        provider: 'google',
        version: '6.0.0',
        description: 'Google Dialogflow conversational AI integration',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/chatbot/dialogflow.ts',
            template: `import { SessionsClient } from '@google-cloud/dialogflow';
import { google } from '@google-cloud/dialogflow/build/protos/protos';

export interface DialogflowConfig {
  projectId: string;
  location?: string;
  languageCode?: string;
  keyFilename?: string;
}

export class DialogflowClient {
  private sessionsClient: SessionsClient;
  private projectId: string;
  private location: string;
  private languageCode: string;

  constructor(config: DialogflowConfig) {
    this.projectId = config.projectId;
    this.location = config.location || 'global';
    this.languageCode = config.languageCode || 'en';
    
    this.sessionsClient = new SessionsClient({
      keyFilename: config.keyFilename
    });
  }

  async detectIntent(
    sessionId: string,
    queryText: string,
    contexts?: google.cloud.dialogflow.v2.IContext[]
  ) {
    const sessionPath = this.sessionsClient.projectAgentSessionPath(
      this.projectId,
      sessionId
    );

    const request: google.cloud.dialogflow.v2.IDetectIntentRequest = {
      session: sessionPath,
      queryInput: {
        text: {
          text: queryText,
          languageCode: this.languageCode,
        },
      },
    };

    if (contexts) {
      request.queryParams = { contexts };
    }

    const [response] = await this.sessionsClient.detectIntent(request);
    return response;
  }

  async streamingDetectIntent(
    sessionId: string,
    audioConfig: google.cloud.dialogflow.v2.IInputAudioConfig
  ) {
    const sessionPath = this.sessionsClient.projectAgentSessionPath(
      this.projectId,
      sessionId
    );

    const request: google.cloud.dialogflow.v2.IStreamingDetectIntentRequest = {
      session: sessionPath,
      queryInput: {
        audioConfig,
      },
    };

    const stream = this.sessionsClient.streamingDetectIntent();
    stream.write(request);
    
    return stream;
  }

  async createIntent(
    displayName: string,
    trainingPhrases: string[],
    messageTexts: string[]
  ) {
    const intentsClient = new SessionsClient();
    const agentPath = intentsClient.projectAgentPath(this.projectId);

    const trainingPhraseParts = trainingPhrases.map(phrase => ({
      text: phrase,
      entityType: '',
      alias: '',
      userDefined: false,
    }));

    const messageText = {
      text: messageTexts,
    };

    const intent = {
      displayName,
      trainingPhrases: trainingPhraseParts.map(part => ({
        parts: [part],
      })),
      messages: [{ text: messageText }],
    };

    const createIntentRequest = {
      parent: agentPath,
      intent,
    };

    const [response] = await intentsClient.createIntent(createIntentRequest);
    return response;
  }

  async listIntents() {
    const intentsClient = new SessionsClient();
    const agentPath = intentsClient.projectAgentPath(this.projectId);

    const [intents] = await intentsClient.listIntents({ parent: agentPath });
    return intents;
  }

  async deleteIntent(intentName: string) {
    const intentsClient = new SessionsClient();
    await intentsClient.deleteIntent({ name: intentName });
  }

  async createContext(
    sessionId: string,
    contextName: string,
    lifespanCount: number,
    parameters?: { [key: string]: any }
  ) {
    const sessionPath = this.sessionsClient.projectAgentSessionPath(
      this.projectId,
      sessionId
    );
    
    const contextPath = \`\${sessionPath}/contexts/\${contextName}\`;

    const context = {
      name: contextPath,
      lifespanCount,
      parameters: parameters ? google.protobuf.Struct.fromObject(parameters) : undefined,
    };

    const contextsClient = new SessionsClient();
    const [response] = await contextsClient.createContext({
      parent: sessionPath,
      context,
    });

    return response;
  }
}

export function createDialogflowClient(config: DialogflowConfig) {
  return new DialogflowClient(config);
}`,
            priority: 85
          },
          {
            type: 'file-create',
            target: 'src/components/DialogflowMessenger.tsx',
            template: `import React, { useEffect } from 'react';

interface DialogflowMessengerProps {
  projectId: string;
  location?: string;
  languageCode?: string;
  botWritingText?: string;
  chatTitle?: string;
  placeholder?: string;
  welcomeIntent?: string;
  className?: string;
}

export const DialogflowMessenger: React.FC<DialogflowMessengerProps> = ({
  projectId,
  location = 'global',
  languageCode = 'en',
  botWritingText = 'Bot is typing...',
  chatTitle = 'Chat',
  placeholder = 'Type a message...',
  welcomeIntent,
  className = ''
}) => {
  useEffect(() => {
    // Load Dialogflow Messenger script
    const script = document.createElement('script');
    script.src = 'https://www.gstatic.com/dialogflow-console/fast/messenger/bootstrap.js?v=1';
    script.async = true;
    
    document.head.appendChild(script);
    
    return () => {
      if (document.head.contains(script)) {
        document.head.removeChild(script);
      }
    };
  }, []);

  return (
    <df-messenger
      project-id={projectId}
      agent-id={location}
      language-code={languageCode}
      bot-writing-text={botWritingText}
      chat-title={chatTitle}
      placeholder={placeholder}
      welcome-intent={welcomeIntent}
      className={className}
    />
  );
};

// Add TypeScript declaration for df-messenger
declare global {
  namespace JSX {
    interface IntrinsicElements {
      'df-messenger': React.DetailedHTMLProps<
        React.HTMLAttributes<HTMLElement> & {
          'project-id': string;
          'agent-id': string;
          'language-code': string;
          'bot-writing-text'?: string;
          'chat-title'?: string;
          'placeholder'?: string;
          'welcome-intent'?: string;
        },
        HTMLElement
      >;
    }
  }
}`,
            priority: 80
          }
        ],
        dependencies: {
          npm: {
            '@google-cloud/dialogflow': '^6.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'GOOGLE_APPLICATION_CREDENTIALS',
            description: 'Path to Google Cloud service account key file',
            required: true,
            type: 'string'
          },
          {
            name: 'DIALOGFLOW_PROJECT_ID',
            description: 'Google Cloud project ID',
            required: true,
            type: 'string'
          },
          {
            name: 'DIALOGFLOW_LOCATION',
            description: 'Dialogflow agent location',
            required: false,
            type: 'string',
            defaultValue: 'global'
          }
        ],
        documentation: 'https://cloud.google.com/dialogflow/docs',
        complexity: 'high',
        tags: ['ai', 'chatbot', 'dialogflow', 'google-cloud', 'conversational-ai']
      },

      // Vector Database Services
      {
        name: 'weaviate',
        type: 'vector-database',
        provider: 'weaviate',
        version: '1.0.0',
        description: 'Weaviate vector database for AI applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/vector-db/weaviate.ts',
            template: `import weaviate, { WeaviateClient, ApiKey } from 'weaviate-ts-client';

export interface WeaviateConfig {
  scheme: 'http' | 'https';
  host: string;
  apiKey?: string;
  headers?: Record<string, string>;
}

export class WeaviateVectorDB {
  private client: WeaviateClient;

  constructor(config: WeaviateConfig) {
    const clientConfig: any = {
      scheme: config.scheme,
      host: config.host,
    };

    if (config.apiKey) {
      clientConfig.authClientSecret = new ApiKey(config.apiKey);
    }

    if (config.headers) {
      clientConfig.headers = config.headers;
    }

    this.client = weaviate.client(clientConfig);
  }

  async createSchema(className: string, properties: Array<{
    name: string;
    dataType: string[];
    description?: string;
    moduleConfig?: any;
  }>) {
    const schema = {
      class: className,
      description: \`\${className} objects\`,
      properties,
      vectorizer: 'text2vec-openai',
      moduleConfig: {
        'text2vec-openai': {
          model: 'ada',
          modelVersion: '002',
          type: 'text'
        }
      }
    };

    const result = await this.client.schema
      .classCreator()
      .withClass(schema)
      .do();

    return result;
  }

  async addObject(
    className: string,
    properties: Record<string, any>,
    vector?: number[]
  ) {
    let creator = this.client.data
      .creator()
      .withClassName(className)
      .withProperties(properties);

    if (vector) {
      creator = creator.withVector(vector);
    }

    const result = await creator.do();
    return result;
  }

  async addObjects(
    className: string,
    objects: Array<{
      properties: Record<string, any>;
      vector?: number[];
    }>
  ) {
    const batcher = this.client.batch.objectsBatcher();

    objects.forEach(obj => {
      let batchObj = batcher
        .withClassName(className)
        .withProperties(obj.properties);

      if (obj.vector) {
        batchObj = batchObj.withVector(obj.vector);
      }

      batchObj.withId();
    });

    const result = await batcher.do();
    return result;
  }

  async search(
    className: string,
    query: {
      concepts?: string[];
      nearText?: string;
      nearVector?: number[];
      where?: any;
      limit?: number;
      offset?: number;
    }
  ) {
    let searcher = this.client.graphql
      .get()
      .withClassName(className);

    if (query.concepts) {
      searcher = searcher.withNearText({ concepts: query.concepts });
    }

    if (query.nearText) {
      searcher = searcher.withNearText({ concepts: [query.nearText] });
    }

    if (query.nearVector) {
      searcher = searcher.withNearVector({ vector: query.nearVector });
    }

    if (query.where) {
      searcher = searcher.withWhere(query.where);
    }

    if (query.limit) {
      searcher = searcher.withLimit(query.limit);
    }

    if (query.offset) {
      searcher = searcher.withOffset(query.offset);
    }

    searcher = searcher.withFields('_additional { id certainty distance } *');

    const result = await searcher.do();
    return result;
  }

  async semanticSearch(
    className: string,
    text: string,
    limit = 10
  ) {
    const result = await this.client.graphql
      .get()
      .withClassName(className)
      .withNearText({ concepts: [text] })
      .withLimit(limit)
      .withFields('_additional { id certainty } *')
      .do();

    return result;
  }

  async updateObject(
    id: string,
    className: string,
    properties: Record<string, any>
  ) {
    const result = await this.client.data
      .updater()
      .withId(id)
      .withClassName(className)
      .withProperties(properties)
      .do();

    return result;
  }

  async deleteObject(id: string) {
    const result = await this.client.data
      .deleter()
      .withId(id)
      .do();

    return result;
  }

  async getSchema() {
    const result = await this.client.schema.getter().do();
    return result;
  }

  async deleteClass(className: string) {
    const result = await this.client.schema
      .classDeleter()
      .withClassName(className)
      .do();

    return result;
  }
}

export function createWeaviateClient(config: WeaviateConfig) {
  return new WeaviateVectorDB(config);
}`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            'weaviate-ts-client': '^1.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'WEAVIATE_URL',
            description: 'Weaviate instance URL',
            required: true,
            type: 'string'
          },
          {
            name: 'WEAVIATE_API_KEY',
            description: 'Weaviate API key (optional)',
            required: false,
            type: 'string'
          }
        ],
        documentation: 'https://weaviate.io/developers/weaviate',
        complexity: 'medium',
        tags: ['ai', 'vector-database', 'weaviate', 'search', 'embeddings']
      },

      {
        name: 'qdrant',
        type: 'vector-database',
        provider: 'qdrant',
        version: '1.7.0',
        description: 'Qdrant vector database for similarity search',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/vector-db/qdrant.ts',
            template: `import { QdrantClient } from '@qdrant/js-client-rest';

export interface QdrantConfig {
  url: string;
  apiKey?: string;
  port?: number;
  https?: boolean;
}

export class QdrantVectorDB {
  private client: QdrantClient;

  constructor(config: QdrantConfig) {
    this.client = new QdrantClient({
      url: config.url,
      apiKey: config.apiKey,
      port: config.port,
      https: config.https
    });
  }

  async createCollection(
    collectionName: string,
    config: {
      size: number;
      distance: 'Cosine' | 'Euclid' | 'Dot';
      hnsw_config?: {
        m?: number;
        ef_construct?: number;
        full_scan_threshold?: number;
      };
      optimizers_config?: {
        deleted_threshold?: number;
        vacuum_min_vector_number?: number;
        default_segment_number?: number;
      };
    }
  ) {
    const result = await this.client.createCollection(collectionName, {
      vectors: {
        size: config.size,
        distance: config.distance,
        hnsw_config: config.hnsw_config,
      },
      optimizers_config: config.optimizers_config
    });

    return result;
  }

  async insertPoints(
    collectionName: string,
    points: Array<{
      id: number | string;
      vector: number[];
      payload?: Record<string, any>;
    }>
  ) {
    const result = await this.client.upsert(collectionName, {
      wait: true,
      points: points.map(point => ({
        id: point.id,
        vector: point.vector,
        payload: point.payload || {}
      }))
    });

    return result;
  }

  async search(
    collectionName: string,
    query: {
      vector: number[];
      limit?: number;
      offset?: number;
      filter?: any;
      params?: {
        hnsw_ef?: number;
        exact?: boolean;
      };
      score_threshold?: number;
    }
  ) {
    const result = await this.client.search(collectionName, {
      vector: query.vector,
      limit: query.limit || 10,
      offset: query.offset,
      filter: query.filter,
      params: query.params,
      score_threshold: query.score_threshold,
      with_payload: true,
      with_vector: false
    });

    return result;
  }

  async searchBatched(
    collectionName: string,
    queries: Array<{
      vector: number[];
      limit?: number;
      filter?: any;
    }>
  ) {
    const searchRequests = queries.map(query => ({
      vector: query.vector,
      limit: query.limit || 10,
      filter: query.filter,
      with_payload: true
    }));

    const result = await this.client.searchBatch(collectionName, {
      searches: searchRequests
    });

    return result;
  }

  async recommend(
    collectionName: string,
    config: {
      positive: Array<number | string>;
      negative?: Array<number | string>;
      limit?: number;
      offset?: number;
      filter?: any;
      using?: string;
      lookup_from?: {
        collection: string;
        vector?: string;
      };
    }
  ) {
    const result = await this.client.recommend(collectionName, {
      positive: config.positive,
      negative: config.negative || [],
      limit: config.limit || 10,
      offset: config.offset,
      filter: config.filter,
      using: config.using,
      lookup_from: config.lookup_from,
      with_payload: true,
      with_vector: false
    });

    return result;
  }

  async getPoint(collectionName: string, id: number | string) {
    const result = await this.client.getPoint(collectionName, id);
    return result;
  }

  async updatePoint(
    collectionName: string,
    id: number | string,
    payload: Record<string, any>
  ) {
    const result = await this.client.setPayload(collectionName, {
      payload,
      points: [id],
      wait: true
    });

    return result;
  }

  async deletePoints(
    collectionName: string,
    ids: Array<number | string>
  ) {
    const result = await this.client.delete(collectionName, {
      points: ids,
      wait: true
    });

    return result;
  }

  async getCollectionInfo(collectionName: string) {
    const result = await this.client.getCollection(collectionName);
    return result;
  }

  async deleteCollection(collectionName: string) {
    const result = await this.client.deleteCollection(collectionName);
    return result;
  }

  async createSnapshot(collectionName: string) {
    const result = await this.client.createSnapshot(collectionName);
    return result;
  }
}

export function createQdrantClient(config: QdrantConfig) {
  return new QdrantVectorDB(config);
}`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            '@qdrant/js-client-rest': '^1.7.0'
          }
        },
        environmentVariables: [
          {
            name: 'QDRANT_URL',
            description: 'Qdrant instance URL',
            required: true,
            type: 'string'
          },
          {
            name: 'QDRANT_API_KEY',
            description: 'Qdrant API key (optional)',
            required: false,
            type: 'string'
          }
        ],
        documentation: 'https://qdrant.tech/documentation/',
        complexity: 'medium',
        tags: ['ai', 'vector-database', 'qdrant', 'search', 'similarity']
      },

      {
        name: 'chroma',
        type: 'vector-database',
        provider: 'chroma',
        version: '1.7.0',
        description: 'ChromaDB vector database for AI applications',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/vector-db/chroma.ts',
            template: `import { ChromaClient, OpenAIEmbeddingFunction, CohereEmbeddingFunction } from 'chromadb';

export interface ChromaConfig {
  path?: string;
  host?: string;
  port?: number;
  ssl?: boolean;
  headers?: Record<string, string>;
  tenant?: string;
  database?: string;
}

export class ChromaVectorDB {
  private client: ChromaClient;

  constructor(config: ChromaConfig = {}) {
    if (config.path) {
      this.client = new ChromaClient({ path: config.path });
    } else {
      this.client = new ChromaClient({
        host: config.host || 'localhost',
        port: config.port || 8000,
        ssl: config.ssl || false,
        headers: config.headers,
        tenant: config.tenant || 'default_tenant',
        database: config.database || 'default_database'
      });
    }
  }

  async createCollection(
    name: string,
    options: {
      embeddingFunction?: 'openai' | 'cohere' | 'custom';
      metadata?: Record<string, any>;
      getOrCreate?: boolean;
    } = {}
  ) {
    let embeddingFunction;

    if (options.embeddingFunction === 'openai') {
      embeddingFunction = new OpenAIEmbeddingFunction({
        openai_api_key: process.env.OPENAI_API_KEY!
      });
    } else if (options.embeddingFunction === 'cohere') {
      embeddingFunction = new CohereEmbeddingFunction({
        cohere_api_key: process.env.COHERE_API_KEY!
      });
    }

    const collection = options.getOrCreate 
      ? await this.client.getOrCreateCollection({
          name,
          embeddingFunction,
          metadata: options.metadata
        })
      : await this.client.createCollection({
          name,
          embeddingFunction,
          metadata: options.metadata
        });

    return collection;
  }

  async getCollection(name: string) {
    const collection = await this.client.getCollection({ name });
    return collection;
  }

  async addDocuments(
    collectionName: string,
    documents: Array<{
      id: string;
      document: string;
      metadata?: Record<string, any>;
      embedding?: number[];
    }>
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.add({
      ids: documents.map(doc => doc.id),
      documents: documents.map(doc => doc.document),
      metadatas: documents.map(doc => doc.metadata || {}),
      embeddings: documents.some(doc => doc.embedding) 
        ? documents.map(doc => doc.embedding)
        : undefined
    });

    return result;
  }

  async query(
    collectionName: string,
    options: {
      queryTexts?: string[];
      queryEmbeddings?: number[][];
      nResults?: number;
      where?: Record<string, any>;
      whereDocument?: Record<string, any>;
      include?: ('documents' | 'embeddings' | 'metadatas' | 'distances')[];
    }
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.query({
      queryTexts: options.queryTexts,
      queryEmbeddings: options.queryEmbeddings,
      nResults: options.nResults || 10,
      where: options.where,
      whereDocument: options.whereDocument,
      include: options.include || ['documents', 'metadatas', 'distances']
    });

    return result;
  }

  async similaritySearch(
    collectionName: string,
    query: string,
    nResults = 10,
    where?: Record<string, any>
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.query({
      queryTexts: [query],
      nResults,
      where,
      include: ['documents', 'metadatas', 'distances']
    });

    return result;
  }

  async update(
    collectionName: string,
    updates: Array<{
      id: string;
      document?: string;
      metadata?: Record<string, any>;
      embedding?: number[];
    }>
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.update({
      ids: updates.map(update => update.id),
      documents: updates.map(update => update.document).filter(Boolean),
      metadatas: updates.map(update => update.metadata).filter(Boolean),
      embeddings: updates.map(update => update.embedding).filter(Boolean)
    });

    return result;
  }

  async upsert(
    collectionName: string,
    documents: Array<{
      id: string;
      document: string;
      metadata?: Record<string, any>;
      embedding?: number[];
    }>
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.upsert({
      ids: documents.map(doc => doc.id),
      documents: documents.map(doc => doc.document),
      metadatas: documents.map(doc => doc.metadata || {}),
      embeddings: documents.some(doc => doc.embedding) 
        ? documents.map(doc => doc.embedding)
        : undefined
    });

    return result;
  }

  async deleteDocuments(collectionName: string, ids: string[]) {
    const collection = await this.getCollection(collectionName);
    const result = await collection.delete({ ids });
    return result;
  }

  async get(
    collectionName: string,
    options: {
      ids?: string[];
      where?: Record<string, any>;
      limit?: number;
      offset?: number;
      include?: ('documents' | 'embeddings' | 'metadatas' | 'distances')[];
    } = {}
  ) {
    const collection = await this.getCollection(collectionName);

    const result = await collection.get({
      ids: options.ids,
      where: options.where,
      limit: options.limit,
      offset: options.offset,
      include: options.include || ['documents', 'metadatas']
    });

    return result;
  }

  async peek(collectionName: string, limit = 10) {
    const collection = await this.getCollection(collectionName);
    const result = await collection.peek({ limit });
    return result;
  }

  async count(collectionName: string) {
    const collection = await this.getCollection(collectionName);
    const result = await collection.count();
    return result;
  }

  async deleteCollection(name: string) {
    const result = await this.client.deleteCollection({ name });
    return result;
  }

  async listCollections() {
    const result = await this.client.listCollections();
    return result;
  }
}

export function createChromaClient(config: ChromaConfig = {}) {
  return new ChromaVectorDB(config);
}`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            'chromadb': '^1.7.0'
          }
        },
        environmentVariables: [
          {
            name: 'CHROMA_HOST',
            description: 'ChromaDB host',
            required: false,
            type: 'string',
            defaultValue: 'localhost'
          },
          {
            name: 'CHROMA_PORT',
            description: 'ChromaDB port',
            required: false,
            type: 'string',
            defaultValue: '8000'
          },
          {
            name: 'CHROMA_SSL',
            description: 'Use SSL for ChromaDB connection',
            required: false,
            type: 'boolean',
            defaultValue: 'false'
          }
        ],
        documentation: 'https://docs.trychroma.com/',
        complexity: 'medium',
        tags: ['ai', 'vector-database', 'chroma', 'embeddings', 'search']
      },

      // Additional AI Observability Services
      {
        name: 'helicone',
        type: 'ai-observability',
        provider: 'helicone',  
        version: '1.0.0',
        description: 'Helicone LLM observability and monitoring platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/helicone.ts',
            template: `import OpenAI from 'openai';

export interface HeliconeConfig {
  apiKey: string;
  baseURL?: string;
  rateLimitPolicy?: string;
  userId?: string;
  sessionId?: string;
  sessionName?: string;
  sessionPath?: string;
}

export class HeliconeOpenAI extends OpenAI {
  constructor(config: HeliconeConfig) {
    const headers: Record<string, string> = {
      'Helicone-Auth': \`Bearer \${config.apiKey}\`,
    };

    if (config.rateLimitPolicy) {
      headers['Helicone-RateLimit-Policy'] = config.rateLimitPolicy;
    }

    if (config.userId) {
      headers['Helicone-User-Id'] = config.userId;
    }

    if (config.sessionId) {
      headers['Helicone-Session-Id'] = config.sessionId;
    }

    if (config.sessionName) {
      headers['Helicone-Session-Name'] = config.sessionName;
    }

    if (config.sessionPath) {
      headers['Helicone-Session-Path'] = config.sessionPath;
    }

    super({
      apiKey: process.env.OPENAI_API_KEY!,
      baseURL: config.baseURL || 'https://oai.helicone.ai/v1',
      defaultHeaders: headers,
    });
  }

  async createChatCompletionWithLogging(
    params: OpenAI.Chat.ChatCompletionCreateParams,
    metadata?: Record<string, any>
  ) {
    const headers: Record<string, string> = {};

    if (metadata) {
      Object.entries(metadata).forEach(([key, value]) => {
        headers[\`Helicone-Property-\${key}\`] = String(value);
      });
    }

    const completion = await this.chat.completions.create(params, {
      headers
    });

    return completion;
  }

  async logCustomEvent(
    eventName: string,
    properties: Record<string, any> = {},
    userId?: string
  ) {
    const headers: Record<string, string> = {
      'Helicone-Custom-Event': eventName,
    };

    if (userId) {
      headers['Helicone-User-Id'] = userId;
    }

    Object.entries(properties).forEach(([key, value]) => {
      headers[\`Helicone-Property-\${key}\`] = String(value);
    });

    // Make a dummy request to log the custom event
    try {
      await this.chat.completions.create({
        model: 'gpt-3.5-turbo',
        messages: [{ role: 'user', content: 'ping' }],
        max_tokens: 1
      }, { headers });
    } catch (error) {
      // Expected to fail, but event is logged
    }
  }

  async logFeedback(
    requestId: string,
    rating: number,
    feedback?: string
  ) {
    const response = await fetch('https://api.helicone.ai/v1/feedback', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.HELICONE_API_KEY}\`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        'helicone-id': requestId,
        rating,
        feedback
      })
    });

    return response.json();
  }
}

export interface HeliconeMetrics {
  totalRequests: number;
  totalCost: number;
  averageLatency: number;
  successRate: number;
  errorRate: number;
}

export async function getHeliconeMetrics(
  startDate: string,
  endDate: string,
  userId?: string
): Promise<HeliconeMetrics> {
  const params = new URLSearchParams({
    start_date: startDate,
    end_date: endDate
  });

  if (userId) {
    params.append('user_id', userId);
  }

  const response = await fetch(
    \`https://api.helicone.ai/v1/metrics?\${params}\`,
    {
      headers: {
        'Authorization': \`Bearer \${process.env.HELICONE_API_KEY}\`
      }
    }
  );

  return response.json();
}

export async function getHeliconeRequests(
  limit = 100,
  offset = 0,
  userId?: string
) {
  const params = new URLSearchParams({
    limit: limit.toString(),
    offset: offset.toString()
  });

  if (userId) {
    params.append('user_id', userId);
  }

  const response = await fetch(
    \`https://api.helicone.ai/v1/requests?\${params}\`,
    {
      headers: {
        'Authorization': \`Bearer \${process.env.HELICONE_API_KEY}\`
      }
    }
  );

  return response.json();
}

export function createHeliconeClient(config: HeliconeConfig) {
  return new HeliconeOpenAI(config);
}`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            'openai': '^4.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'HELICONE_API_KEY',
            description: 'Helicone API key',
            required: true,
            type: 'string'
          },
          {
            name: 'OPENAI_API_KEY',
            description: 'OpenAI API key',
            required: true,
            type: 'string'
          }
        ],
        documentation: 'https://docs.helicone.ai/',
        complexity: 'low',
        tags: ['ai', 'observability', 'monitoring', 'helicone', 'openai']
      },

      {
        name: 'portkey',
        type: 'ai-observability',
        provider: 'portkey',
        version: '1.0.0',
        description: 'Portkey AI gateway and observability platform',
        injectionPoints: [
          {
            type: 'file-create',
            target: 'src/lib/ai/portkey.ts',
            template: `import Portkey from 'portkey-ai';

export interface PortkeyConfig {
  apiKey: string;
  virtualKey?: string;
  config?: string;
  provider?: string;
  traceId?: string;
  metadata?: Record<string, any>;
  cacheForceRefresh?: boolean;
  cacheNamespace?: string;
}

export class PortkeyClient {
  private client: Portkey;

  constructor(config: PortkeyConfig) {
    this.client = new Portkey({
      apiKey: config.apiKey,
      virtualKey: config.virtualKey,
      config: config.config,
      provider: config.provider,
      traceId: config.traceId,
      metadata: config.metadata,
      cacheForceRefresh: config.cacheForceRefresh,
      cacheNamespace: config.cacheNamespace,
    });
  }

  async createChatCompletion(
    params: any,
    options?: {
      traceId?: string;
      metadata?: Record<string, any>;
      tags?: string[];
      cache?: boolean;
      cacheAge?: number;
    }
  ) {
    const headers: Record<string, string> = {};

    if (options?.traceId) {
      headers['x-portkey-trace-id'] = options.traceId;
    }

    if (options?.metadata) {
      headers['x-portkey-metadata'] = JSON.stringify(options.metadata);
    }

    if (options?.tags) {
      headers['x-portkey-tags'] = options.tags.join(',');
    }

    if (options?.cache) {
      headers['x-portkey-cache'] = 'true';
      if (options.cacheAge) {
        headers['x-portkey-cache-max-age'] = options.cacheAge.toString();
      }
    }

    const completion = await this.client.chat.completions.create(params, {
      headers
    });

    return completion;
  }

  async createCompletion(
    params: any,
    options?: {
      traceId?: string;
      metadata?: Record<string, any>;
    }
  ) {
    const headers: Record<string, string> = {};

    if (options?.traceId) {
      headers['x-portkey-trace-id'] = options.traceId;
    }

    if (options?.metadata) {
      headers['x-portkey-metadata'] = JSON.stringify(options.metadata);
    }

    const completion = await this.client.completions.create(params, {
      headers
    });

    return completion;
  }

  async createEmbedding(
    params: any,
    options?: {
      traceId?: string;
      metadata?: Record<string, any>;
    }
  ) {
    const headers: Record<string, string> = {};

    if (options?.traceId) {
      headers['x-portkey-trace-id'] = options.traceId;
    }

    if (options?.metadata) {
      headers['x-portkey-metadata'] = JSON.stringify(options.metadata);
    }

    const embedding = await this.client.embeddings.create(params, {
      headers
    });

    return embedding;
  }

  async logFeedback(
    traceId: string,
    rating: number,
    feedback?: string,
    metadata?: Record<string, any>
  ) {
    const response = await fetch('https://api.portkey.ai/v1/feedback', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.PORTKEY_API_KEY}\`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        traceId,
        rating,
        feedback,
        metadata
      })
    });

    return response.json();
  }

  async getAnalytics(
    startDate: string,
    endDate: string,
    filters?: {
      provider?: string;
      model?: string;
      userId?: string;
      tags?: string[];
    }
  ) {
    const params = new URLSearchParams({
      start_date: startDate,
      end_date: endDate
    });

    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (Array.isArray(value)) {
          params.append(key, value.join(','));
        } else if (value) {
          params.append(key, value);
        }
      });
    }

    const response = await fetch(
      \`https://api.portkey.ai/v1/analytics?\${params}\`,
      {
        headers: {
          'Authorization': \`Bearer \${process.env.PORTKEY_API_KEY}\`
        }
      }
    );

    return response.json();
  }

  async getLogs(
    limit = 100,
    offset = 0,
    filters?: {
      traceId?: string;
      provider?: string;
      model?: string;
      userId?: string;
    }
  ) {
    const params = new URLSearchParams({
      limit: limit.toString(),
      offset: offset.toString()
    });

    if (filters) {
      Object.entries(filters).forEach(([key, value]) => {
        if (value) {
          params.append(key, value);
        }
      });
    }

    const response = await fetch(
      \`https://api.portkey.ai/v1/logs?\${params}\`,
      {
        headers: {
          'Authorization': \`Bearer \${process.env.PORTKEY_API_KEY}\`
        }
      }
    );

    return response.json();
  }

  async createPromptTemplate(
    name: string,
    template: string,
    variables?: string[],
    metadata?: Record<string, any>
  ) {
    const response = await fetch('https://api.portkey.ai/v1/prompts', {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.PORTKEY_API_KEY}\`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        name,
        template,
        variables,
        metadata
      })
    });

    return response.json();
  }

  async renderPrompt(
    promptId: string,
    variables: Record<string, any>
  ) {
    const response = await fetch(\`https://api.portkey.ai/v1/prompts/\${promptId}/render\`, {
      method: 'POST',
      headers: {
        'Authorization': \`Bearer \${process.env.PORTKEY_API_KEY}\`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ variables })
    });

    return response.json();
  }
}

export function createPortkeyClient(config: PortkeyConfig) {
  return new PortkeyClient(config);
}`,
            priority: 85
          }
        ],
        dependencies: {
          npm: {
            'portkey-ai': '^1.0.0'
          }
        },
        environmentVariables: [
          {
            name: 'PORTKEY_API_KEY',
            description: 'Portkey API key',
            required: true,
            type: 'string'
          },
          {
            name: 'PORTKEY_VIRTUAL_KEY',
            description: 'Portkey virtual key (optional)',
            required: false,
            type: 'string'
          }
        ],
        documentation: 'https://docs.portkey.ai/',
        complexity: 'medium',
        tags: ['ai', 'observability', 'gateway', 'portkey', 'monitoring']
      }
    ];

    // Register built-in templates
    for (const template of builtInTemplates) {
      await this.registerTemplate(template);
    }
  }
}