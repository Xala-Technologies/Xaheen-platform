{
  "$schema": "https://xaheen.io/schemas/registry-item.schema.json",
  "name": "use-responsive",
  "type": "registry:hook",
  "title": "useResponsive",
  "description": "Responsive design hook with breakpoint detection",
  "platforms": [
    "react",
    "nextjs",
    "vue",
    "angular",
    "svelte",
    "react-native",
    "electron",
    "ionic",
    "vanilla",
    "headless-ui",
    "radix"
  ],
  "files": [
    {
      "path": "hooks/use-responsive.ts",
      "type": "registry:hook",
      "content": "/**\n * useResponsive Hook - Responsive breakpoint detection\n * Professional responsive design with Norwegian enterprise standards\n * WCAG AAA: Ensures responsive design doesn't break accessibility\n */\n\nimport { useEffect, useState, useCallback } from 'react';\n\n// Breakpoint values matching Tailwind CSS defaults\nconst breakpoints = {\n  xs: 0,      // Mobile first\n  sm: 640,    // Small tablets\n  md: 768,    // Tablets\n  lg: 1024,   // Small laptops\n  xl: 1280,   // Desktops\n  '2xl': 1536 // Large screens\n} as const;\n\nexport type Breakpoint = keyof typeof breakpoints;\n\nexport interface ResponsiveConfig {\n  /** Enable SSR-safe behavior */\n  readonly ssr?: boolean;\n  /** Debounce resize events (ms) */\n  readonly debounce?: number;\n  /** Initial breakpoint for SSR */\n  readonly initialBreakpoint?: Breakpoint;\n}\n\nexport interface ResponsiveResult {\n  /** Current breakpoint */\n  readonly breakpoint: Breakpoint;\n  /** Check if current viewport is at least the specified breakpoint */\n  readonly isAtLeast: (breakpoint: Breakpoint) => boolean;\n  /** Check if current viewport is at most the specified breakpoint */\n  readonly isAtMost: (breakpoint: Breakpoint) => boolean;\n  /** Check if current viewport exactly matches the breakpoint */\n  readonly is: (breakpoint: Breakpoint) => boolean;\n  /** Check if current viewport is between two breakpoints (inclusive) */\n  readonly isBetween: (min: Breakpoint, max: Breakpoint) => boolean;\n  /** Current viewport width */\n  readonly width: number;\n  /** Current viewport height */\n  readonly height: number;\n  /** Device orientation */\n  readonly orientation: 'portrait' | 'landscape';\n  /** Check if device supports touch */\n  readonly isTouch: boolean;\n  /** Check if reduced motion is preferred */\n  readonly prefersReducedMotion: boolean;\n}\n\nexport const useResponsive = (config: ResponsiveConfig = {}): ResponsiveResult => {\n  const { \n    ssr = false, \n    debounce = 150, \n    initialBreakpoint = 'lg' \n  } = config;\n\n  // Initialize with SSR-safe values\n  const [width, setWidth] = useState<number>(ssr ? breakpoints[initialBreakpoint] : 0);\n  const [height, setHeight] = useState<number>(ssr ? 900 : 0); // Reasonable default height\n  const [isTouch, setIsTouch] = useState(false);\n  const [prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n\n  // Get current breakpoint\n  const getBreakpoint = useCallback((w: number): Breakpoint => {\n    const entries = Object.entries(breakpoints).reverse() as Array<[Breakpoint, number]>;\n    for (const [key, value] of entries) {\n      if (w >= value) return key;\n    }\n    return 'xs';\n  }, []);\n\n  const [breakpoint, setBreakpoint] = useState<Breakpoint>(\n    ssr ? initialBreakpoint : 'xs'\n  );\n\n  // Responsive check functions\n  const isAtLeast = useCallback((bp: Breakpoint): boolean => {\n    return width >= breakpoints[bp];\n  }, [width]);\n\n  const isAtMost = useCallback((bp: Breakpoint): boolean => {\n    const bpIndex = Object.keys(breakpoints).indexOf(bp);\n    const nextBp = Object.keys(breakpoints)[bpIndex + 1] as Breakpoint | undefined;\n    return nextBp ? width < breakpoints[nextBp] : true;\n  }, [width]);\n\n  const is = useCallback((bp: Breakpoint): boolean => {\n    return breakpoint === bp;\n  }, [breakpoint]);\n\n  const isBetween = useCallback((min: Breakpoint, max: Breakpoint): boolean => {\n    return width >= breakpoints[min] && width < breakpoints[max];\n  }, [width]);\n\n  // Update dimensions\n  useEffect(() => {\n    if (typeof window === 'undefined') return;\n\n    let timeoutId: ReturnType<typeof setTimeout>;\n\n    const updateDimensions = () => {\n      clearTimeout(timeoutId);\n      timeoutId = setTimeout(() => {\n        const w = window.innerWidth;\n        const h = window.innerHeight;\n        setWidth(w);\n        setHeight(h);\n        setBreakpoint(getBreakpoint(w));\n      }, debounce);\n    };\n\n    const updateMediaQueries = () => {\n      // Check touch support\n      setIsTouch('ontouchstart' in window || navigator.maxTouchPoints > 0);\n      \n      // Check reduced motion preference\n      const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n      setPrefersReducedMotion(motionQuery.matches);\n    };\n\n    // Initial setup\n    updateDimensions();\n    updateMediaQueries();\n\n    // Set up listeners\n    window.addEventListener('resize', updateDimensions);\n    \n    const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    motionQuery.addEventListener('change', updateMediaQueries);\n\n    return () => {\n      clearTimeout(timeoutId);\n      window.removeEventListener('resize', updateDimensions);\n      motionQuery.removeEventListener('change', updateMediaQueries);\n    };\n  }, [debounce, getBreakpoint]);\n\n  // Calculate orientation\n  const orientation = width > height ? 'landscape' : 'portrait';\n\n  return {\n    breakpoint,\n    isAtLeast,\n    isAtMost,\n    is,\n    isBetween,\n    width,\n    height,\n    orientation,\n    isTouch,\n    prefersReducedMotion\n  };\n};\n\n// Utility hook for conditional rendering based on breakpoints\nexport const useBreakpointValue = <T,>(\n  values: Partial<Record<Breakpoint, T>>,\n  config?: ResponsiveConfig\n): T | undefined => {\n  const { breakpoint } = useResponsive(config);\n  \n  // Find the value for current breakpoint or fall back to smaller ones\n  const breakpointKeys = Object.keys(breakpoints) as Breakpoint[];\n  const currentIndex = breakpointKeys.indexOf(breakpoint);\n  \n  for (let i = currentIndex; i >= 0; i--) {\n    const bp = breakpointKeys[i];\n    if (values[bp] !== undefined) {\n      return values[bp];\n    }\n  }\n  \n  return undefined;\n};\n\n// Export breakpoints for external use\nexport { breakpoints };"
    }
  ]
}