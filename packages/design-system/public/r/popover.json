{
  "$schema": "https://xaheen.io/schemas/registry-item.schema.json",
  "name": "popover",
  "type": "registry:component",
  "title": "Popover",
  "description": "Floating content panels",
  "category": "components",
  "categories": [
    "components",
    "overlay"
  ],
  "nsm": {
    "classification": "OPEN",
    "wcagLevel": "AAA",
    "norwegianOptimized": true
  },
  "platforms": [
    "react",
    "nextjs",
    "vue",
    "angular",
    "svelte",
    "react-native",
    "electron",
    "ionic",
    "vanilla",
    "headless-ui",
    "radix"
  ],
  "dependencies": [
    "@radix-ui/react-popover"
  ],
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "components/popover/popover.tsx",
      "type": "registry:component",
      "content": "import React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport { createPortal } from 'react-dom';\nimport { tokens } from '../../core/universal-tokens';\n\nconst popoverVariants = cva(\n  'absolute z-50 min-w-[8rem] overflow-hidden rounded-xl bg-white text-gray-900 shadow-lg outline-none transition-all',\n  {\n    variants: {\n      placement: {\n        top: 'bottom-full mb-2',\n        bottom: 'top-full mt-2',\n        left: 'right-full mr-2',\n        right: 'left-full ml-2',\n        'top-start': 'bottom-full mb-2 right-0',\n        'top-end': 'bottom-full mb-2 left-0',\n        'bottom-start': 'top-full mt-2 left-0',\n        'bottom-end': 'top-full mt-2 right-0',\n      },\n      size: {\n        sm: 'max-w-xs',\n        md: 'max-w-sm',\n        lg: 'max-w-md',\n        xl: 'max-w-lg',\n        full: 'max-w-full',\n      },\n    },\n    defaultVariants: {\n      placement: 'bottom',\n      size: 'md',\n    },\n  }\n);\n\ninterface PopoverProps extends VariantProps<typeof popoverVariants> {\n  readonly children: React.ReactNode;\n  readonly trigger: React.ReactNode;\n  readonly open?: boolean;\n  readonly defaultOpen?: boolean;\n  readonly onOpenChange?: (open: boolean) => void;\n  readonly modal?: boolean;\n  readonly className?: string;\n  readonly triggerAsChild?: boolean;\n  readonly offset?: number;\n  readonly sideOffset?: number;\n  readonly align?: 'start' | 'center' | 'end';\n  readonly alignOffset?: number;\n  readonly avoidCollisions?: boolean;\n  readonly collisionBoundary?: Element | null;\n  readonly collisionPadding?: number | { top?: number; right?: number; bottom?: number; left?: number };\n  readonly sticky?: 'partial' | 'always';\n}\n\nexport const Popover = ({\n  children,\n  trigger,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n  modal = false,\n  className,\n  triggerAsChild = false,\n  placement,\n  size,\n  offset = 0,\n  sideOffset = 0,\n  align = 'center',\n  alignOffset = 0,\n  avoidCollisions = true,\n  collisionBoundary,\n  collisionPadding = 8,\n  sticky = 'partial',\n}: PopoverProps): JSX.Element => {\n  const [uncontrolledOpen, setUncontrolledOpen] = useState(defaultOpen);\n  const isOpen = controlledOpen !== undefined ? controlledOpen : uncontrolledOpen;\n  const triggerRef = useRef<HTMLElement>(null);\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  const handleOpenChange = useCallback((newOpen: boolean) => {\n    if (controlledOpen === undefined) {\n      setUncontrolledOpen(newOpen);\n    }\n    onOpenChange?.(newOpen);\n  }, [controlledOpen, onOpenChange]);\n\n  const handleTriggerClick = useCallback(() => {\n    handleOpenChange(!isOpen);\n  }, [isOpen, handleOpenChange]);\n\n  const handleKeyDown = useCallback((event: KeyboardEvent) => {\n    if (event.key === 'Escape' && isOpen) {\n      handleOpenChange(false);\n    }\n  }, [isOpen, handleOpenChange]);\n\n  const handleClickOutside = useCallback((event: MouseEvent) => {\n    if (!modal) return;\n    \n    const target = event.target as Node;\n    if (\n      popoverRef.current &&\n      !popoverRef.current.contains(target) &&\n      triggerRef.current &&\n      !triggerRef.current.contains(target)\n    ) {\n      handleOpenChange(false);\n    }\n  }, [modal, handleOpenChange]);\n\n  useEffect(() => {\n    if (isOpen) {\n      document.addEventListener('keydown', handleKeyDown);\n      document.addEventListener('mousedown', handleClickOutside);\n      \n      return () => {\n        document.removeEventListener('keydown', handleKeyDown);\n        document.removeEventListener('mousedown', handleClickOutside);\n      };\n    }\n  }, [isOpen, handleKeyDown, handleClickOutside]);\n\n  const updatePosition = useCallback(() => {\n    if (!triggerRef.current || !popoverRef.current) return;\n\n    const triggerRect = triggerRef.current.getBoundingClientRect();\n    const popoverRect = popoverRef.current.getBoundingClientRect();\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    let top = 0;\n    let left = 0;\n\n    // Calculate base position based on placement\n    switch (placement) {\n      case 'top':\n        top = triggerRect.top - popoverRect.height - sideOffset;\n        left = triggerRect.left + (triggerRect.width - popoverRect.width) / 2;\n        break;\n      case 'bottom':\n        top = triggerRect.bottom + sideOffset;\n        left = triggerRect.left + (triggerRect.width - popoverRect.width) / 2;\n        break;\n      case 'left':\n        top = triggerRect.top + (triggerRect.height - popoverRect.height) / 2;\n        left = triggerRect.left - popoverRect.width - sideOffset;\n        break;\n      case 'right':\n        top = triggerRect.top + (triggerRect.height - popoverRect.height) / 2;\n        left = triggerRect.right + sideOffset;\n        break;\n      case 'top-start':\n        top = triggerRect.top - popoverRect.height - sideOffset;\n        left = triggerRect.left + alignOffset;\n        break;\n      case 'top-end':\n        top = triggerRect.top - popoverRect.height - sideOffset;\n        left = triggerRect.right - popoverRect.width - alignOffset;\n        break;\n      case 'bottom-start':\n        top = triggerRect.bottom + sideOffset;\n        left = triggerRect.left + alignOffset;\n        break;\n      case 'bottom-end':\n        top = triggerRect.bottom + sideOffset;\n        left = triggerRect.right - popoverRect.width - alignOffset;\n        break;\n      default:\n        top = triggerRect.bottom + sideOffset;\n        left = triggerRect.left + (triggerRect.width - popoverRect.width) / 2;\n    }\n\n    // Apply collision detection\n    if (avoidCollisions) {\n      const padding = typeof collisionPadding === 'number' \n        ? { top: collisionPadding, right: collisionPadding, bottom: collisionPadding, left: collisionPadding }\n        : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPadding };\n\n      // Check horizontal collisions\n      if (left < padding.left) {\n        left = padding.left;\n      } else if (left + popoverRect.width > viewportWidth - padding.right) {\n        left = viewportWidth - popoverRect.width - padding.right;\n      }\n\n      // Check vertical collisions\n      if (top < padding.top) {\n        top = padding.top;\n      } else if (top + popoverRect.height > viewportHeight - padding.bottom) {\n        top = viewportHeight - popoverRect.height - padding.bottom;\n      }\n    }\n\n    popoverRef.current.style.top = `${top}px`;\n    popoverRef.current.style.left = `${left}px`;\n  }, [placement, sideOffset, alignOffset, avoidCollisions, collisionPadding]);\n\n  useEffect(() => {\n    if (isOpen) {\n      updatePosition();\n      window.addEventListener('resize', updatePosition);\n      window.addEventListener('scroll', updatePosition);\n\n      return () => {\n        window.removeEventListener('resize', updatePosition);\n        window.removeEventListener('scroll', updatePosition);\n      };\n    }\n  }, [isOpen, updatePosition]);\n\n  const triggerElement = triggerAsChild ? (\n    React.cloneElement(trigger as React.ReactElement, {\n      ref: triggerRef,\n      onClick: handleTriggerClick,\n      'aria-haspopup': 'dialog',\n      'aria-expanded': isOpen,\n      'aria-controls': 'popover-content',\n    })\n  ) : (\n    <button\n      ref={triggerRef as React.RefObject<HTMLButtonElement>}\n      onClick={handleTriggerClick}\n      aria-haspopup=\"dialog\"\n      aria-expanded={isOpen}\n      aria-controls=\"popover-content\"\n      className=\"inline-flex items-center justify-center\"\n    >\n      {trigger}\n    </button>\n  );\n\n  return (\n    <>\n      {triggerElement}\n      {isOpen && createPortal(\n        <div\n          ref={popoverRef}\n          id=\"popover-content\"\n          role=\"dialog\"\n          aria-modal={modal}\n          className={popoverVariants({ placement, size, className })}\n          style={{\n            position: 'fixed',\n            opacity: 0,\n            transform: 'scale(0.95)',\n            animation: 'popover-in 150ms ease-out forwards',\n          }}\n        >\n          {children}\n        </div>,\n        document.body\n      )}\n      <style jsx>{`\n        @keyframes popover-in {\n          to {\n            opacity: 1;\n            transform: scale(1);\n          }\n        }\n      `}</style>\n    </>\n  );\n};\n\ninterface PopoverTriggerProps {\n  readonly children: React.ReactNode;\n  readonly asChild?: boolean;\n  readonly className?: string;\n}\n\nexport const PopoverTrigger = ({ children, asChild, className }: PopoverTriggerProps): JSX.Element => {\n  return <>{children}</>;\n};\n\ninterface PopoverContentProps {\n  readonly children: React.ReactNode;\n  readonly className?: string;\n}\n\nexport const PopoverContent = ({ children, className }: PopoverContentProps): JSX.Element => {\n  return (\n    <div className={`p-4 ${className || ''}`}>\n      {children}\n    </div>\n  );\n};\n\ninterface PopoverHeaderProps {\n  readonly children: React.ReactNode;\n  readonly className?: string;\n}\n\nexport const PopoverHeader = ({ children, className }: PopoverHeaderProps): JSX.Element => {\n  return (\n    <div className={`mb-4 ${className || ''}`}>\n      {children}\n    </div>\n  );\n};\n\ninterface PopoverCloseProps {\n  readonly children: React.ReactNode;\n  readonly className?: string;\n  readonly onClick?: () => void;\n}\n\nexport const PopoverClose = ({ children, className, onClick }: PopoverCloseProps): JSX.Element => {\n  return (\n    <button\n      onClick={onClick}\n      className={`absolute right-4 top-4 h-8 w-8 rounded-lg hover:bg-gray-100 flex items-center justify-center transition-colors ${className || ''}`}\n      aria-label=\"Close popover\"\n    >\n      {children}\n    </button>\n  );\n};"
    }
  ]
}