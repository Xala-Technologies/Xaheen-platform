{
  "$schema": "https://xaheen.io/schemas/registry-item.schema.json",
  "name": "hover-card",
  "type": "registry:component",
  "title": "Hover Card",
  "description": "Rich hover preview cards",
  "category": "components",
  "categories": [
    "components",
    "overlay",
    "display"
  ],
  "nsm": {
    "classification": "OPEN",
    "wcagLevel": "AAA",
    "norwegianOptimized": true
  },
  "platforms": [
    "react",
    "nextjs",
    "vue",
    "angular",
    "svelte",
    "electron",
    "ionic",
    "vanilla",
    "headless-ui",
    "radix"
  ],
  "dependencies": [
    "@radix-ui/react-hover-card"
  ],
  "registryDependencies": [
    "utils"
  ],
  "files": [
    {
      "path": "components/hover-card/hover-card.tsx",
      "type": "registry:component",
      "content": "import React, { useState, useCallback, useRef, useEffect } from 'react';\nimport { cva, type VariantProps } from 'class-variance-authority';\nimport { createPortal } from 'react-dom';\nimport { tokens } from '../../core/universal-tokens';\n\nconst hoverCardVariants = cva(\n  'absolute z-50 min-w-[8rem] overflow-hidden rounded-xl bg-white text-gray-900 shadow-lg border border-gray-200 outline-none transition-all duration-200',\n  {\n    variants: {\n      placement: {\n        top: 'bottom-full mb-2',\n        bottom: 'top-full mt-2',\n        left: 'right-full mr-2',\n        right: 'left-full ml-2',\n        'top-start': 'bottom-full mb-2 left-0',\n        'top-end': 'bottom-full mb-2 right-0',\n        'bottom-start': 'top-full mt-2 left-0',\n        'bottom-end': 'top-full mt-2 right-0',\n      },\n      size: {\n        sm: 'max-w-xs',\n        md: 'max-w-sm',\n        lg: 'max-w-md',\n        xl: 'max-w-lg',\n      },\n      state: {\n        closed: 'opacity-0 scale-95 pointer-events-none',\n        open: 'opacity-100 scale-100',\n      },\n    },\n    defaultVariants: {\n      placement: 'bottom',\n      size: 'md',\n      state: 'closed',\n    },\n  }\n);\n\ninterface HoverCardProps extends VariantProps<typeof hoverCardVariants> {\n  readonly children: React.ReactNode;\n  readonly trigger: React.ReactNode;\n  readonly content: React.ReactNode;\n  readonly open?: boolean;\n  readonly defaultOpen?: boolean;\n  readonly onOpenChange?: (open: boolean) => void;\n  readonly openDelay?: number;\n  readonly closeDelay?: number;\n  readonly className?: string;\n  readonly contentClassName?: string;\n  readonly side?: 'top' | 'bottom' | 'left' | 'right';\n  readonly sideOffset?: number;\n  readonly align?: 'start' | 'center' | 'end';\n  readonly alignOffset?: number;\n  readonly avoidCollisions?: boolean;\n  readonly collisionBoundary?: Element | null;\n  readonly collisionPadding?: number;\n  readonly arrow?: boolean;\n  readonly arrowClassName?: string;\n}\n\nexport const HoverCard = ({\n  children,\n  trigger,\n  content,\n  open: controlledOpen,\n  defaultOpen = false,\n  onOpenChange,\n  openDelay = 700,\n  closeDelay = 300,\n  className,\n  contentClassName,\n  placement,\n  size,\n  side = 'bottom',\n  sideOffset = 0,\n  align = 'center',\n  alignOffset = 0,\n  avoidCollisions = true,\n  collisionBoundary,\n  collisionPadding = 8,\n  arrow = false,\n  arrowClassName,\n}: HoverCardProps): JSX.Element => {\n  const [uncontrolledOpen, setUncontrolledOpen] = useState(defaultOpen);\n  const isOpen = controlledOpen !== undefined ? controlledOpen : uncontrolledOpen;\n  const [isVisible, setIsVisible] = useState(false);\n  \n  const triggerRef = useRef<HTMLElement>(null);\n  const contentRef = useRef<HTMLDivElement>(null);\n  const openTimeoutRef = useRef<NodeJS.Timeout>();\n  const closeTimeoutRef = useRef<NodeJS.Timeout>();\n  const isHoveringTrigger = useRef(false);\n  const isHoveringContent = useRef(false);\n\n  const handleOpenChange = useCallback((newOpen: boolean) => {\n    if (controlledOpen === undefined) {\n      setUncontrolledOpen(newOpen);\n    }\n    onOpenChange?.(newOpen);\n  }, [controlledOpen, onOpenChange]);\n\n  const scheduleOpen = useCallback(() => {\n    if (closeTimeoutRef.current) {\n      clearTimeout(closeTimeoutRef.current);\n    }\n    \n    if (!isOpen) {\n      openTimeoutRef.current = setTimeout(() => {\n        handleOpenChange(true);\n        setIsVisible(true);\n      }, openDelay);\n    }\n  }, [isOpen, openDelay, handleOpenChange]);\n\n  const scheduleClose = useCallback(() => {\n    if (openTimeoutRef.current) {\n      clearTimeout(openTimeoutRef.current);\n    }\n    \n    closeTimeoutRef.current = setTimeout(() => {\n      if (!isHoveringTrigger.current && !isHoveringContent.current) {\n        handleOpenChange(false);\n        setTimeout(() => setIsVisible(false), 200);\n      }\n    }, closeDelay);\n  }, [closeDelay, handleOpenChange]);\n\n  const handleTriggerEnter = useCallback(() => {\n    isHoveringTrigger.current = true;\n    scheduleOpen();\n  }, [scheduleOpen]);\n\n  const handleTriggerLeave = useCallback(() => {\n    isHoveringTrigger.current = false;\n    scheduleClose();\n  }, [scheduleClose]);\n\n  const handleContentEnter = useCallback(() => {\n    isHoveringContent.current = true;\n    if (closeTimeoutRef.current) {\n      clearTimeout(closeTimeoutRef.current);\n    }\n  }, []);\n\n  const handleContentLeave = useCallback(() => {\n    isHoveringContent.current = false;\n    scheduleClose();\n  }, [scheduleClose]);\n\n  const updatePosition = useCallback(() => {\n    if (!triggerRef.current || !contentRef.current || !isVisible) return;\n\n    const triggerRect = triggerRef.current.getBoundingClientRect();\n    const contentRect = contentRef.current.getBoundingClientRect();\n    const viewportWidth = window.innerWidth;\n    const viewportHeight = window.innerHeight;\n\n    let top = 0;\n    let left = 0;\n\n    // Calculate base position based on side and align\n    switch (side) {\n      case 'top':\n        top = triggerRect.top - contentRect.height - sideOffset;\n        left = align === 'start' \n          ? triggerRect.left + alignOffset\n          : align === 'end'\n          ? triggerRect.right - contentRect.width - alignOffset\n          : triggerRect.left + (triggerRect.width - contentRect.width) / 2;\n        break;\n      case 'bottom':\n        top = triggerRect.bottom + sideOffset;\n        left = align === 'start' \n          ? triggerRect.left + alignOffset\n          : align === 'end'\n          ? triggerRect.right - contentRect.width - alignOffset\n          : triggerRect.left + (triggerRect.width - contentRect.width) / 2;\n        break;\n      case 'left':\n        top = align === 'start'\n          ? triggerRect.top + alignOffset\n          : align === 'end'\n          ? triggerRect.bottom - contentRect.height - alignOffset\n          : triggerRect.top + (triggerRect.height - contentRect.height) / 2;\n        left = triggerRect.left - contentRect.width - sideOffset;\n        break;\n      case 'right':\n        top = align === 'start'\n          ? triggerRect.top + alignOffset\n          : align === 'end'\n          ? triggerRect.bottom - contentRect.height - alignOffset\n          : triggerRect.top + (triggerRect.height - contentRect.height) / 2;\n        left = triggerRect.right + sideOffset;\n        break;\n    }\n\n    // Apply collision detection\n    if (avoidCollisions) {\n      const padding = collisionPadding;\n\n      // Check horizontal collisions\n      if (left < padding) {\n        left = padding;\n      } else if (left + contentRect.width > viewportWidth - padding) {\n        left = viewportWidth - contentRect.width - padding;\n      }\n\n      // Check vertical collisions\n      if (top < padding) {\n        top = padding;\n      } else if (top + contentRect.height > viewportHeight - padding) {\n        top = viewportHeight - contentRect.height - padding;\n      }\n    }\n\n    contentRef.current.style.top = `${top}px`;\n    contentRef.current.style.left = `${left}px`;\n  }, [side, align, sideOffset, alignOffset, avoidCollisions, collisionPadding, isVisible]);\n\n  useEffect(() => {\n    if (isVisible) {\n      updatePosition();\n      window.addEventListener('resize', updatePosition);\n      window.addEventListener('scroll', updatePosition);\n\n      return () => {\n        window.removeEventListener('resize', updatePosition);\n        window.removeEventListener('scroll', updatePosition);\n      };\n    }\n  }, [isVisible, updatePosition]);\n\n  useEffect(() => {\n    return () => {\n      if (openTimeoutRef.current) {\n        clearTimeout(openTimeoutRef.current);\n      }\n      if (closeTimeoutRef.current) {\n        clearTimeout(closeTimeoutRef.current);\n      }\n    };\n  }, []);\n\n  const triggerElement = React.isValidElement(trigger) ? (\n    React.cloneElement(trigger, {\n      ref: triggerRef,\n      onMouseEnter: (e: React.MouseEvent) => {\n        trigger.props.onMouseEnter?.(e);\n        handleTriggerEnter();\n      },\n      onMouseLeave: (e: React.MouseEvent) => {\n        trigger.props.onMouseLeave?.(e);\n        handleTriggerLeave();\n      },\n      onFocus: (e: React.FocusEvent) => {\n        trigger.props.onFocus?.(e);\n        handleTriggerEnter();\n      },\n      onBlur: (e: React.FocusEvent) => {\n        trigger.props.onBlur?.(e);\n        handleTriggerLeave();\n      },\n      'aria-describedby': isOpen ? 'hover-card-content' : undefined,\n    })\n  ) : (\n    <span\n      ref={triggerRef as React.RefObject<HTMLSpanElement>}\n      onMouseEnter={handleTriggerEnter}\n      onMouseLeave={handleTriggerLeave}\n      onFocus={handleTriggerEnter}\n      onBlur={handleTriggerLeave}\n      className=\"inline-block\"\n      tabIndex={0}\n    >\n      {trigger}\n    </span>\n  );\n\n  return (\n    <>\n      {triggerElement}\n      {children}\n      {isVisible && createPortal(\n        <div\n          ref={contentRef}\n          id=\"hover-card-content\"\n          role=\"tooltip\"\n          onMouseEnter={handleContentEnter}\n          onMouseLeave={handleContentLeave}\n          className={hoverCardVariants({ \n            placement, \n            size, \n            state: isOpen ? 'open' : 'closed',\n            className: contentClassName \n          })}\n          style={{\n            position: 'fixed',\n            zIndex: 9999,\n          }}\n        >\n          {arrow && (\n            <div\n              className={`absolute h-2 w-2 rotate-45 bg-white border-l border-t border-gray-200 ${arrowClassName || ''}`}\n              style={{\n                [side === 'top' ? 'bottom' : side === 'bottom' ? 'top' : side === 'left' ? 'right' : 'left']: '-4px',\n                [side === 'top' || side === 'bottom' ? 'left' : 'top']: '50%',\n                transform: side === 'top' || side === 'bottom' \n                  ? 'translateX(-50%) rotate(45deg)' \n                  : 'translateY(-50%) rotate(45deg)',\n              }}\n            />\n          )}\n          <div className=\"relative p-4\">\n            {content}\n          </div>\n        </div>,\n        document.body\n      )}\n    </>\n  );\n};\n\ninterface HoverCardTriggerProps {\n  readonly children: React.ReactNode;\n  readonly asChild?: boolean;\n  readonly className?: string;\n}\n\nexport const HoverCardTrigger = ({ \n  children, \n  asChild, \n  className \n}: HoverCardTriggerProps): JSX.Element => {\n  if (asChild && React.isValidElement(children)) {\n    return children;\n  }\n\n  return (\n    <span className={`inline-block cursor-pointer ${className || ''}`}>\n      {children}\n    </span>\n  );\n};\n\ninterface HoverCardContentProps {\n  readonly children: React.ReactNode;\n  readonly className?: string;\n  readonly side?: 'top' | 'bottom' | 'left' | 'right';\n  readonly align?: 'start' | 'center' | 'end';\n  readonly sideOffset?: number;\n  readonly alignOffset?: number;\n}\n\nexport const HoverCardContent = ({ \n  children, \n  className,\n  side,\n  align,\n  sideOffset,\n  alignOffset \n}: HoverCardContentProps): JSX.Element => {\n  return <>{children}</>;\n};\n\ninterface HoverCardArrowProps {\n  readonly className?: string;\n  readonly width?: number;\n  readonly height?: number;\n}\n\nexport const HoverCardArrow = ({ \n  className, \n  width = 10, \n  height = 5 \n}: HoverCardArrowProps): JSX.Element => {\n  return (\n    <svg\n      width={width}\n      height={height}\n      viewBox={`0 0 ${width} ${height}`}\n      className={className}\n    >\n      <polygon\n        points={`0,${height} ${width / 2},0 ${width},${height}`}\n        fill=\"currentColor\"\n      />\n    </svg>\n  );\n};"
    }
  ]
}