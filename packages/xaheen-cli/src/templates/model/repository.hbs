/**
 * {{className}} Repository
 *
 * Generated by Xaheen CLI Model Generator
 * @since {{generatedAt}}
 */

import type {
  {{className}},
  Create{{className}}Input,
  Update{{className}}Input,
  {{className}}Repository as I{{className}}Repository,
  {{className}}ListResponse,
  FindManyOptions,
} from '../types/{{name}}.types.js';

/**
 * {{className}} Repository Implementation
 * 
 * This repository provides a data access layer for {{className}} entities.
 * It abstracts the underlying database operations and provides a clean API.
 */
export class {{className}}Repository implements I{{className}}Repository {
  constructor(
    private readonly db: any, // Replace with your database client type
  ) {}

  /**
   * Find a {{name}} by ID
   */
  async findById(id: string): Promise<{{className}} | null> {
    try {
      // TODO: Implement database query based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{name}}.findUnique({ where: { id } });
      
      // Example for Drizzle:
      // const result = await this.db.select().from({{name}}).where(eq({{name}}.id, id));
      // return result[0] || null;
      
      throw new Error('{{className}}Repository.findById not implemented');
    } catch (error) {
      throw new Error(`Failed to find {{name}} by ID: ${error}`);
    }
  }

  /**
   * Find multiple {{name}}s with optional filtering and pagination
   */
  async findMany(options: FindManyOptions = {}): Promise<{{className}}ListResponse> {
    try {
      const {
        page = 1,
        limit = 10,
        sortBy = 'createdAt',
        sortOrder = 'desc',
        filters = {},
        {{#if softDeletes}}
        includeDeleted = false,
        {{/if}}
      } = options;

      const offset = (page - 1) * limit;

      // TODO: Implement database query based on your ORM/database client
      // Example for Prisma:
      // const [data, total] = await Promise.all([
      //   this.db.{{name}}.findMany({
      //     where: { ...filters, {{#if softDeletes}}...(includeDeleted ? {} : { deletedAt: null }){{/if}} },
      //     orderBy: { [sortBy]: sortOrder },
      //     skip: offset,
      //     take: limit,
      //   }),
      //   this.db.{{name}}.count({ where: { ...filters, {{#if softDeletes}}...(includeDeleted ? {} : { deletedAt: null }){{/if}} } }),
      // ]);

      // Temporary mock data - replace with actual database query
      const data: {{className}}[] = [];
      const total = 0;

      return {
        data,
        total,
        page,
        limit,
        hasNext: offset + limit < total,
        hasPrev: page > 1,
      };
    } catch (error) {
      throw new Error(`Failed to find {{name}}s: ${error}`);
    }
  }

  /**
   * Create a new {{name}}
   */
  async create(input: Create{{className}}Input): Promise<{{className}}> {
    try {
      // TODO: Implement database create based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{name}}.create({ data: input });
      
      // Example for Drizzle:
      // const result = await this.db.insert({{name}}).values(input).returning();
      // return result[0];
      
      throw new Error('{{className}}Repository.create not implemented');
    } catch (error) {
      throw new Error(`Failed to create {{name}}: ${error}`);
    }
  }

  /**
   * Update an existing {{name}}
   */
  async update(id: string, input: Update{{className}}Input): Promise<{{className}} | null> {
    try {
      // TODO: Implement database update based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{name}}.update({
      //   where: { id },
      //   data: { ...input, updatedAt: new Date() },
      // });
      
      // Example for Drizzle:
      // const result = await this.db.update({{name}})
      //   .set({ ...input, updatedAt: new Date() })
      //   .where(eq({{name}}.id, id))
      //   .returning();
      // return result[0] || null;
      
      throw new Error('{{className}}Repository.update not implemented');
    } catch (error) {
      throw new Error(`Failed to update {{name}}: ${error}`);
    }
  }

  /**
   * Delete a {{name}}{{#if softDeletes}} (soft delete){{/if}}
   */
  async delete(id: string): Promise<boolean> {
    try {
      {{#if softDeletes}}
      // Soft delete - mark as deleted
      const result = await this.update(id, { deletedAt: new Date() } as Update{{className}}Input);
      return result !== null;
      {{else}}
      // TODO: Implement database delete based on your ORM/database client
      // Example for Prisma:
      // await this.db.{{name}}.delete({ where: { id } });
      
      // Example for Drizzle:
      // const result = await this.db.delete({{name}}).where(eq({{name}}.id, id));
      // return result.rowCount > 0;
      
      throw new Error('{{className}}Repository.delete not implemented');
      {{/if}}
    } catch (error) {
      throw new Error(`Failed to delete {{name}}: ${error}`);
    }
  }

  {{#if softDeletes}}
  /**
   * Restore a soft-deleted {{name}}
   */
  async restore(id: string): Promise<{{className}} | null> {
    try {
      return await this.update(id, { deletedAt: null } as Update{{className}}Input);
    } catch (error) {
      throw new Error(`Failed to restore {{name}}: ${error}`);
    }
  }

  /**
   * Permanently delete a {{name}} (hard delete)
   */
  async forceDelete(id: string): Promise<boolean> {
    try {
      // TODO: Implement database delete based on your ORM/database client
      // Example for Prisma:
      // await this.db.{{name}}.delete({ where: { id } });
      
      // Example for Drizzle:
      // const result = await this.db.delete({{name}}).where(eq({{name}}.id, id));
      // return result.rowCount > 0;
      
      throw new Error('{{className}}Repository.forceDelete not implemented');
    } catch (error) {
      throw new Error(`Failed to force delete {{name}}: ${error}`);
    }
  }
  {{/if}}

  /**
   * Check if a {{name}} exists
   */
  async exists(id: string): Promise<boolean> {
    try {
      const {{name}} = await this.findById(id);
      return {{name}} !== null;
    } catch (error) {
      throw new Error(`Failed to check if {{name}} exists: ${error}`);
    }
  }

  /**
   * Count {{name}}s with optional filters
   */
  async count(filters: Partial<{{className}}> = {}): Promise<number> {
    try {
      // TODO: Implement database count based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{name}}.count({ where: filters });
      
      // Example for Drizzle:
      // const result = await this.db.select({ count: sql`count(*)` })
      //   .from({{name}})
      //   .where(and(...Object.entries(filters).map(([key, value]) => eq({{name}}[key], value))));
      // return Number(result[0].count);
      
      throw new Error('{{className}}Repository.count not implemented');
    } catch (error) {
      throw new Error(`Failed to count {{name}}s: ${error}`);
    }
  }

  /**
   * Find {{name}}s by specific field
   */
  {{#each fields}}
  {{#if (eq name 'email')}}
  async findByEmail(email: string): Promise<{{../className}} | null> {
    try {
      // TODO: Implement database query based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{../name}}.findUnique({ where: { email } });
      
      throw new Error('{{../className}}Repository.findByEmail not implemented');
    } catch (error) {
      throw new Error(`Failed to find {{../name}} by email: ${error}`);
    }
  }
  {{/if}}
  {{/each}}

  /**
   * Search {{name}}s by text (if applicable)
   */
  async search(query: string, options: FindManyOptions = {}): Promise<{{className}}ListResponse> {
    try {
      // TODO: Implement full-text search based on your database capabilities
      // This is a placeholder implementation
      const searchFilters = {
        // Add text search logic for relevant fields
        {{#each fields}}
        {{#if (or (eq type 'string') (eq type 'text') (eq type 'email'))}}
        // {{name}}: { contains: query, mode: 'insensitive' }, // Prisma example
        {{/if}}
        {{/each}}
      };

      return await this.findMany({ ...options, filters: searchFilters });
    } catch (error) {
      throw new Error(`Failed to search {{name}}s: ${error}`);
    }
  }

  /**
   * Bulk operations
   */
  async createMany(inputs: Create{{className}}Input[]): Promise<{{className}}[]> {
    try {
      // TODO: Implement bulk create based on your ORM/database client
      // Example for Prisma:
      // return await this.db.{{name}}.createMany({ data: inputs, skipDuplicates: true });
      
      throw new Error('{{className}}Repository.createMany not implemented');
    } catch (error) {
      throw new Error(`Failed to create multiple {{name}}s: ${error}`);
    }
  }

  async updateMany(filters: Partial<{{className}}>, input: Update{{className}}Input): Promise<number> {
    try {
      // TODO: Implement bulk update based on your ORM/database client
      // Example for Prisma:
      // const result = await this.db.{{name}}.updateMany({ where: filters, data: input });
      // return result.count;
      
      throw new Error('{{className}}Repository.updateMany not implemented');
    } catch (error) {
      throw new Error(`Failed to update multiple {{name}}s: ${error}`);
    }
  }

  async deleteMany(filters: Partial<{{className}}>): Promise<number> {
    try {
      {{#if softDeletes}}
      // Soft delete multiple records
      return await this.updateMany(filters, { deletedAt: new Date() } as Update{{className}}Input);
      {{else}}
      // TODO: Implement bulk delete based on your ORM/database client
      // Example for Prisma:
      // const result = await this.db.{{name}}.deleteMany({ where: filters });
      // return result.count;
      
      throw new Error('{{className}}Repository.deleteMany not implemented');
      {{/if}}
    } catch (error) {
      throw new Error(`Failed to delete multiple {{name}}s: ${error}`);
    }
  }
}