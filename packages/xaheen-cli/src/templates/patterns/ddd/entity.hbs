/**
 * {{pascalCase name}} Entity
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - DDD Pattern Generator
 */

import { Entity } from '../base/entity.base';
import { {{pascalCase name}}Id } from '../value-objects/{{kebabCase name}}-id.value-object';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}

{{#if interfaces}}
{{#each interfaces}}
export interface {{this}} {
  // TODO: Define interface methods
}
{{/each}}
{{/if}}

export class {{pascalCase name}} extends Entity<{{pascalCase name}}Id> {
  {{#each fields}}
  private _{{name}}: {{type}};
  {{/each}}

  {{#each relationships}}
  private _{{name}}: {{target}}{{#if (eq type 'one-to-many')}}[]{{/if}}{{#if (eq type 'many-to-many')}}[]{{/if}};
  {{/each}}

  constructor(
    id: {{pascalCase name}}Id,
    {{#each fields}}
    {{name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {
    super(id);
    {{#each fields}}
    this._{{name}} = {{name}};
    {{/each}}
    
    this.validate();
  }

  {{#each fields}}
  get {{name}}(): {{type}} {
    return this._{{name}};
  }
  {{#unless isReadonly}}

  set {{name}}(value: {{type}}) {
    {{#if validation}}
    // Validation: {{#each validation}}{{message}}{{#unless @last}}, {{/unless}}{{/each}}
    {{/if}}
    this._{{name}} = value;
    this.validate();
  }
  {{/unless}}

  {{/each}}

  {{#each relationships}}
  get {{name}}(): {{target}}{{#if (eq type 'one-to-many')}}[]{{/if}}{{#if (eq type 'many-to-many')}}[]{{/if}} {
    return this._{{name}};
  }

  {{#if (eq type 'one-to-many')}}
  add{{pascalCase (singularize name)}}({{singularize name}}: {{target}}): void {
    this._{{name}}.push({{singularize name}});
    this.validate();
  }

  remove{{pascalCase (singularize name)}}({{singularize name}}Id: string): void {
    this._{{name}} = this._{{name}}.filter(item => item.id.value !== {{singularize name}}Id);
  }
  {{/if}}

  {{/each}}

  // Business methods
  update{{pascalCase name}}(
    {{#each fields}}
    {{name}}?: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ): void {
    {{#each fields}}
    if ({{name}} !== undefined) {
      this._{{name}} = {{name}};
    }
    {{/each}}
    
    this.validate();
    this.recordDomainEvent(new {{pascalCase name}}UpdatedEvent(this.id, {
      {{#each fields}}
      {{name}}: this._{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    }));
  }

  {{#each businessMethods}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if businessRules}}
    // Business rules validation
    {{#each businessRules}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}
    {{/if}}

    // TODO: Implement {{name}} business logic
    {{#if events}}
    // Record domain event
    {{#each events}}
    this.recordDomainEvent(new {{this}}(this.id, { /* event data */ }));
    {{/each}}
    {{/if}}
  }

  {{/each}}

  private validate(): void {
    {{#each invariants}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}

    {{#each fields}}
    {{#if isRequired}}
    if (!this._{{name}}) {
      throw new DomainError('{{pascalCase name}} is required');
    }
    {{/if}}
    {{#if validation}}
    {{#each validation}}
    {{#if (eq type 'minLength')}}
    if (this._{{../name}}.length < {{value}}) {
      throw new DomainError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'maxLength')}}
    if (this._{{../name}}.length > {{value}}) {
      throw new DomainError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'pattern')}}
    if (!new RegExp('{{value}}').test(this._{{../name}})) {
      throw new DomainError('{{message}}');
    }
    {{/if}}
    {{/each}}
    {{/if}}
    {{/each}}
  }

  static create(
    {{#each fields}}
    {{name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ): {{pascalCase name}} {
    const id = {{pascalCase name}}Id.generate();
    const entity = new {{pascalCase name}}(
      id,
      {{#each fields}}
      {{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    );

    entity.recordDomainEvent(new {{pascalCase name}}CreatedEvent(id, {
      {{#each fields}}
      {{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    }));

    return entity;
  }

  toPrimitives(): any {
    return {
      id: this.id.value,
      {{#each fields}}
      {{name}}: this._{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
  }
}

{{#if events}}
// Domain Events
{{#each events}}
export class {{pascalCase name}}Event extends DomainEvent {
  constructor(
    aggregateId: {{../pascalCase ../name}}Id,
    payload: {
      {{#each ../fields}}
      {{name}}: {{type}};
      {{/each}}
    }
  ) {
    super('{{kebabCase name}}', aggregateId.value, payload);
  }
}

{{/each}}
{{/if}}