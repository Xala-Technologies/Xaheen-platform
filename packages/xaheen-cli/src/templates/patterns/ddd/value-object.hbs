/**
 * {{pascalCase name}} Value Object
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - DDD Pattern Generator
 */

import { ValueObject } from '../base/value-object.base';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}

export interface {{pascalCase name}}Props {
  {{#each fields}}
  readonly {{name}}: {{type}};
  {{/each}}
}

export class {{pascalCase name}} extends ValueObject<{{pascalCase name}}Props> {
  constructor(props: {{pascalCase name}}Props) {
    super(props);
    this.validate();
  }

  {{#each fields}}
  get {{name}}(): {{type}} {
    return this.props.{{name}};
  }

  {{/each}}

  private validate(): void {
    {{#each validationRules}}
    {{#if (eq type 'required')}}
    {{#each ../fields}}
    {{#if isRequired}}
    if (!this.props.{{name}}) {
      throw new Error('{{name}} is required');
    }
    {{/if}}
    {{/each}}
    {{/if}}
    {{/each}}

    {{#each fields}}
    {{#if validation}}
    {{#each validation}}
    {{#if (eq type 'minLength')}}
    if (this.props.{{../name}}.length < {{value}}) {
      throw new Error('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'maxLength')}}
    if (this.props.{{../name}}.length > {{value}}) {
      throw new Error('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'pattern')}}
    if (!new RegExp('{{value}}').test(this.props.{{../name}})) {
      throw new Error('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'range')}}
    if (this.props.{{../name}} < {{min}} || this.props.{{../name}} > {{max}}) {
      throw new Error('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'custom')}}
    if ({{condition}}) {
      throw new Error('{{message}}');
    }
    {{/if}}
    {{/each}}
    {{/if}}
    {{/each}}

    {{#each businessRules}}
    if ({{condition}}) {
      throw new Error('{{message}}');
    }
    {{/each}}
  }

  {{#each methods}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if businessLogic}}
    {{businessLogic}}
    {{else}}
    // TODO: Implement {{name}} method
    {{/if}}
  }

  {{/each}}

  // Equality comparison
  equals(other: {{pascalCase name}}): boolean {
    if (!other) {
      return false;
    }

    if (!(other instanceof {{pascalCase name}})) {
      return false;
    }

    return this.props.{{#each fields}}{{name}} === other.props.{{name}}{{#unless @last}} && this.props.{{/unless}}{{/each}};
  }

  // Hash code for collections
  hashCode(): string {
    return `{{kebabCase name}}-${
      {{#each fields}}
      this.props.{{name}}{{#unless @last}} + '-' + {{/unless}}
      {{/each}}
    }`;
  }

  // String representation
  toString(): string {
    return `{{pascalCase name}}(${JSON.stringify(this.props)})`;
  }

  // Serialization
  toJSON(): {{pascalCase name}}Props {
    return {
      {{#each fields}}
      {{name}}: this.props.{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
  }

  // Factory methods
  static create(props: {{pascalCase name}}Props): {{pascalCase name}} {
    return new {{pascalCase name}}(props);
  }

  {{#each factoryMethods}}
  static {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{../pascalCase ../name}} {
    {{#if validation}}
    // Validation
    {{#each validation}}
    if ({{condition}}) {
      throw new Error('{{message}}');
    }
    {{/each}}
    {{/if}}

    return new {{../pascalCase ../name}}({
      {{#each mapping}}
      {{property}}: {{value}}{{#unless @last}},{{/unless}}
      {{/each}}
    });
  }

  {{/each}}

  // Transformation methods
  {{#each transformations}}
  to{{pascalCase name}}(): {{returnType}} {
    return {{#if logic}}{{logic}}{{else}}{
      {{#each mapping}}
      {{property}}: {{#if transformation}}{{transformation}}{{else}}this.props.{{sourceProperty}}{{/if}}{{#unless @last}},{{/unless}}
      {{/each}}
    }{{/if}};
  }

  {{/each}}

  // Immutable update methods
  {{#each fields}}
  {{#unless isImmutable}}
  with{{pascalCase name}}({{name}}: {{type}}): {{../pascalCase ../name}} {
    return new {{../pascalCase ../name}}({
      ...this.props,
      {{name}}: {{name}}
    });
  }
  {{/unless}}

  {{/each}}

  // Copy with partial updates
  copyWith(updates: Partial<{{pascalCase name}}Props>): {{pascalCase name}} {
    return new {{pascalCase name}}({
      ...this.props,
      ...updates
    });
  }

  // Validation methods
  isValid(): boolean {
    try {
      this.validate();
      return true;
    } catch {
      return false;
    }
  }

  getValidationErrors(): string[] {
    const errors: string[] = [];
    
    try {
      this.validate();
    } catch (error) {
      if (error instanceof Error) {
        errors.push(error.message);
      }
    }
    
    return errors;
  }

  {{#if comparable}}
  // Comparison methods (for comparable value objects)
  compareTo(other: {{pascalCase name}}): number {
    {{#each fields}}
    {{#if isComparable}}
    if (this.props.{{name}} < other.props.{{name}}) return -1;
    if (this.props.{{name}} > other.props.{{name}}) return 1;
    {{/if}}
    {{/each}}
    return 0;
  }

  isLessThan(other: {{pascalCase name}}): boolean {
    return this.compareTo(other) < 0;
  }

  isGreaterThan(other: {{pascalCase name}}): boolean {
    return this.compareTo(other) > 0;
  }

  isLessThanOrEqual(other: {{pascalCase name}}): boolean {
    return this.compareTo(other) <= 0;
  }

  isGreaterThanOrEqual(other: {{pascalCase name}}): boolean {
    return this.compareTo(other) >= 0;
  }
  {{/if}}
}

{{#if hasIdValueObject}}
// ID Value Object for {{name}}
export class {{pascalCase name}}Id extends ValueObject<{ value: string }> {
  constructor(value: string) {
    super({ value });
    this.validate();
  }

  get value(): string {
    return this.props.value;
  }

  private validate(): void {
    if (!this.props.value) {
      throw new Error('{{pascalCase name}}Id cannot be empty');
    }
    
    if (typeof this.props.value !== 'string') {
      throw new Error('{{pascalCase name}}Id must be a string');
    }
  }

  static generate(): {{pascalCase name}}Id {
    return new {{pascalCase name}}Id(crypto.randomUUID());
  }

  static fromString(id: string): {{pascalCase name}}Id {
    return new {{pascalCase name}}Id(id);
  }

  toString(): string {
    return this.props.value;
  }

  equals(other: {{pascalCase name}}Id): boolean {
    return other instanceof {{pascalCase name}}Id && this.props.value === other.props.value;
  }
}
{{/if}}