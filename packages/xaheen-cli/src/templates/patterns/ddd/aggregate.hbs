/**
 * {{pascalCase name}} Aggregate Root
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - DDD Pattern Generator
 */

import { AggregateRoot } from '@nestjs/cqrs';
import { {{pascalCase name}}Id } from './{{kebabCase name}}-id.value-object';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}
{{#each events}}
import { {{pascalCase name}}Event } from '../events/{{kebabCase name}}.event';
{{/each}}

export class {{pascalCase name}} extends AggregateRoot {
  private readonly _id: {{pascalCase name}}Id;
  private _version: number = 0;
  {{#each fields}}
  private _{{name}}: {{type}};
  {{/each}}

  {{#each entities}}
  private _{{name}}: {{type}}{{#if isCollection}}[]{{/if}};
  {{/each}}

  constructor(
    id: {{pascalCase name}}Id,
    {{#each fields}}
    {{name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {
    super();
    this._id = id;
    {{#each fields}}
    this._{{name}} = {{name}};
    {{/each}}
    
    // Initialize entities
    {{#each entities}}
    {{#if isCollection}}
    this._{{name}} = [];
    {{else}}
    this._{{name}} = {{#if defaultValue}}{{defaultValue}}{{else}}null{{/if}};
    {{/if}}
    {{/each}}
    
    // Enforce business invariants
    this.enforceInvariants();
  }

  get id(): {{pascalCase name}}Id {
    return this._id;
  }

  get version(): number {
    return this._version;
  }

  {{#each fields}}
  get {{name}}(): {{type}} {
    return this._{{name}};
  }

  {{/each}}

  {{#each entities}}
  get {{name}}(): {{type}}{{#if isCollection}}[]{{/if}} {
    return this._{{name}};
  }

  {{#if isCollection}}
  add{{pascalCase (singularize name)}}({{singularize name}}: {{type}}): void {
    // Business rule validation
    {{#each businessRules}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}

    this._{{name}}.push({{singularize name}});
    this.enforceInvariants();
    
    this.apply(new {{pascalCase (singularize name)}}AddedEvent(this._id, {{singularize name}}.id));
  }

  remove{{pascalCase (singularize name)}}({{singularize name}}Id: string): void {
    const index = this._{{name}}.findIndex(item => item.id.value === {{singularize name}}Id);
    if (index === -1) {
      throw new DomainError('{{pascalCase (singularize name)}} not found');
    }

    const removed{{pascalCase (singularize name)}} = this._{{name}}[index];
    this._{{name}}.splice(index, 1);
    
    this.apply(new {{pascalCase (singularize name)}}RemovedEvent(this._id, removed{{pascalCase (singularize name)}}.id));
  }
  {{/if}}

  {{/each}}

  {{#each commands}}
  {{camelCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): void {
    {{#if businessRules}}
    // Business rules validation
    {{#each businessRules}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}
    {{/if}}

    {{#if guard}}
    // Guard clause
    if ({{guard.condition}}) {
      throw new DomainError('{{guard.message}}');
    }
    {{/if}}

    // Execute command logic
    {{#each stateChanges}}
    this._{{property}} = {{value}};
    {{/each}}

    // Enforce invariants after state change
    this.enforceInvariants();

    // Apply domain event
    this.apply(new {{pascalCase ../name}}{{pascalCase name}}Event(
      this._id,
      {
        {{#each parameters}}
        {{name}}{{#unless @last}},{{/unless}}
        {{/each}}
      }
    ));
  }

  {{/each}}

  {{#each businessMethods}}
  {{camelCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if businessRules}}
    // Business rules
    {{#each businessRules}}
    if ({{condition}}) {
      {{#if action}}
      {{action}};
      {{else}}
      throw new DomainError('{{message}}');
      {{/if}}
    }
    {{/each}}
    {{/if}}

    // TODO: Implement {{name}} business logic
    
    {{#if events}}
    // Apply domain events
    {{#each events}}
    this.apply(new {{this}}(this._id, { /* event data */ }));
    {{/each}}
    {{/if}}
  }

  {{/each}}

  private enforceInvariants(): void {
    {{#each invariants}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}

    {{#each businessRules}}
    if ({{condition}}) {
      throw new DomainError('{{message}}');
    }
    {{/each}}
  }

  {{#each events}}
  // Event application method for {{name}}
  on{{pascalCase name}}(event: {{pascalCase name}}Event): void {
    {{#each stateChanges}}
    this._{{property}} = event.payload.{{sourceProperty}};
    {{/each}}
    this._version++;
  }

  {{/each}}

  // Factory method
  static create(
    {{#each fields}}
    {{name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ): {{pascalCase name}} {
    const id = {{pascalCase name}}Id.generate();
    const aggregate = new {{pascalCase name}}(
      id,
      {{#each fields}}
      {{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    );

    aggregate.apply(new {{pascalCase name}}CreatedEvent(id, {
      {{#each fields}}
      {{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    }));

    return aggregate;
  }

  // Reconstruction from events
  static fromHistory(id: {{pascalCase name}}Id, events: DomainEvent[]): {{pascalCase name}} {
    const aggregate = new {{pascalCase name}}(id, /* initial state */);
    
    events.forEach(event => {
      switch (event.eventType) {
        {{#each events}}
        case '{{kebabCase name}}':
          aggregate.on{{pascalCase name}}(event as {{pascalCase name}}Event);
          break;
        {{/each}}
        default:
          // Unknown event type
          break;
      }
    });

    aggregate.clearEvents();
    return aggregate;
  }

  // Snapshot for performance
  toSnapshot(): {{pascalCase name}}Snapshot {
    return {
      id: this._id.value,
      version: this._version,
      {{#each fields}}
      {{name}}: this._{{name}},
      {{/each}}
      {{#each entities}}
      {{name}}: this._{{name}}{{#if isCollection}}.map(item => item.toSnapshot()){{else}}?.toSnapshot(){{/if}},
      {{/each}}
      snapshotVersion: 1,
      createdAt: new Date(),
    };
  }

  static fromSnapshot(snapshot: {{pascalCase name}}Snapshot): {{pascalCase name}} {
    const aggregate = new {{pascalCase name}}(
      {{pascalCase name}}Id.fromString(snapshot.id),
      {{#each fields}}
      snapshot.{{name}}{{#unless @last}},{{/unless}}
      {{/each}}
    );
    
    aggregate._version = snapshot.version;
    
    {{#each entities}}
    {{#if isCollection}}
    aggregate._{{name}} = snapshot.{{name}}.map(item => {{type}}.fromSnapshot(item));
    {{else}}
    aggregate._{{name}} = snapshot.{{name}} ? {{type}}.fromSnapshot(snapshot.{{name}}) : null;
    {{/if}}
    {{/each}}

    return aggregate;
  }
}

// Snapshot interface
export interface {{pascalCase name}}Snapshot {
  id: string;
  version: number;
  {{#each fields}}
  {{name}}: {{type}};
  {{/each}}
  {{#each entities}}
  {{name}}: {{#if isCollection}}any[]{{else}}any | null{{/if}};
  {{/each}}
  snapshotVersion: number;
  createdAt: Date;
}