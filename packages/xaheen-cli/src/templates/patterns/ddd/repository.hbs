/**
 * {{pascalCase name}} Repository
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - DDD Pattern Generator
 */

import { Injectable } from '@nestjs/common';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}
import { {{pascalCase entityName}} } from '../entities/{{kebabCase entityName}}.entity';
import { {{pascalCase entityName}}Id } from '../value-objects/{{kebabCase entityName}}-id.value-object';

// Repository Interface (Domain Layer)
export interface I{{pascalCase name}}Repository {
  {{#each methods}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{#if isAsync}}Promise<{{/if}}{{returnType}}{{#if isAsync}}>{{/if}};
  {{/each}}

  // Standard CRUD operations
  findById(id: {{pascalCase entityName}}Id): Promise<{{pascalCase entityName}} | null>;
  findAll(): Promise<{{pascalCase entityName}}[]>;
  save(entity: {{pascalCase entityName}}): Promise<{{pascalCase entityName}}>;
  delete(id: {{pascalCase entityName}}Id): Promise<void>;
  exists(id: {{pascalCase entityName}}Id): Promise<boolean>;

  {{#if hasCustomQueries}}
  // Custom queries
  {{#each customQueries}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}>;
  {{/each}}
  {{/if}}

  {{#if hasSpecifications}}
  // Specification-based queries
  {{#each specifications}}
  findBy{{pascalCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{../pascalCase ../entityName}}[]>;
  {{/each}}
  {{/if}}
}

// Repository Implementation (Infrastructure Layer)
@Injectable()
export class {{pascalCase name}}Repository implements I{{pascalCase name}}Repository {
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {}

  async findById(id: {{pascalCase entityName}}Id): Promise<{{pascalCase entityName}} | null> {
    {{#if implementation.findById}}
    {{implementation.findById}}
    {{else}}
    // TODO: Implement database query to find by ID
    // Example for TypeORM:
    // const record = await this.entityRepository.findOne({ where: { id: id.value } });
    // return record ? this.toDomain(record) : null;
    
    // Example for Prisma:
    // const record = await this.prisma.{{camelCase entityName}}.findUnique({ where: { id: id.value } });
    // return record ? this.toDomain(record) : null;
    
    throw new Error('Method not implemented');
    {{/if}}
  }

  async findAll(): Promise<{{pascalCase entityName}}[]> {
    {{#if implementation.findAll}}
    {{implementation.findAll}}
    {{else}}
    // TODO: Implement database query to find all
    // Example for TypeORM:
    // const records = await this.entityRepository.find();
    // return records.map(record => this.toDomain(record));
    
    // Example for Prisma:
    // const records = await this.prisma.{{camelCase entityName}}.findMany();
    // return records.map(record => this.toDomain(record));
    
    throw new Error('Method not implemented');
    {{/if}}
  }

  async save(entity: {{pascalCase entityName}}): Promise<{{pascalCase entityName}}> {
    {{#if implementation.save}}
    {{implementation.save}}
    {{else}}
    // TODO: Implement database save operation
    // Example for TypeORM:
    // const record = this.toRecord(entity);
    // const saved = await this.entityRepository.save(record);
    // return this.toDomain(saved);
    
    // Example for Prisma:
    // const data = this.toRecord(entity);
    // const saved = await this.prisma.{{camelCase entityName}}.upsert({
    //   where: { id: entity.id.value },
    //   create: data,
    //   update: data
    // });
    // return this.toDomain(saved);
    
    throw new Error('Method not implemented');
    {{/if}}
  }

  async delete(id: {{pascalCase entityName}}Id): Promise<void> {
    {{#if implementation.delete}}
    {{implementation.delete}}
    {{else}}
    // TODO: Implement database delete operation  
    // Example for TypeORM:
    // await this.entityRepository.delete({ id: id.value });
    
    // Example for Prisma:
    // await this.prisma.{{camelCase entityName}}.delete({ where: { id: id.value } });
    
    throw new Error('Method not implemented');
    {{/if}}
  }

  async exists(id: {{pascalCase entityName}}Id): Promise<boolean> {
    {{#if implementation.exists}}
    {{implementation.exists}}
    {{else}}
    // TODO: Implement existence check
    // Example for TypeORM:
    // const count = await this.entityRepository.count({ where: { id: id.value } });
    // return count > 0;
    
    // Example for Prisma:
    // const record = await this.prisma.{{camelCase entityName}}.findUnique({ 
    //   where: { id: id.value },
    //   select: { id: true }
    // });
    // return !!record;
    
    throw new Error('Method not implemented');
    {{/if}}
  }

  {{#if hasCustomQueries}}
  // Custom query implementations
  {{#each customQueries}}
  async {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}> {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement {{name}} query
    {{#if query}}
    // Query: {{query}}
    {{/if}}
    {{#if description}}
    // {{description}}
    {{/if}}
    throw new Error('Method not implemented');
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if hasSpecifications}}
  // Specification-based query implementations
  {{#each specifications}}
  async findBy{{pascalCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{../pascalCase ../entityName}}[]> {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement specification-based query for {{name}}
    // Use the specification pattern to build dynamic queries
    // const spec = new {{pascalCase name}}Specification({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
    // const records = await this.findBySpecification(spec);
    // return records.map(record => this.toDomain(record));
    throw new Error('Method not implemented');
    {{/if}}
  }

  {{/each}}

  // Generic specification support
  private async findBySpecification(specification: Specification<any>): Promise<any[]> {
    // TODO: Implement specification-to-query translation
    // This would typically involve:
    // 1. Parse the specification into database query criteria
    // 2. Execute the query
    // 3. Return the results
    throw new Error('Specification support not implemented');
  }
  {{/if}}

  {{#each methods}}
  async {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{#if isAsync}}Promise<{{/if}}{{returnType}}{{#if isAsync}}>{{/if}} {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement {{name}}
    {{#if description}}
    // {{description}}
    {{/if}}
    {{#unless (eq returnType 'void')}}
    throw new Error('Method not implemented');
    {{/unless}}
    {{/if}}
  }

  {{/each}}

  {{#if hasTransactions}}
  // Transaction support
  async transaction<T>(work: (repository: I{{pascalCase name}}Repository) => Promise<T>): Promise<T> {
    // TODO: Implement transaction support
    // Example for TypeORM:
    // return await this.dataSource.transaction(async manager => {
    //   const transactionalRepo = new {{pascalCase name}}Repository(manager.getRepository({{pascalCase entityName}}Entity));
    //   return await work(transactionalRepo);  
    // });
    
    // Example for Prisma:
    // return await this.prisma.$transaction(async prisma => {
    //   const transactionalRepo = new {{pascalCase name}}Repository(prisma);
    //   return await work(transactionalRepo);
    // });
    
    throw new Error('Transaction support not implemented');
  }
  {{/if}}

  {{#if hasCaching}}
  // Caching support
  private getCacheKey(key: string): string {
    return `{{kebabCase name}}:${key}`;
  }

  private async getFromCache<T>(key: string): Promise<T | null> {
    // TODO: Implement cache retrieval
    // Example with Redis:
    // const cached = await this.redis.get(this.getCacheKey(key));
    // return cached ? JSON.parse(cached) : null;
    return null;
  }

  private async setCache<T>(key: string, value: T, ttl: number = 300): Promise<void> {
    // TODO: Implement cache storage
    // Example with Redis:
    // await this.redis.setex(this.getCacheKey(key), ttl, JSON.stringify(value));
  }

  private async invalidateCache(pattern: string): Promise<void> {
    // TODO: Implement cache invalidation
    // Example with Redis:
    // const keys = await this.redis.keys(this.getCacheKey(pattern));
    // if (keys.length > 0) {
    //   await this.redis.del(...keys);
    // }
  }
  {{/if}}

  // Mapping methods
  private toDomain(record: any): {{pascalCase entityName}} {
    {{#if mapping.toDomain}}
    {{mapping.toDomain}}
    {{else}}
    // TODO: Map database record to domain entity
    // return new {{pascalCase entityName}}(
    //   {{pascalCase entityName}}Id.fromString(record.id),
    //   record.field1,
    //   record.field2,
    //   // ... other fields
    // );
    throw new Error('Domain mapping not implemented');
    {{/if}}
  }

  private toRecord(entity: {{pascalCase entityName}}): any {
    {{#if mapping.toRecord}}
    {{mapping.toRecord}}
    {{else}}
    // TODO: Map domain entity to database record
    // return {
    //   id: entity.id.value,
    //   field1: entity.field1,
    //   field2: entity.field2,
    //   // ... other fields
    //   createdAt: entity.createdAt,
    //   updatedAt: new Date(),
    // };
    throw new Error('Record mapping not implemented');
    {{/if}}
  }

  {{#if hasAggregateMapping}}
  // Aggregate mapping with relationships
  private toDomainWithRelations(record: any): {{pascalCase entityName}} {
    const entity = this.toDomain(record);
    
    // TODO: Map related entities
    {{#each relationships}}
    // Map {{name}} relationship
    {{#if isCollection}}
    if (record.{{name}}) {
      entity.{{name}} = record.{{name}}.map(item => this.map{{pascalCase type}}(item));
    }
    {{else}}
    if (record.{{name}}) {
      entity.{{name}} = this.map{{pascalCase type}}(record.{{name}});
    }
    {{/if}}
    {{/each}}
    
    return entity;
  }

  {{#each relationships}}
  private map{{pascalCase type}}(record: any): {{type}} {
    // TODO: Map {{type}} from record
    throw new Error('{{type}} mapping not implemented');
  }

  {{/each}}
  {{/if}}

  {{#if hasEventSourcing}}
  // Event sourcing support
  async saveEvents(aggregateId: {{pascalCase entityName}}Id, events: DomainEvent[], expectedVersion: number): Promise<void> {
    // TODO: Implement event storage
    // Validate expected version
    // Store events atomically
    // Update aggregate version
    throw new Error('Event sourcing not implemented');
  }

  async getEvents(aggregateId: {{pascalCase entityName}}Id, fromVersion?: number): Promise<DomainEvent[]> {
    // TODO: Implement event retrieval
    // Load events for aggregate
    // Apply version filtering if specified
    // Return events in order
    throw new Error('Event sourcing not implemented');
  }

  async loadAggregate(id: {{pascalCase entityName}}Id): Promise<{{pascalCase entityName}} | null> {
    // TODO: Implement aggregate reconstruction from events
    // Load events for aggregate
    // Reconstruct aggregate from event history
    // Apply snapshot if available
    throw new Error('Event sourcing not implemented');
  }
  {{/if}}

  {{#if hasSnapshots}}
  // Snapshot support
  async saveSnapshot(aggregate: {{pascalCase entityName}}): Promise<void> {
    // TODO: Implement snapshot storage
    // Create snapshot from current aggregate state
    // Store snapshot with version information
    throw new Error('Snapshot support not implemented');
  }

  async loadSnapshot(id: {{pascalCase entityName}}Id): Promise<{{pascalCase entityName}}Snapshot | null> {
    // TODO: Implement snapshot loading
    // Load latest snapshot for aggregate
    // Return null if no snapshot exists
    throw new Error('Snapshot support not implemented');
  }
  {{/if}}
}

{{#if hasFactory}}
// Repository Factory
@Injectable()
export class {{pascalCase name}}RepositoryFactory {
  constructor(
    {{#each factoryDependencies}}
    private readonly {{camelCase name}}: {{type}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {}

  create{{pascalCase name}}Repository(): I{{pascalCase name}}Repository {
    return new {{pascalCase name}}Repository(
      {{#each factoryDependencies}}
      this.{{camelCase name}}{{#unless @last}},{{/unless}}
      {{/each}}
    );
  }

  {{#if hasReadOnlyRepository}}
  createReadOnly{{pascalCase name}}Repository(): I{{pascalCase name}}ReadOnlyRepository {
    // TODO: Create read-only repository for queries
    // This might use a read replica or specialized query implementation
    throw new Error('Read-only repository not implemented');
  }
  {{/if}}
}
{{/if}}

{{#if hasReadOnlyRepository}}
// Read-only repository interface for queries
export interface I{{pascalCase name}}ReadOnlyRepository {
  findById(id: {{pascalCase entityName}}Id): Promise<{{pascalCase entityName}} | null>;
  findAll(): Promise<{{pascalCase entityName}}[]>;
  {{#each customQueries}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}>;
  {{/each}}
}
{{/if}}