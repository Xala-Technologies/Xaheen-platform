/**
 * {{pascalCase name}} Use Case
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - Clean Architecture Generator
 */

import { Injectable } from '@nestjs/common';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}
import { {{inputType}} } from '../dto/{{kebabCase name}}-input.dto';
import { {{outputType}} } from '../dto/{{kebabCase name}}-output.dto';
{{#each dependencies}}
import { I{{pascalCase name}} } from '../interfaces/{{kebabCase name}}.interface';
{{/each}}

// Use Case Interface
export interface I{{pascalCase name}}UseCase {
  execute(input: {{inputType}}): Promise<{{outputType}}>;
}

@Injectable()
export class {{pascalCase name}}UseCase implements I{{pascalCase name}}UseCase {
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: I{{pascalCase name}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {}

  async execute(input: {{inputType}}): Promise<{{outputType}}> {
    {{#if validation}}
    // Input validation
    await this.validateInput(input);
    {{/if}}

    {{#if businessRules}}
    // Business rules validation
    {{#each businessRules}}
    if ({{condition}}) {
      throw new UseCaseError('{{message}}');
    }
    {{/each}}
    {{/if}}

    {{#if authorization}}
    // Authorization check
    await this.checkAuthorization(input);
    {{/if}}

    try {
      {{#if steps}}
      // Use case execution steps
      {{#each steps}}
      // Step {{@index}}: {{description}}
      {{#if condition}}
      if ({{condition}}) {
      {{/if}}
        {{#if isAsync}}await {{/if}}{{action}};
      {{#if condition}}
      }
      {{/if}}
      {{/each}}
      {{else}}
      // TODO: Implement use case logic
      {{#if entityOperations}}
      {{#each entityOperations}}
      {{#if (eq operation 'create')}}
      const {{camelCase entity}} = await this.{{camelCase entity}}Repository.create({{parameters}});
      {{/if}}
      {{#if (eq operation 'update')}}
      const {{camelCase entity}} = await this.{{camelCase entity}}Repository.findById(input.{{idField}});
      if (!{{camelCase entity}}) {
        throw new NotFoundError('{{pascalCase entity}} not found');
      }
      {{camelCase entity}}.update({{parameters}});
      await this.{{camelCase entity}}Repository.save({{camelCase entity}});
      {{/if}}
      {{#if (eq operation 'delete')}}
      await this.{{camelCase entity}}Repository.delete(input.{{idField}});
      {{/if}}
      {{#if (eq operation 'find')}}
      const {{camelCase entity}} = await this.{{camelCase entity}}Repository.findById(input.{{idField}});
      if (!{{camelCase entity}}) {
        throw new NotFoundError('{{pascalCase entity}} not found');
      }
      {{/if}}
      {{/each}}
      {{/if}}

      {{#if domainEvents}}
      // Handle domain events
      {{#each domainEvents}}
      await this.eventPublisher.publish(new {{pascalCase name}}({{parameters}}));
      {{/each}}
      {{/if}}

      {{#if integrationEvents}}
      // Publish integration events
      {{#each integrationEvents}}
      await this.eventBus.publish(new {{pascalCase name}}({{parameters}}));
      {{/each}}
      {{/if}}

      {{#if externalServices}}
      // Call external services
      {{#each externalServices}}
      {{#if condition}}
      if ({{condition}}) {
      {{/if}}
        const {{resultVariable}} = await this.{{camelCase service}}.{{method}}({{parameters}});
      {{#if condition}}
      }
      {{/if}}
      {{/each}}
      {{/if}}
      {{/if}}

      {{#if postProcessing}}
      // Post-processing
      {{#each postProcessing}}
      {{action}};
      {{/each}}
      {{/if}}

      {{#if logging}}
      // Audit logging
      await this.logger.log('{{name}} executed successfully', {
        input: input,
        userId: input.userId || 'system',
        timestamp: new Date(),
      });
      {{/if}}

      {{#if returnMapping}}
      // Map result to output DTO
      return this.mapToOutput({{returnSource}});
      {{else}}
      return {
        success: true,
        {{#if result}}
        data: {{result}},
        {{/if}}
        message: '{{name}} completed successfully',
      } as {{outputType}};
      {{/if}}

    } catch (error) {
      {{#if errorHandling}}
      // Custom error handling
      {{#each errorHandling}}
      if (error instanceof {{errorType}}) {
        {{action}};
      }
      {{/each}}
      {{/if}}

      {{#if logging}}
      await this.logger.error('{{name}} failed', {
        error: error.message,
        input: input,
        userId: input.userId || 'system',
        timestamp: new Date(),
      });
      {{/if}}

      if (error instanceof DomainError) {
        throw new UseCaseError(error.message);
      }

      if (error instanceof ValidationError) {
        throw new UseCaseValidationError(error.message, error.details);
      }

      throw new UseCaseError('An unexpected error occurred');
    }
  }

  {{#if validation}}
  private async validateInput(input: {{inputType}}): Promise<void> {
    {{#each validationRules}}
    {{#if (eq type 'required')}}
    if (!input.{{field}}) {
      throw new ValidationError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'minLength')}}
    if (input.{{field}} && input.{{field}}.length < {{value}}) {
      throw new ValidationError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'maxLength')}}
    if (input.{{field}} && input.{{field}}.length > {{value}}) {
      throw new ValidationError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'pattern')}}
    if (input.{{field}} && !new RegExp('{{value}}').test(input.{{field}})) {
      throw new ValidationError('{{message}}');
    }
    {{/if}}
    {{#if (eq type 'custom')}}
    if ({{condition}}) {
      throw new ValidationError('{{message}}');
    }
    {{/if}}
    {{/each}}

    {{#if complexValidation}}
    // Complex validation logic
    {{#each complexValidation}}
    const {{validatorName}} = new {{pascalCase validatorName}}();
    const isValid = await {{validatorName}}.validate(input.{{field}});
    if (!isValid) {
      throw new ValidationError('{{message}}');
    }
    {{/each}}
    {{/if}}
  }
  {{/if}}

  {{#if authorization}}
  private async checkAuthorization(input: {{inputType}}): Promise<void> {
    {{#if roles}}
    // Role-based authorization
    const userRoles = await this.authService.getUserRoles(input.userId);
    const requiredRoles = [{{#each roles}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}];
    
    if (!requiredRoles.some(role => userRoles.includes(role))) {
      throw new UnauthorizedError('Insufficient permissions');
    }
    {{/if}}

    {{#if permissions}}
    // Permission-based authorization
    const userPermissions = await this.authService.getUserPermissions(input.userId);
    const requiredPermissions = [{{#each permissions}}'{{this}}'{{#unless @last}}, {{/unless}}{{/each}}];
    
    if (!requiredPermissions.every(permission => userPermissions.includes(permission))) {
      throw new UnauthorizedError('Missing required permissions');
    }
    {{/if}}

    {{#if customLogic}}
    // Custom authorization logic
    {{customLogic}}
    {{/if}}
  }
  {{/if}}

  {{#if returnMapping}}
  private mapToOutput({{returnSource}}: any): {{outputType}} {
    {{#if mapping}}
    return {
      {{#each mapping}}
      {{outputField}}: {{#if transformation}}{{transformation}}{{else}}{{returnSource}}.{{sourceField}}{{/if}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
    {{else}}
    // TODO: Implement output mapping
    return {} as {{outputType}};
    {{/if}}
  }
  {{/if}}

  {{#if helperMethods}}
  // Helper methods
  {{#each helperMethods}}
  private {{#if isAsync}}async {{/if}}{{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{#if isAsync}}Promise<{{/if}}{{returnType}}{{#if isAsync}}>{{/if}} {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement {{name}}
    {{#unless (eq returnType 'void')}}
    throw new Error('Method not implemented');
    {{/unless}}
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if queries}}
  // Query methods
  {{#each queries}}
  private async {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}> {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement {{name}} query
    return await this.{{repository}}.{{method}}({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if calculations}}
  // Business calculations
  {{#each calculations}}
  private {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if formula}}
    return {{formula}};
    {{else}}
    // TODO: Implement {{name}} calculation
    return {{#if (eq returnType 'number')}}0{{else if (eq returnType 'boolean')}}false{{else}}null{{/if}};
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if transformations}}
  // Data transformations
  {{#each transformations}}
  private transform{{pascalCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if logic}}
    {{logic}}
    {{else}}
    // TODO: Implement {{name}} transformation
    return {} as {{returnType}};
    {{/if}}
  }

  {{/each}}
  {{/if}}
}

{{#if inputDto}}
// Input DTO
export class {{inputType}} {
  {{#each inputFields}}
  {{#if isReadonly}}readonly {{/if}}{{name}}{{#unless isRequired}}?{{/unless}}: {{type}};
  {{/each}}

  {{#if validation}}
  // Validation methods
  validate(): boolean {
    {{#each validationRules}}
    {{#if (eq type 'required')}}
    if (!this.{{field}}) return false;
    {{/if}}
    {{/each}}
    return true;
  }
  {{/if}}
}
{{/if}}

{{#if outputDto}}
// Output DTO
export class {{outputType}} {
  {{#each outputFields}}
  readonly {{name}}: {{type}};
  {{/each}}

  constructor(data: Partial<{{outputType}}>) {
    Object.assign(this, data);
  }
}
{{/if}}

{{#if errors}}
// Use Case Specific Errors
{{#each errors}}
export class {{pascalCase name}}Error extends UseCaseError {
  constructor({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}) {
    super('{{message}}');
    this.name = '{{pascalCase name}}Error';
  }
}

{{/each}}
{{/if}}