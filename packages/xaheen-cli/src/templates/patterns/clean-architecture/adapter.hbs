/**
 * {{pascalCase name}} Adapter
 * {{#if description}}{{description}}{{/if}}
 * Generated by Xaheen CLI - Clean Architecture Generator
 */

import { Injectable } from '@nestjs/common';
{{#each imports}}
import { {{this}} } from '{{@key}}';
{{/each}}
import { I{{pascalCase name}}Port } from '../interfaces/{{kebabCase name}}.port';
{{#each dependencies}}
import { {{pascalCase name}} } from '{{path}}';
{{/each}}

{{#if adapterInterface}}
// Adapter Interface
export interface I{{pascalCase name}}Adapter extends I{{pascalCase name}}Port {
  {{#each methods}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{#if isAsync}}Promise<{{/if}}{{returnType}}{{#if isAsync}}>{{/if}};
  {{/each}}
}
{{/if}}

@Injectable()
export class {{pascalCase name}}Adapter implements I{{pascalCase name}}Port {
  constructor(
    {{#each dependencies}}
    private readonly {{camelCase name}}: {{pascalCase name}}{{#unless @last}},{{/unless}}
    {{/each}}
  ) {}

  {{#each methods}}
  async {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}> {
    {{#if description}}
    // {{description}}
    {{/if}}

    {{#if validation}}
    // Input validation
    {{#each validation}}
    if ({{condition}}) {
      throw new AdapterError('{{message}}');
    }
    {{/each}}
    {{/if}}

    try {
      {{#if transformation}}
      // Transform input data
      const transformedInput = this.transformInput({{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}});
      {{/if}}

      {{#if externalCall}}
      // Call external service/system
      {{#if isAsync}}
      const externalResult = await this.{{externalService}}.{{externalMethod}}({{#if transformation}}transformedInput{{else}}{{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}});
      {{else}}
      const externalResult = this.{{externalService}}.{{externalMethod}}({{#if transformation}}transformedInput{{else}}{{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}}{{/if}});
      {{/if}}
      {{/if}}

      {{#if resultTransformation}}
      // Transform result
      const result = this.transformOutput(externalResult);
      return result;
      {{else}}
      {{#if defaultReturn}}
      return {{defaultReturn}};
      {{else}}
      // TODO: Implement {{name}} logic
      throw new Error('Method not implemented');
      {{/if}}
      {{/if}}

    } catch (error) {
      {{#if errorHandling}}
      // Custom error handling
      {{#each errorHandling}}
      if (error instanceof {{errorType}}) {
        throw new {{mappedError}}('{{message}}');
      }
      {{/each}}
      {{/if}}

      {{#if logging}}
      await this.logger.error('{{pascalCase ../name}} adapter error in {{name}}', {
        error: error.message,
        parameters: { {{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}} },
      });
      {{/if}}

      throw new AdapterError(`{{name}} failed: ${error.message}`);
    }
  }

  {{/each}}

  {{#if transformations}}
  // Data transformation methods
  {{#each transformations}}
  private transform{{pascalCase name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if mapping}}
    return {
      {{#each mapping}}
      {{targetField}}: {{#if transformation}}{{transformation}}{{else}}{{sourceField}}{{/if}}{{#unless @last}},{{/unless}}
      {{/each}}
    };
    {{else}}
    // TODO: Implement {{name}} transformation
    return {} as {{returnType}};
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if helperMethods}}
  // Helper methods
  {{#each helperMethods}}
  private {{#if isAsync}}async {{/if}}{{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{#if isAsync}}Promise<{{/if}}{{returnType}}{{#if isAsync}}>{{/if}} {
    {{#if implementation}}
    {{implementation}}
    {{else}}
    // TODO: Implement {{name}}
    {{#unless (eq returnType 'void')}}
    throw new Error('Method not implemented');
    {{/unless}}
    {{/if}}
  }

  {{/each}}
  {{/if}}

  {{#if caching}}
  // Caching methods
  private getCacheKey({{#each cacheKeyFields}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): string {
    return `{{kebabCase name}}:${{{#each cacheKeyFields}}{{name}}{{#unless @last}} + ':' + {{/unless}}{{/each}}}`;
  }

  private async getFromCache<T>(key: string): Promise<T | null> {
    try {
      const cached = await this.cacheService.get(key);
      return cached ? JSON.parse(cached) : null;
    } catch (error) {
      // Log cache error but don't fail the operation
      this.logger.warn('Cache retrieval failed', { key, error: error.message });
      return null;
    }
  }

  private async setCache<T>(key: string, value: T, ttl: number = {{cacheTtl}}): Promise<void> {
    try {
      await this.cacheService.set(key, JSON.stringify(value), ttl);
    } catch (error) {
      // Log cache error but don't fail the operation
      this.logger.warn('Cache storage failed', { key, error: error.message });
    }
  }
  {{/if}}

  {{#if healthCheck}}
  // Health check method
  async isHealthy(): Promise<boolean> {
    try {
      {{#if healthCheckImplementation}}
      {{healthCheckImplementation}}
      {{else}}
      // TODO: Implement health check
      // This might involve checking external service connectivity
      await this.{{externalService}}.ping();
      {{/if}}
      return true;
    } catch (error) {
      this.logger.error('{{pascalCase name}} adapter health check failed', { error: error.message });
      return false;
    }
  }
  {{/if}}

  {{#if metrics}}
  // Metrics methods
  private recordMetric(operation: string, duration: number, success: boolean): void {
    this.metricsService.recordOperation({
      adapter: '{{kebabCase name}}',
      operation,
      duration,
      success,
      timestamp: Date.now(),
    });
  }

  private async executeWithMetrics<T>(
    operation: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const startTime = Date.now();
    let success = false;
    
    try {
      const result = await fn();
      success = true;
      return result;
    } catch (error) {
      success = false;
      throw error;
    } finally {
      const duration = Date.now() - startTime;
      this.recordMetric(operation, duration, success);
    }
  }
  {{/if}}

  {{#if rateLimiting}}
  // Rate limiting
  private async checkRateLimit(key: string): Promise<void> {
    const isAllowed = await this.rateLimiter.isAllowed(key, {{rateLimit}});
    if (!isAllowed) {
      throw new RateLimitError('Rate limit exceeded');
    }
  }
  {{/if}}

  {{#if circuitBreaker}}
  // Circuit breaker pattern
  private async executeWithCircuitBreaker<T>(
    operation: string,
    fn: () => Promise<T>
  ): Promise<T> {
    const circuitBreaker = this.circuitBreakerService.getCircuitBreaker(operation);
    
    if (circuitBreaker.isOpen()) {
      throw new CircuitBreakerOpenError(`Circuit breaker is open for ${operation}`);
    }

    try {
      const result = await fn();
      circuitBreaker.recordSuccess();
      return result;
    } catch (error) {
      circuitBreaker.recordFailure();
      throw error;
    }
  }
  {{/if}}

  {{#if retry}}
  // Retry logic
  private async executeWithRetry<T>(
    fn: () => Promise<T>,
    maxRetries: number = {{maxRetries}},
    delay: number = {{retryDelay}}
  ): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;
        
        if (attempt === maxRetries) {
          break;
        }

        {{#if retryCondition}}
        // Check if error is retryable
        if ({{retryCondition}}) {
          await this.delay(delay * attempt);
          continue;
        } else {
          break;
        }
        {{else}}
        // Default retry logic
        if (this.isRetryableError(error)) {
          await this.delay(delay * attempt);
          continue;
        } else {
          break;
        }
        {{/if}}
      }
    }
    
    throw lastError;
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  private isRetryableError(error: any): boolean {
    // Define which errors are retryable
    return error.code === 'TIMEOUT' || 
           error.code === 'CONNECTION_ERROR' ||
           error.status >= 500;
  }
  {{/if}}
}

{{#if portInterface}}
// Port Interface (Application Layer)
export interface I{{pascalCase name}}Port {
  {{#each methods}}
  {{name}}({{#each parameters}}{{name}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): Promise<{{returnType}}>;
  {{/each}}
  {{#if healthCheck}}
  isHealthy(): Promise<boolean>;
  {{/if}}
}
{{/if}}

{{#if errors}}
// Adapter-specific errors
{{#each errors}}
export class {{pascalCase name}}Error extends Error {
  constructor(message: string{{#if hasCode}}, public readonly code: string{{/if}}) {
    super(message);
    this.name = '{{pascalCase name}}Error';
    {{#if hasCode}}
    this.code = code;
    {{/if}}
  }
}

{{/each}}
{{/if}}

{{#if configuration}}
// Adapter configuration
export interface {{pascalCase name}}AdapterConfig {
  {{#each configFields}}
  {{name}}: {{type}};
  {{/each}}
}

export const default{{pascalCase name}}Config: {{pascalCase name}}AdapterConfig = {
  {{#each configFields}}
  {{name}}: {{defaultValue}}{{#unless @last}},{{/unless}}
  {{/each}}
};
{{/if}}