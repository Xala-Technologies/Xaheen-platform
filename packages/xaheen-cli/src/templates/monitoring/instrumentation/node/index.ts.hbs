// OpenTelemetry Instrumentation for {{projectName}} (Node.js)
// Generated by Xaheen CLI - Story 4.3 Monitoring and Observability
// Environment: {{environment}}

import { NodeSDK } from '@opentelemetry/sdk-node';
import { Resource } from '@opentelemetry/resources';
import { SemanticResourceAttributes } from '@opentelemetry/semantic-conventions';
import { getNodeAutoInstrumentations } from '@opentelemetry/auto-instrumentations-node';
import { PeriodicExportingMetricReader, ConsoleMetricExporter } from '@opentelemetry/sdk-metrics';
import { PrometheusExporter } from '@opentelemetry/exporter-prometheus';
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http';
import { OTLPMetricExporter } from '@opentelemetry/exporter-metrics-otlp-http';
import { OTLPLogExporter } from '@opentelemetry/exporter-logs-otlp-http';
import { BatchSpanProcessor, SimpleSpanProcessor } from '@opentelemetry/sdk-trace-node';
import { BatchLogRecordProcessor } from '@opentelemetry/sdk-logs';
import { WinstonInstrumentation } from '@opentelemetry/instrumentation-winston';
import { PinoInstrumentation } from '@opentelemetry/instrumentation-pino';
import { BunyanInstrumentation } from '@opentelemetry/instrumentation-bunyan';
import { RedisInstrumentation } from '@opentelemetry/instrumentation-redis-4';
import { MongoDBInstrumentation } from '@opentelemetry/instrumentation-mongodb';
import { MySQLInstrumentation } from '@opentelemetry/instrumentation-mysql2';
import { PgInstrumentation } from '@opentelemetry/instrumentation-pg';
import { GraphQLInstrumentation } from '@opentelemetry/instrumentation-graphql';
import { ExpressInstrumentation } from '@opentelemetry/instrumentation-express';
import { FastifyInstrumentation } from '@opentelemetry/instrumentation-fastify';
import { NestInstrumentation } from '@opentelemetry/instrumentation-nestjs-core';

// Environment variables configuration
const {
  OTEL_SERVICE_NAME = '{{projectName}}',
  OTEL_SERVICE_VERSION = '1.0.0',
  OTEL_EXPORTER_OTLP_TRACES_ENDPOINT = '{{#if kubernetes}}http://otel-collector.{{kubernetes.namespace}}.svc.cluster.local:4318/v1/traces{{else}}http://otel-collector:4318/v1/traces{{/if}}',
  OTEL_EXPORTER_OTLP_METRICS_ENDPOINT = '{{#if kubernetes}}http://otel-collector.{{kubernetes.namespace}}.svc.cluster.local:4318/v1/metrics{{else}}http://otel-collector:4318/v1/metrics{{/if}}',
  OTEL_EXPORTER_OTLP_LOGS_ENDPOINT = '{{#if kubernetes}}http://otel-collector.{{kubernetes.namespace}}.svc.cluster.local:4318/v1/logs{{else}}http://otel-collector:4318/v1/logs{{/if}}',
  OTEL_RESOURCE_ATTRIBUTES = '',
  NODE_ENV = '{{environment}}',
  KUBERNETES_NAMESPACE = '{{#if kubernetes}}{{kubernetes.namespace}}{{else}}default{{/if}}',
  KUBERNETES_POD_NAME = process.env.HOSTNAME || 'unknown-pod',
  KUBERNETES_NODE_NAME = process.env.KUBERNETES_NODE_NAME || 'unknown-node'
} = process.env;

// Parse additional resource attributes from environment
const parseResourceAttributes = (attributesString: string): Record<string, string> => {
  const attributes: Record<string, string> = {};
  if (attributesString) {
    attributesString.split(',').forEach(attr => {
      const [key, value] = attr.split('=');
      if (key && value) {
        attributes[key.trim()] = value.trim();
      }
    });
  }
  return attributes;
};

// Resource configuration
const resource = new Resource({
  [SemanticResourceAttributes.SERVICE_NAME]: OTEL_SERVICE_NAME,
  [SemanticResourceAttributes.SERVICE_VERSION]: OTEL_SERVICE_VERSION,
  [SemanticResourceAttributes.DEPLOYMENT_ENVIRONMENT]: NODE_ENV,
  {{#if kubernetes}}
  [SemanticResourceAttributes.K8S_NAMESPACE_NAME]: KUBERNETES_NAMESPACE,
  [SemanticResourceAttributes.K8S_POD_NAME]: KUBERNETES_POD_NAME,
  [SemanticResourceAttributes.K8S_NODE_NAME]: KUBERNETES_NODE_NAME,
  [SemanticResourceAttributes.K8S_CLUSTER_NAME]: '{{kubernetes.namespace}}-cluster',
  {{/if}}
  [SemanticResourceAttributes.CONTAINER_NAME]: OTEL_SERVICE_NAME,
  [SemanticResourceAttributes.PROCESS_PID]: process.pid,
  [SemanticResourceAttributes.PROCESS_EXECUTABLE_NAME]: 'node',
  [SemanticResourceAttributes.PROCESS_RUNTIME_NAME]: 'nodejs',
  [SemanticResourceAttributes.PROCESS_RUNTIME_VERSION]: process.version,
  [SemanticResourceAttributes.OS_TYPE]: process.platform,
  [SemanticResourceAttributes.HOST_NAME]: process.env.HOSTNAME || 'unknown',
  ...parseResourceAttributes(OTEL_RESOURCE_ATTRIBUTES)
});

// Instrumentation configuration
const instrumentations = [
  getNodeAutoInstrumentations({
    // Core HTTP instrumentation
    '@opentelemetry/instrumentation-http': {
      enabled: true,
      ignoreIncomingRequestHook: (req) => {
        const url = req.url || '';
        return (
          url.includes('/metrics') ||
          url.includes('/health') ||
          url.includes('/ping') ||
          url.includes('/_health') ||
          url.includes('/favicon.ico')
        );
      },
      ignoreOutgoingRequestHook: (req) => {
        const hostname = req.hostname || req.host || '';
        return (
          hostname.includes('otel-collector') ||
          hostname.includes('prometheus') ||
          hostname.includes('grafana')
        );
      },
      headersToSpanAttributes: {
        client: {
          requestHeaders: ['user-agent', 'x-request-id', 'x-correlation-id'],
          responseHeaders: ['content-type', 'x-response-time']
        },
        server: {
          requestHeaders: ['user-agent', 'x-request-id', 'x-correlation-id', 'authorization'],
          responseHeaders: ['content-type', 'x-response-time']
        }
      }
    },

    // Express instrumentation
    '@opentelemetry/instrumentation-express': {
      enabled: true,
      ignoreLayers: [
        (name) => name.includes('bound dispatch'),
        (name, type) => type === 'request_handler' && name.includes('corsMiddleware'),
        (name, type) => type === 'middleware' && name.includes('helmet')
      ]
    },

    // File system instrumentation (can be noisy, disabled by default)
    '@opentelemetry/instrumentation-fs': {
      enabled: false
    },

    // DNS instrumentation (can be noisy, disabled by default)
    '@opentelemetry/instrumentation-dns': {
      enabled: false
    },

    // Net instrumentation
    '@opentelemetry/instrumentation-net': {
      enabled: true
    }
  }),

  // Additional framework instrumentations
  {{#if projectType}}
  {{#eq projectType 'api'}}
  new FastifyInstrumentation({
    enabled: true
  }),
  new GraphQLInstrumentation({
    enabled: true,
    mergeItems: true,
    depth: 10
  }),
  {{/eq}}
  {{#eq projectType 'fullstack'}}
  new NestInstrumentation({
    enabled: true
  }),
  {{/eq}}
  {{/if}}

  // Database instrumentations
  new MongoDBInstrumentation({
    enabled: true,
    enhancedDatabaseReporting: true
  }),
  new MySQLInstrumentation({
    enabled: true,
    addSqlCommenterCommentToQueries: true
  }),
  new PgInstrumentation({
    enabled: true,
    enhancedDatabaseReporting: true,
    addSqlCommenterCommentToQueries: true
  }),
  new RedisInstrumentation({
    enabled: true,
    dbStatementSerializer: (cmdName, cmdArgs) => {
      if (cmdArgs.length > 0 && typeof cmdArgs[0] === 'string') {
        return `${cmdName} ${cmdArgs[0]}`;
      }
      return cmdName;
    }
  }),

  // Logging instrumentations
  new WinstonInstrumentation({
    enabled: true,
    logHook: (span, record) => {
      {{#if features.includes('distributed-tracing')}}
      // Add trace correlation to logs
      const spanContext = span.spanContext();
      record['trace_id'] = spanContext.traceId;
      record['span_id'] = spanContext.spanId;
      record['trace_flags'] = spanContext.traceFlags;
      {{/if}}
    }
  }),
  new PinoInstrumentation({
    enabled: true,
    logHook: (span, record) => {
      {{#if features.includes('distributed-tracing')}}
      // Add trace correlation to logs
      const spanContext = span.spanContext();
      record['trace_id'] = spanContext.traceId;
      record['span_id'] = spanContext.spanId;
      record['trace_flags'] = spanContext.traceFlags;
      {{/if}}
    }
  }),
  new BunyanInstrumentation({
    enabled: true,
    logHook: (span, record) => {
      {{#if features.includes('distributed-tracing')}}
      // Add trace correlation to logs
      const spanContext = span.spanContext();
      record['trace_id'] = spanContext.traceId;
      record['span_id'] = spanContext.spanId;
      record['trace_flags'] = spanContext.traceFlags;
      {{/if}}
    }
  })
];

// Trace exporters configuration
const traceExporters = [];

// Always add logging exporter for development
if (NODE_ENV === 'development') {
  // Development: Log traces to console
  const { ConsoleSpanExporter } = require('@opentelemetry/sdk-trace-node');
  traceExporters.push(new SimpleSpanProcessor(new ConsoleSpanExporter()));
}

// OTLP exporter for production
traceExporters.push(
  new BatchSpanProcessor(
    new OTLPTraceExporter({
      url: OTEL_EXPORTER_OTLP_TRACES_ENDPOINT,
      headers: {
        'Content-Type': 'application/json',
        {{#if environment}}
        {{#eq environment 'production'}}
        'Authorization': `Bearer ${process.env.OTEL_EXPORTER_OTLP_TOKEN || ''}`,
        {{/eq}}
        {{/if}}
      },
      compression: 'gzip'
    }),
    {
      maxQueueSize: 2048,
      maxExportBatchSize: 512,
      scheduledDelayMillis: 1000,
      exportTimeoutMillis: 30000
    }
  )
);

// Metric exporters configuration
const metricReaders = [];

{{#if features.includes('prometheus')}}
// Prometheus exporter for metrics
metricReaders.push(
  new PrometheusExporter({
    endpoint: '/metrics',
    port: 9464,
    preventServerStart: false
  })
);
{{/if}}

// OTLP metric exporter
metricReaders.push(
  new PeriodicExportingMetricReader({
    exporter: new OTLPMetricExporter({
      url: OTEL_EXPORTER_OTLP_METRICS_ENDPOINT,
      headers: {
        'Content-Type': 'application/json',
        {{#if environment}}
        {{#eq environment 'production'}}
        'Authorization': `Bearer ${process.env.OTEL_EXPORTER_OTLP_TOKEN || ''}`,
        {{/eq}}
        {{/if}}
      },
      compression: 'gzip'
    }),
    exportIntervalMillis: 30000,
    exportTimeoutMillis: 10000
  })
);

// Log processor configuration
const logProcessors = [];

{{#if features.includes('loki')}}
// OTLP log exporter
logProcessors.push(
  new BatchLogRecordProcessor(
    new OTLPLogExporter({
      url: OTEL_EXPORTER_OTLP_LOGS_ENDPOINT,
      headers: {
        'Content-Type': 'application/json',
        {{#if environment}}
        {{#eq environment 'production'}}
        'Authorization': `Bearer ${process.env.OTEL_EXPORTER_OTLP_TOKEN || ''}`,
        {{/eq}}
        {{/if}}
      },
      compression: 'gzip'
    }),
    {
      maxQueueSize: 2048,
      maxExportBatchSize: 512,
      scheduledDelayMillis: 1000,
      exportTimeoutMillis: 30000
    }
  )
);
{{/if}}

// SDK Configuration
const sdk = new NodeSDK({
  resource,
  instrumentations,
  spanProcessors: traceExporters,
  metricReader: metricReaders.length > 1 ? metricReaders : metricReaders[0],
  {{#if features.includes('loki')}}
  logRecordProcessors: logProcessors,
  {{/if}}
  
  // Sampling configuration
  sampler: NODE_ENV === 'production' 
    ? require('@opentelemetry/sdk-trace-base').TraceIdRatioBasedSampler(0.1) // 10% sampling in production
    : require('@opentelemetry/sdk-trace-base').AlwaysOnSampler(), // 100% sampling in development

  // Context propagation
  textMapPropagator: new (require('@opentelemetry/core').CompositePropagator)({
    propagators: [
      new (require('@opentelemetry/propagator-b3').B3Propagator)(),
      new (require('@opentelemetry/propagator-jaeger').JaegerPropagator)(),
      new (require('@opentelemetry/core').W3CTraceContextPropagator)(),
      new (require('@opentelemetry/core').W3CBaggagePropagator)()
    ]
  })
});

// Initialize the SDK
try {
  sdk.start();
  console.log('OpenTelemetry started successfully for {{projectName}}');
  
  // Log configuration details in development
  if (NODE_ENV === 'development') {
    console.log('OpenTelemetry Configuration:');
    console.log(`  Service Name: ${OTEL_SERVICE_NAME}`);
    console.log(`  Service Version: ${OTEL_SERVICE_VERSION}`);
    console.log(`  Environment: ${NODE_ENV}`);
    console.log(`  Traces Endpoint: ${OTEL_EXPORTER_OTLP_TRACES_ENDPOINT}`);
    console.log(`  Metrics Endpoint: ${OTEL_EXPORTER_OTLP_METRICS_ENDPOINT}`);
    {{#if features.includes('loki')}}
    console.log(`  Logs Endpoint: ${OTEL_EXPORTER_OTLP_LOGS_ENDPOINT}`);
    {{/if}}
    {{#if kubernetes}}
    console.log(`  Kubernetes Namespace: ${KUBERNETES_NAMESPACE}`);
    console.log(`  Pod Name: ${KUBERNETES_POD_NAME}`);
    {{/if}}
  }
} catch (error) {
  console.error('Error initializing OpenTelemetry:', error);
}

// Graceful shutdown
const shutdown = async () => {
  try {
    console.log('Shutting down OpenTelemetry...');
    await sdk.shutdown();
    console.log('OpenTelemetry shutdown complete');
  } catch (error) {
    console.error('Error shutting down OpenTelemetry:', error);
  } finally {
    process.exit(0);
  }
};

// Handle process signals
process.on('SIGTERM', shutdown);
process.on('SIGINT', shutdown);
process.on('SIGQUIT', shutdown);

// Handle uncaught exceptions
process.on('uncaughtException', (error) => {
  console.error('Uncaught Exception:', error);
  shutdown();
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Unhandled Rejection at:', promise, 'reason:', reason);
  shutdown();
});

// Export SDK for custom usage
export { sdk };

// Utility functions for manual instrumentation
import { trace, metrics, logs, SpanKind, SpanStatusCode } from '@opentelemetry/api';

const tracer = trace.getTracer('{{projectName}}', '1.0.0');
const meter = metrics.getMeter('{{projectName}}', '1.0.0');
const logger = logs.getLogger('{{projectName}}', '1.0.0');

// Custom metrics
export const customCounter = meter.createCounter('custom_operations_total', {
  description: 'Total number of custom operations',
  unit: '1'
});

export const customHistogram = meter.createHistogram('custom_operation_duration', {
  description: 'Duration of custom operations',
  unit: 'ms'
});

export const customGauge = meter.createObservableGauge('custom_gauge_value', {
  description: 'Custom gauge metric',
  unit: '1'
});

// Helper functions
export const createSpan = <T>(name: string, operation: (span: any) => Promise<T> | T, kind: SpanKind = SpanKind.INTERNAL): Promise<T> | T => {
  return tracer.startActiveSpan(name, { kind }, async (span) => {
    try {
      const result = await operation(span);
      span.setStatus({ code: SpanStatusCode.OK });
      return result;
    } catch (error) {
      span.recordException(error as Error);
      span.setStatus({ 
        code: SpanStatusCode.ERROR, 
        message: (error as Error).message 
      });
      throw error;
    } finally {
      span.end();
    }
  });
};

export const addCorrelationId = () => {
  const span = trace.getActiveSpan();
  if (span) {
    const spanContext = span.spanContext();
    return {
      traceId: spanContext.traceId,
      spanId: spanContext.spanId,
      traceFlags: spanContext.traceFlags.toString(16).padStart(2, '0')
    };
  }
  return {
    traceId: 'unknown',
    spanId: 'unknown',
    traceFlags: '00'
  };
};

export const addCustomAttributes = (attributes: Record<string, string | number | boolean>) => {
  const span = trace.getActiveSpan();
  if (span) {
    Object.entries(attributes).forEach(([key, value]) => {
      span.setAttribute(key, value);
    });
  }
};

export const emitCustomLog = (level: 'debug' | 'info' | 'warn' | 'error', message: string, attributes?: Record<string, any>) => {
  const correlation = addCorrelationId();
  logger.emit({
    severityText: level.toUpperCase(),
    body: message,
    attributes: {
      ...correlation,
      ...attributes,
      service: '{{projectName}}',
      environment: NODE_ENV
    }
  });
};

// Decorator for automatic span creation
export const traced = (operationName?: string, spanKind: SpanKind = SpanKind.INTERNAL) => {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const spanName = operationName || `${target.constructor.name}.${propertyKey}`;

    descriptor.value = function (...args: any[]) {
      return createSpan(spanName, (span) => {
        // Add method arguments as span attributes (be careful with sensitive data)
        if (args.length > 0 && NODE_ENV === 'development') {
          span.setAttribute('method.args.length', args.length);
        }
        
        return originalMethod.apply(this, args);
      }, spanKind);
    };

    return descriptor;
  };
};

// Performance monitoring helpers
export const startTimer = (metricName: string) => {
  const startTime = Date.now();
  
  return {
    end: (labels?: Record<string, string>) => {
      const duration = Date.now() - startTime;
      customHistogram.record(duration, labels);
      
      // Also add to current span if available
      const span = trace.getActiveSpan();
      if (span) {
        span.setAttribute(`${metricName}.duration_ms`, duration);
      }
      
      return duration;
    }
  };
};

// Health check integration
export const healthCheck = () => {
  return {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    service: OTEL_SERVICE_NAME,
    version: OTEL_SERVICE_VERSION,
    environment: NODE_ENV,
    tracing: {
      enabled: true,
      endpoint: OTEL_EXPORTER_OTLP_TRACES_ENDPOINT
    },
    metrics: {
      enabled: true,
      endpoint: OTEL_EXPORTER_OTLP_METRICS_ENDPOINT,
      {{#if features.includes('prometheus')}}
      prometheus: 'http://localhost:9464/metrics'
      {{/if}}
    }
    {{#if features.includes('loki')}}
    ,logs: {
      enabled: true,
      endpoint: OTEL_EXPORTER_OTLP_LOGS_ENDPOINT
    }
    {{/if}}
  };
};