# Compute module main configuration
# Generated by Xaheen CLI Terraform Generator

{{#eq cloudProvider "aws"}}
# Data source for latest Amazon Linux 2 AMI
data "aws_ami" "amazon_linux" {
  most_recent = true
  owners      = ["amazon"]
  
  filter {
    name   = "name"
    values = ["amzn2-ami-hvm-*-x86_64-gp2"]
  }
  
  filter {
    name   = "virtualization-type"
    values = ["hvm"]
  }
}

# Security Group for EC2 instances
resource "aws_security_group" "instance" {
  name_prefix = "${var.project_name}-${var.environment}-instance-"
  vpc_id      = var.vpc_id
  description = "Security group for EC2 instances"
  
  # HTTP
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
    description = "HTTP from VPC"
  }
  
  # HTTPS
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
    description = "HTTPS from VPC"
  }
  
  # SSH
  ingress {
    from_port   = 22
    to_port     = 22
    protocol    = "tcp"
    cidr_blocks = ["10.0.0.0/8"]
    description = "SSH from VPC"
  }
  
  # All outbound traffic
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "All outbound traffic"
  }
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-instance-sg"
  })
  
  lifecycle {
    create_before_destroy = true
  }
}

# Launch Template
resource "aws_launch_template" "main" {
  name_prefix   = "${var.project_name}-${var.environment}-"
  image_id      = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  key_name      = var.key_pair_name
  
  vpc_security_group_ids = concat([aws_security_group.instance.id], var.security_group_ids)
  
  user_data = base64encode(templatefile("${path.module}/user_data.sh", {
    project_name = var.project_name
    environment  = var.environment
  }))
  
  block_device_mappings {
    device_name = "/dev/xvda"
    ebs {
      volume_size = 20
      volume_type = "gp3"
      encrypted   = var.encryption_enabled
      delete_on_termination = true
    }
  }
  
  metadata_options {
    http_endpoint = "enabled"
    http_tokens   = "required"
    http_put_response_hop_limit = 2
  }
  
  monitoring {
    enabled = true
  }
  
  tag_specifications {
    resource_type = "instance"
    tags = merge(var.tags, {
      Name = "${var.project_name}-${var.environment}-instance"
    })
  }
  
  lifecycle {
    create_before_destroy = true
  }
}

{{#if compute.autoScaling}}
# Auto Scaling Group
resource "aws_autoscaling_group" "main" {
  name                = "${var.project_name}-${var.environment}-asg"
  vpc_zone_identifier = var.private_subnets
  min_size            = var.min_size
  max_size            = var.max_size
  desired_capacity    = var.desired_capacity
  health_check_type   = var.enable_load_balancer ? "ELB" : "EC2"
  health_check_grace_period = 300
  
  launch_template {
    id      = aws_launch_template.main.id
    version = "$Latest"
  }
  
  target_group_arns = var.enable_load_balancer ? [aws_lb_target_group.main[0].arn] : []
  
  enabled_metrics = [
    "GroupMinSize",
    "GroupMaxSize",
    "GroupDesiredCapacity",
    "GroupInServiceInstances",
    "GroupTotalInstances"
  ]
  
  tag {
    key                 = "Name"
    value               = "${var.project_name}-${var.environment}-instance"
    propagate_at_launch = true
  }
  
  dynamic "tag" {
    for_each = var.tags
    content {
      key                 = tag.key
      value               = tag.value
      propagate_at_launch = true
    }
  }
  
  instance_refresh {
    strategy = "Rolling"
    preferences {
      min_healthy_percentage = 50
    }
  }
  
  lifecycle {
    create_before_destroy = true
  }
}

# Auto Scaling Policies
resource "aws_autoscaling_policy" "scale_up" {
  name                   = "${var.project_name}-${var.environment}-scale-up"
  scaling_adjustment     = 1
  adjustment_type        = "ChangeInCapacity"
  cooldown               = 300
  autoscaling_group_name = aws_autoscaling_group.main.name
}

resource "aws_autoscaling_policy" "scale_down" {
  name                   = "${var.project_name}-${var.environment}-scale-down"
  scaling_adjustment     = -1
  adjustment_type        = "ChangeInCapacity"
  cooldown               = 300
  autoscaling_group_name = aws_autoscaling_group.main.name
}

# CloudWatch Alarms
resource "aws_cloudwatch_metric_alarm" "cpu_high" {
  alarm_name          = "${var.project_name}-${var.environment}-cpu-high"
  comparison_operator = "GreaterThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "120"
  statistic           = "Average"
  threshold           = "80"
  alarm_description   = "This metric monitors ec2 cpu utilization"
  
  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.main.name
  }
  
  alarm_actions = [aws_autoscaling_policy.scale_up.arn]
  
  tags = var.tags
}

resource "aws_cloudwatch_metric_alarm" "cpu_low" {
  alarm_name          = "${var.project_name}-${var.environment}-cpu-low"
  comparison_operator = "LessThanThreshold"
  evaluation_periods  = "2"
  metric_name         = "CPUUtilization"
  namespace           = "AWS/EC2"
  period              = "120"
  statistic           = "Average"
  threshold           = "10"
  alarm_description   = "This metric monitors ec2 cpu utilization"
  
  dimensions = {
    AutoScalingGroupName = aws_autoscaling_group.main.name
  }
  
  alarm_actions = [aws_autoscaling_policy.scale_down.arn]
  
  tags = var.tags
}
{{else}}
# Single EC2 instance (when auto scaling is disabled)
resource "aws_instance" "main" {
  count = var.desired_capacity
  
  ami           = data.aws_ami.amazon_linux.id
  instance_type = var.instance_type
  key_name      = var.key_pair_name
  subnet_id     = var.private_subnets[count.index % length(var.private_subnets)]
  
  vpc_security_group_ids = concat([aws_security_group.instance.id], var.security_group_ids)
  
  user_data = base64encode(templatefile("${path.module}/user_data.sh", {
    project_name = var.project_name
    environment  = var.environment
  }))
  
  root_block_device {
    volume_size = 20
    volume_type = "gp3"
    encrypted   = var.encryption_enabled
    delete_on_termination = true
  }
  
  metadata_options {
    http_endpoint = "enabled"
    http_tokens   = "required"
    http_put_response_hop_limit = 2
  }
  
  monitoring = true
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-instance-${count.index + 1}"
  })
}
{{/if}}

{{#if compute.loadBalancer}}
# Application Load Balancer
resource "aws_lb" "main" {
  name               = "${var.project_name}-${var.environment}-alb"
  internal           = false
  load_balancer_type = "application"
  security_groups    = [aws_security_group.alb.id]
  subnets            = var.public_subnets
  
  enable_deletion_protection = var.environment == "production" ? true : false
  
  access_logs {
    bucket  = aws_s3_bucket.alb_logs.bucket
    prefix  = "alb-logs"
    enabled = true
  }
  
  tags = var.tags
}

resource "aws_lb_target_group" "main" {
  count = var.enable_load_balancer ? 1 : 0
  
  name     = "${var.project_name}-${var.environment}-tg"
  port     = 80
  protocol = "HTTP"
  vpc_id   = var.vpc_id
  
  health_check {
    enabled             = true
    healthy_threshold   = 2
    interval            = 30
    matcher             = "200"
    path                = "/health"
    port                = "traffic-port"
    protocol            = "HTTP"
    timeout             = 5
    unhealthy_threshold = 2
  }
  
  tags = var.tags
}

resource "aws_lb_listener" "main" {
  count = var.enable_load_balancer ? 1 : 0
  
  load_balancer_arn = aws_lb.main.arn
  port              = "80"
  protocol          = "HTTP"
  
  default_action {
    type = var.ssl_certificate_arn != null ? "redirect" : "forward"
    
    dynamic "redirect" {
      for_each = var.ssl_certificate_arn != null ? [1] : []
      content {
        port        = "443"
        protocol    = "HTTPS"
        status_code = "HTTP_301"
      }
    }
    
    dynamic "forward" {
      for_each = var.ssl_certificate_arn == null ? [1] : []
      content {
        target_group {
          arn = aws_lb_target_group.main[0].arn
        }
      }
    }
  }
}

resource "aws_lb_listener" "https" {
  count = var.enable_load_balancer && var.ssl_certificate_arn != null ? 1 : 0
  
  load_balancer_arn = aws_lb.main.arn
  port              = "443"
  protocol          = "HTTPS"
  ssl_policy        = "ELBSecurityPolicy-TLS-1-2-2017-01"
  certificate_arn   = var.ssl_certificate_arn
  
  default_action {
    type = "forward"
    forward {
      target_group {
        arn = aws_lb_target_group.main[0].arn
      }
    }
  }
}

# ALB Security Group
resource "aws_security_group" "alb" {
  name_prefix = "${var.project_name}-${var.environment}-alb-"
  vpc_id      = var.vpc_id
  description = "Security group for Application Load Balancer"
  
  ingress {
    from_port   = 80
    to_port     = 80
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTP"
  }
  
  ingress {
    from_port   = 443
    to_port     = 443
    protocol    = "tcp"
    cidr_blocks = ["0.0.0.0/0"]
    description = "HTTPS"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "All outbound traffic"
  }
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-alb-sg"
  })
  
  lifecycle {
    create_before_destroy = true
  }
}

# S3 bucket for ALB logs
resource "aws_s3_bucket" "alb_logs" {
  bucket        = "${var.project_name}-${var.environment}-alb-logs-${random_id.bucket_suffix.hex}"
  force_destroy = var.environment != "production"
  
  tags = var.tags
}

resource "aws_s3_bucket_policy" "alb_logs" {
  bucket = aws_s3_bucket.alb_logs.id
  
  policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Effect = "Allow"
        Principal = {
          AWS = data.aws_elb_service_account.main.arn
        }
        Action   = "s3:PutObject"
        Resource = "${aws_s3_bucket.alb_logs.arn}/alb-logs/AWSLogs/${data.aws_caller_identity.current.account_id}/*"
      }
    ]
  })
}

data "aws_elb_service_account" "main" {}
data "aws_caller_identity" "current" {}

resource "random_id" "bucket_suffix" {
  byte_length = 4
}
{{/if}}
{{/eq}}

{{#eq cloudProvider "azure"}}
# Azure Virtual Machine Scale Set
resource "azurerm_virtual_machine_scale_set" "main" {
  name                = "${var.project_name}-${var.environment}-vmss"
  location            = var.location
  resource_group_name = var.resource_group_name
  
  sku {
    name     = var.vm_size
    tier     = "Standard"
    capacity = var.desired_capacity
  }
  
  upgrade_policy_mode = "Manual"
  
  storage_profile_image_reference {
    publisher = "Canonical"
    offer     = "0001-com-ubuntu-server-focal"
    sku       = "20_04-lts-gen2"
    version   = "latest"
  }
  
  storage_profile_os_disk {
    name              = ""
    caching           = "ReadWrite"
    create_option     = "FromImage"
    managed_disk_type = "Premium_LRS"
  }
  
  os_profile {
    computer_name_prefix = var.project_name
    admin_username       = var.admin_username
    admin_password       = var.admin_password
    custom_data         = base64encode(file("${path.module}/cloud-init.yaml"))
  }
  
  os_profile_linux_config {
    disable_password_authentication = false
  }
  
  network_profile {
    name    = "terraformnetworkprofile"
    primary = true
    
    ip_configuration {
      name                                   = "TestIPConfiguration"
      primary                                = true
      subnet_id                              = var.subnet_ids[0]
      load_balancer_backend_address_pool_ids = var.enable_load_balancer ? [azurerm_lb_backend_address_pool.main[0].id] : []
    }
  }
  
  tags = var.tags
}

{{#if compute.autoScaling}}
# Auto-scaling settings
resource "azurerm_monitor_autoscale_setting" "main" {
  name                = "${var.project_name}-${var.environment}-autoscale"
  resource_group_name = var.resource_group_name
  location            = var.location
  target_resource_id  = azurerm_virtual_machine_scale_set.main.id
  
  profile {
    name = "defaultProfile"
    
    capacity {
      default = var.desired_capacity
      minimum = var.min_size
      maximum = var.max_size
    }
    
    rule {
      metric_trigger {
        metric_name        = "Percentage CPU"
        metric_resource_id = azurerm_virtual_machine_scale_set.main.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "GreaterThan"
        threshold          = 75
      }
      
      scale_action {
        direction = "Increase"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT1M"
      }
    }
    
    rule {
      metric_trigger {
        metric_name        = "Percentage CPU"
        metric_resource_id = azurerm_virtual_machine_scale_set.main.id
        time_grain         = "PT1M"
        statistic          = "Average"
        time_window        = "PT5M"
        time_aggregation   = "Average"
        operator           = "LessThan"
        threshold          = 25
      }
      
      scale_action {
        direction = "Decrease"
        type      = "ChangeCount"
        value     = "1"
        cooldown  = "PT1M"
      }
    }
  }
  
  tags = var.tags
}
{{/if}}

{{#if compute.loadBalancer}}
# Azure Load Balancer
resource "azurerm_public_ip" "main" {
  name                = "${var.project_name}-${var.environment}-lb-pip"
  location            = var.location
  resource_group_name = var.resource_group_name
  allocation_method   = "Static"
  sku                = "Standard"
  
  tags = var.tags
}

resource "azurerm_lb" "main" {
  name                = "${var.project_name}-${var.environment}-lb"
  location            = var.location
  resource_group_name = var.resource_group_name
  sku                = "Standard"
  
  frontend_ip_configuration {
    name                 = "PublicIPAddress"
    public_ip_address_id = azurerm_public_ip.main.id
  }
  
  tags = var.tags
}

resource "azurerm_lb_backend_address_pool" "main" {
  count = var.enable_load_balancer ? 1 : 0
  
  loadbalancer_id = azurerm_lb.main.id
  name            = "BackEndAddressPool"
}

resource "azurerm_lb_probe" "main" {
  count = var.enable_load_balancer ? 1 : 0
  
  loadbalancer_id = azurerm_lb.main.id
  name            = "http-probe"
  protocol        = "Http"
  request_path    = "/health"
  port            = 80
}

resource "azurerm_lb_rule" "main" {
  count = var.enable_load_balancer ? 1 : 0
  
  loadbalancer_id                = azurerm_lb.main.id
  name                           = "LBRule"
  protocol                       = "Tcp"
  frontend_port                  = 80
  backend_port                   = 80
  frontend_ip_configuration_name = "PublicIPAddress"
  backend_address_pool_ids       = [azurerm_lb_backend_address_pool.main[0].id]
  probe_id                       = azurerm_lb_probe.main[0].id
}
{{/if}}
{{/eq}}

{{#eq cloudProvider "gcp"}}
# Service Account for instances
resource "google_service_account" "main" {
  account_id   = "${var.project_name}-${var.environment}-sa"
  display_name = "Service Account for ${var.project_name} ${var.environment}"
}

# Data sources
data "google_compute_image" "ubuntu" {
  family  = "ubuntu-2004-lts"
  project = "ubuntu-os-cloud"
}

data "google_compute_zones" "available" {
  region = var.region
}

# Instance Template
resource "google_compute_instance_template" "main" {
  name_prefix  = "${var.project_name}-${var.environment}-"
  machine_type = var.machine_type
  region       = var.region
  
  tags = ["web-server", "ssh-server"]
  
  disk {
    source_image = data.google_compute_image.ubuntu.id
    auto_delete  = true
    boot         = true
    disk_size_gb = 20
    disk_type    = "pd-ssd"
  }
  
  network_interface {
    network    = var.network_name
    subnetwork = var.subnet_names[0]
    
    access_config {
      // Ephemeral public IP
    }
  }
  
  service_account {
    email  = google_service_account.main.email
    scopes = ["cloud-platform"]
  }
  
  metadata = {
    ssh-keys = "ubuntu:${file(var.public_key_path)}"
  }
  
  metadata_startup_script = file("${path.module}/startup-script.sh")
  
  lifecycle {
    create_before_destroy = true
  }
}

{{#if compute.autoScaling}}
# Instance Group Manager
resource "google_compute_instance_group_manager" "main" {
  name = "${var.project_name}-${var.environment}-igm"
  zone = data.google_compute_zones.available.names[0]
  
  version {
    instance_template = google_compute_instance_template.main.id
  }
  
  base_instance_name = "${var.project_name}-${var.environment}"
  target_size        = var.desired_capacity
  
  named_port {
    name = "http"
    port = 80
  }
  
  auto_healing_policies {
    health_check      = google_compute_health_check.main.id
    initial_delay_sec = 300
  }
}

# Auto Scaler
resource "google_compute_autoscaler" "main" {
  name   = "${var.project_name}-${var.environment}-autoscaler"
  zone   = data.google_compute_zones.available.names[0]
  target = google_compute_instance_group_manager.main.id
  
  autoscaling_policy {
    max_replicas    = var.max_size
    min_replicas    = var.min_size
    cooldown_period = 60
    
    cpu_utilization {
      target = 0.8
    }
  }
}

# Health Check
resource "google_compute_health_check" "main" {
  name = "${var.project_name}-${var.environment}-health-check"
  
  timeout_sec        = 5
  check_interval_sec = 10
  
  http_health_check {
    port         = "80"
    request_path = "/health"
  }
}
{{else}}
# Single instances (when auto scaling is disabled)
resource "google_compute_instance" "main" {
  count = var.desired_capacity
  
  name         = "${var.project_name}-${var.environment}-instance-${count.index + 1}"
  machine_type = var.machine_type
  zone         = data.google_compute_zones.available.names[count.index % length(data.google_compute_zones.available.names)]
  
  tags = ["web-server", "ssh-server"]
  
  boot_disk {
    initialize_params {
      image = data.google_compute_image.ubuntu.id
      size  = 20
      type  = "pd-ssd"
    }
  }
  
  network_interface {
    network    = var.network_name
    subnetwork = var.subnet_names[0]
    
    access_config {
      // Ephemeral public IP
    }
  }
  
  service_account {
    email  = google_service_account.main.email
    scopes = ["cloud-platform"]
  }
  
  metadata = {
    ssh-keys = "ubuntu:${file(var.public_key_path)}"
  }
  
  metadata_startup_script = file("${path.module}/startup-script.sh")
}
{{/if}}

{{#if compute.loadBalancer}}
# Global Load Balancer
resource "google_compute_global_address" "main" {
  name = "${var.project_name}-${var.environment}-lb-ip"
}

resource "google_compute_backend_service" "main" {
  name        = "${var.project_name}-${var.environment}-backend"
  port_name   = "http"
  protocol    = "HTTP"
  timeout_sec = 10
  
  health_checks = [google_compute_health_check.main.id]
  
  backend {
    group           = google_compute_instance_group_manager.main.instance_group
    balancing_mode  = "UTILIZATION"
    max_utilization = 0.8
  }
}

resource "google_compute_url_map" "main" {
  name            = "${var.project_name}-${var.environment}-url-map"
  default_service = google_compute_backend_service.main.id
}

resource "google_compute_target_http_proxy" "main" {
  name    = "${var.project_name}-${var.environment}-http-proxy"
  url_map = google_compute_url_map.main.id
}

resource "google_compute_global_forwarding_rule" "main" {
  name       = "${var.project_name}-${var.environment}-forwarding-rule"
  port_range = "80"
  target     = google_compute_target_http_proxy.main.id
  ip_address = google_compute_global_address.main.address
}
{{/if}}
{{/eq}}