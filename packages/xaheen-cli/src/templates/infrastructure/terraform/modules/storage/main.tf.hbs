# Storage module main configuration
# Generated by Xaheen CLI Terraform Generator

{{#eq cloudProvider "aws"}}
{{#if storage.databases}}
# Database Subnet Group
resource "aws_db_subnet_group" "main" {
  name       = "${var.project_name}-${var.environment}-db-subnet-group"
  subnet_ids = var.private_subnets
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-db-subnet-group"
  })
}

# Database Parameter Group
resource "aws_db_parameter_group" "main" {
  family = var.db_engine == "postgresql" ? "postgres15" : "mysql8.0"
  name   = "${var.project_name}-${var.environment}-db-params"
  
  dynamic "parameter" {
    for_each = var.db_engine == "postgresql" ? [
      {
        name  = "shared_preload_libraries"
        value = "pg_stat_statements"
      },
      {
        name  = "log_statement"
        value = "all"
      }
    ] : [
      {
        name  = "innodb_buffer_pool_size"
        value = "{DBInstanceClassMemory*3/4}"
      },
      {
        name  = "slow_query_log"
        value = "1"
      }
    ]
    content {
      name  = parameter.value.name
      value = parameter.value.value
    }
  }
  
  tags = var.tags
}

# Database Security Group
resource "aws_security_group" "rds" {
  name_prefix = "${var.project_name}-${var.environment}-rds-"
  vpc_id      = var.vpc_id
  description = "Security group for RDS database"
  
  ingress {
    from_port       = var.db_engine == "postgresql" ? 5432 : 3306
    to_port         = var.db_engine == "postgresql" ? 5432 : 3306
    protocol        = "tcp"
    security_groups = var.app_security_group_ids
    description     = "Database access from application servers"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "All outbound traffic"
  }
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-rds-sg"
  })
  
  lifecycle {
    create_before_destroy = true
  }
}

# RDS Instance
resource "aws_db_instance" "main" {
  identifier = "${var.project_name}-${var.environment}-db"
  
  engine                = var.db_engine
  engine_version        = var.db_version
  instance_class        = var.db_instance_class
  allocated_storage     = var.db_allocated_storage
  max_allocated_storage = var.db_allocated_storage * 2
  
  db_name  = replace(var.project_name, "-", "_")
  username = var.db_username
  password = var.db_password
  
  vpc_security_group_ids = [aws_security_group.rds.id]
  db_subnet_group_name   = aws_db_subnet_group.main.name
  parameter_group_name   = aws_db_parameter_group.main.name
  
  backup_retention_period = var.backup_retention_days
  backup_window          = var.backup_window
  maintenance_window     = var.maintenance_window
  
  storage_encrypted = var.encryption_enabled
  kms_key_id       = var.encryption_enabled ? var.kms_key_id : null
  
  multi_az               = var.environment == "production"
  publicly_accessible    = false
  storage_type           = "gp3"
  
  skip_final_snapshot       = var.environment != "production"
  final_snapshot_identifier = var.environment == "production" ? "${var.project_name}-${var.environment}-final-snapshot-${formatdate("YYYY-MM-DD-hhmm", timestamp())}" : null
  
  enabled_cloudwatch_logs_exports = var.db_engine == "postgresql" ? ["postgresql"] : ["error", "general", "slow_query"]
  
  monitoring_interval = 60
  monitoring_role_arn = aws_iam_role.rds_enhanced_monitoring.arn
  
  performance_insights_enabled = var.environment == "production"
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-db"
  })
  
  lifecycle {
    prevent_destroy = true
    ignore_changes = [password]
  }
}

# IAM Role for RDS Enhanced Monitoring
resource "aws_iam_role" "rds_enhanced_monitoring" {
  name = "${var.project_name}-${var.environment}-rds-monitoring-role"
  
  assume_role_policy = jsonencode({
    Version = "2012-10-17"
    Statement = [
      {
        Action = "sts:AssumeRole"
        Effect = "Allow"
        Principal = {
          Service = "monitoring.rds.amazonaws.com"
        }
      }
    ]
  })
  
  tags = var.tags
}

resource "aws_iam_role_policy_attachment" "rds_enhanced_monitoring" {
  role       = aws_iam_role.rds_enhanced_monitoring.name
  policy_arn = "arn:aws:iam::aws:policy/service-role/AmazonRDSEnhancedMonitoringRole"
}
{{/if}}

{{#if storage.objectStorage}}
# Random ID for bucket naming
resource "random_id" "bucket_suffix" {
  byte_length = 4
}

# S3 Bucket
resource "aws_s3_bucket" "main" {
  bucket        = "${var.project_name}-${var.environment}-storage-${random_id.bucket_suffix.hex}"
  force_destroy = var.environment != "production"
  
  tags = var.tags
}

# S3 Bucket Public Access Block
resource "aws_s3_bucket_public_access_block" "main" {
  bucket = aws_s3_bucket.main.id
  
  block_public_acls       = true
  block_public_policy     = true
  ignore_public_acls      = true
  restrict_public_buckets = true
}

# S3 Bucket Server Side Encryption
resource "aws_s3_bucket_server_side_encryption_configuration" "main" {
  bucket = aws_s3_bucket.main.id
  
  rule {
    apply_server_side_encryption_by_default {
      kms_master_key_id = var.kms_key_id
      sse_algorithm     = var.encryption_enabled ? "aws:kms" : "AES256"
    }
    bucket_key_enabled = var.encryption_enabled
  }
}

# S3 Bucket Versioning
resource "aws_s3_bucket_versioning" "main" {
  bucket = aws_s3_bucket.main.id
  versioning_configuration {
    status = var.environment == "production" ? "Enabled" : "Suspended"
  }
}

# S3 Bucket Lifecycle Configuration
resource "aws_s3_bucket_lifecycle_configuration" "main" {
  bucket = aws_s3_bucket.main.id
  
  rule {
    id     = "lifecycle_rule"
    status = "Enabled"
    
    expiration {
      days = var.backup_retention_days * 2
    }
    
    noncurrent_version_expiration {
      noncurrent_days = 30
    }
    
    abort_incomplete_multipart_upload {
      days_after_initiation = 7
    }
  }
}

# S3 Bucket Logging (if audit logs enabled)
resource "aws_s3_bucket_logging" "main" {
  count = var.audit_logs_enabled ? 1 : 0
  
  bucket = aws_s3_bucket.main.id
  
  target_bucket = aws_s3_bucket.access_logs[0].id
  target_prefix = "access-logs/"
}

resource "aws_s3_bucket" "access_logs" {
  count = var.audit_logs_enabled ? 1 : 0
  
  bucket        = "${var.project_name}-${var.environment}-access-logs-${random_id.bucket_suffix.hex}"
  force_destroy = var.environment != "production"
  
  tags = var.tags
}
{{/if}}

{{#if storage.fileSystem}}
# EFS File System
resource "aws_efs_file_system" "main" {
  creation_token = "${var.project_name}-${var.environment}-efs"
  
  performance_mode = "generalPurpose"
  throughput_mode  = "provisioned"
  provisioned_throughput_in_mibps = 100
  
  encrypted  = var.encryption_enabled
  kms_key_id = var.encryption_enabled ? var.kms_key_id : null
  
  lifecycle_policy {
    transition_to_ia = "AFTER_30_DAYS"
  }
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-efs"
  })
}

# EFS Mount Targets
resource "aws_efs_mount_target" "main" {
  count = length(var.private_subnets)
  
  file_system_id  = aws_efs_file_system.main.id
  subnet_id       = var.private_subnets[count.index]
  security_groups = [aws_security_group.efs.id]
}

# EFS Security Group
resource "aws_security_group" "efs" {
  name_prefix = "${var.project_name}-${var.environment}-efs-"
  vpc_id      = var.vpc_id
  description = "Security group for EFS"
  
  ingress {
    from_port       = 2049
    to_port         = 2049
    protocol        = "tcp"
    security_groups = var.app_security_group_ids
    description     = "NFS access from application servers"
  }
  
  egress {
    from_port   = 0
    to_port     = 0
    protocol    = "-1"
    cidr_blocks = ["0.0.0.0/0"]
    description = "All outbound traffic"
  }
  
  tags = merge(var.tags, {
    Name = "${var.project_name}-${var.environment}-efs-sg"
  })
  
  lifecycle {
    create_before_destroy = true
  }
}
{{/if}}
{{/eq}}

{{#eq cloudProvider "azure"}}
{{#if storage.databases}}
# Azure SQL Server
resource "azurerm_mssql_server" "main" {
  name                         = "${var.project_name}-${var.environment}-sqlserver"
  resource_group_name          = var.resource_group_name
  location                     = var.location
  version                      = "12.0"
  administrator_login          = var.db_username
  administrator_login_password = var.db_password
  
  public_network_access_enabled = false
  minimum_tls_version          = "1.2"
  
  azuread_administrator {
    login_username = "sqladmin"
    object_id      = data.azurerm_client_config.current.object_id
  }
  
  tags = var.tags
}

# Azure SQL Database
resource "azurerm_mssql_database" "main" {
  name      = "${replace(var.project_name, "-", "_")}_${var.environment}_db"
  server_id = azurerm_mssql_server.main.id
  
  collation        = "SQL_Latin1_General_CP1_CI_AS"
  license_type     = "LicenseIncluded"
  sku_name         = var.db_sku_name
  zone_redundant   = var.environment == "production"
  
  short_term_retention_policy {
    retention_days = var.backup_retention_days
  }
  
  long_term_retention_policy {
    weekly_retention  = "P1W"
    monthly_retention = "P1M"
    yearly_retention  = "P1Y"
    week_of_year      = 1
  }
  
  tags = var.tags
}

# SQL Server Firewall Rule
resource "azurerm_mssql_firewall_rule" "main" {
  name             = "AllowAzureServices"
  server_id        = azurerm_mssql_server.main.id
  start_ip_address = "0.0.0.0"
  end_ip_address   = "0.0.0.0"
}

# Private Endpoint for SQL Server
resource "azurerm_private_endpoint" "sql" {
  name                = "${var.project_name}-${var.environment}-sql-pe"
  location            = var.location
  resource_group_name = var.resource_group_name
  subnet_id           = var.subnet_ids[0]
  
  private_service_connection {
    name                           = "${var.project_name}-${var.environment}-sql-psc"
    private_connection_resource_id = azurerm_mssql_server.main.id
    subresource_names              = ["sqlServer"]
    is_manual_connection           = false
  }
  
  tags = var.tags
}

data "azurerm_client_config" "current" {}
{{/if}}

{{#if storage.objectStorage}}
# Azure Storage Account
resource "azurerm_storage_account" "main" {
  name                = "${replace(var.project_name, "-", "")}${var.environment}storage"
  resource_group_name = var.resource_group_name
  location            = var.location
  
  account_tier             = "Standard"
  account_replication_type = var.environment == "production" ? "GRS" : "LRS"
  account_kind             = "StorageV2"
  
  min_tls_version                 = "TLS1_2"
  allow_nested_items_to_be_public = false
  
  blob_properties {
    versioning_enabled = var.environment == "production"
    
    delete_retention_policy {
      days = var.backup_retention_days
    }
    
    container_delete_retention_policy {
      days = var.backup_retention_days
    }
  }
  
  network_rules {
    default_action = "Deny"
    bypass         = ["AzureServices"]
  }
  
  tags = var.tags
}

# Storage Container
resource "azurerm_storage_container" "main" {
  name                  = "data"
  storage_account_name  = azurerm_storage_account.main.name
  container_access_type = "private"
}

# Private Endpoint for Storage
resource "azurerm_private_endpoint" "storage" {
  name                = "${var.project_name}-${var.environment}-storage-pe"
  location            = var.location
  resource_group_name = var.resource_group_name
  subnet_id           = var.subnet_ids[0]
  
  private_service_connection {
    name                           = "${var.project_name}-${var.environment}-storage-psc"
    private_connection_resource_id = azurerm_storage_account.main.id
    subresource_names              = ["blob"]
    is_manual_connection           = false
  }
  
  tags = var.tags
}
{{/if}}

{{#if storage.fileSystem}}
# Azure NetApp Files Account
resource "azurerm_netapp_account" "main" {
  name                = "${var.project_name}-${var.environment}-netapp"
  resource_group_name = var.resource_group_name
  location            = var.location
  
  tags = var.tags
}

# NetApp Capacity Pool
resource "azurerm_netapp_pool" "main" {
  name                = "${var.project_name}-${var.environment}-pool"
  account_name        = azurerm_netapp_account.main.name
  resource_group_name = var.resource_group_name
  location            = var.location
  service_level       = "Standard"
  size_in_tb          = 4
  
  tags = var.tags
}

# NetApp Volume
resource "azurerm_netapp_volume" "main" {
  name                = "${var.project_name}-${var.environment}-volume"
  resource_group_name = var.resource_group_name
  location            = var.location
  account_name        = azurerm_netapp_account.main.name
  pool_name           = azurerm_netapp_pool.main.name
  volume_path         = "${var.project_name}-${var.environment}"
  service_level       = "Standard"
  subnet_id           = var.subnet_ids[0]
  protocols           = ["NFSv3"]
  storage_quota_in_gb = 100
  
  export_policy_rule {
    rule_index        = 1
    allowed_clients   = ["0.0.0.0/0"]
    protocols_enabled = ["NFSv3"]
    root_access_enabled = false
    read_only          = false
    read_write         = true
  }
  
  tags = var.tags
}
{{/if}}
{{/eq}}

{{#eq cloudProvider "gcp"}}
{{#if storage.databases}}
# Cloud SQL Instance
resource "google_sql_database_instance" "main" {
  name             = "${var.project_name}-${var.environment}-db"
  database_version = var.database_version
  region           = var.region
  
  settings {
    tier              = var.db_tier
    availability_type = var.environment == "production" ? "REGIONAL" : "ZONAL"
    disk_type         = "PD_SSD"
    disk_size         = var.db_disk_size
    disk_autoresize   = true
    
    backup_configuration {
      enabled                        = true
      start_time                     = "02:00"
      location                       = var.region
      point_in_time_recovery_enabled = true
      
      backup_retention_settings {
        retained_backups = var.backup_retention_days
        retention_unit   = "COUNT"
      }
    }
    
    ip_configuration {
      ipv4_enabled    = false
      private_network = var.network_id
      require_ssl     = true
    }
    
    database_flags {
      name  = "log_checkpoints"
      value = "on"
    }
    
    database_flags {
      name  = "log_connections"
      value = "on"
    }
    
    database_flags {
      name  = "log_disconnections"
      value = "on"
    }
    
    database_flags {
      name  = "log_statement"
      value = "all"
    }
    
    maintenance_window {
      day          = 7
      hour         = 2
      update_track = "stable"
    }
  }
  
  deletion_protection = var.environment == "production"
}

# Database
resource "google_sql_database" "main" {
  name     = replace(var.project_name, "-", "_")
  instance = google_sql_database_instance.main.name
  charset  = "UTF8"
  collation = "en_US.UTF8"
}

# Database User
resource "google_sql_user" "main" {
  name     = var.db_username
  instance = google_sql_database_instance.main.name
  password = var.db_password
}

# SSL Certificate
resource "google_sql_ssl_cert" "client_cert" {
  common_name = "${var.project_name}-${var.environment}-cert"
  instance    = google_sql_database_instance.main.name
}
{{/if}}

{{#if storage.objectStorage}}
# Random ID for bucket naming
resource "random_id" "bucket_suffix" {
  byte_length = 4
}

# Cloud Storage Bucket
resource "google_storage_bucket" "main" {
  name     = "${var.project_name}-${var.environment}-storage-${random_id.bucket_suffix.hex}"
  location = var.region
  
  uniform_bucket_level_access = true
  
  versioning {
    enabled = var.environment == "production"
  }
  
  lifecycle_rule {
    condition {
      age = var.backup_retention_days * 2
    }
    action {
      type = "Delete"
    }
  }
  
  lifecycle_rule {
    condition {
      num_newer_versions = 3
    }
    action {
      type = "Delete"
    }
  }
  
  encryption {
    default_kms_key_name = var.kms_key_id
  }
  
  logging {
    log_bucket        = var.audit_logs_enabled ? google_storage_bucket.access_logs[0].name : null
    log_object_prefix = "access-logs/"
  }
}

# Access Logs Bucket
resource "google_storage_bucket" "access_logs" {
  count = var.audit_logs_enabled ? 1 : 0
  
  name     = "${var.project_name}-${var.environment}-access-logs-${random_id.bucket_suffix.hex}"
  location = var.region
  
  uniform_bucket_level_access = true
  
  lifecycle_rule {
    condition {
      age = var.backup_retention_days
    }
    action {
      type = "Delete"
    }
  }
}
{{/if}}

{{#if storage.fileSystem}}
# Filestore Instance
resource "google_filestore_instance" "main" {
  name     = "${var.project_name}-${var.environment}-filestore"
  location = var.region
  tier     = "STANDARD"
  
  file_shares {
    capacity_gb = 1024
    name        = "share1"
  }
  
  networks {
    network = var.network_id
    modes   = ["MODE_IPV4"]
  }
  
  labels = {
    project     = var.project_name
    environment = var.environment
  }
}
{{/if}}
{{/eq}}