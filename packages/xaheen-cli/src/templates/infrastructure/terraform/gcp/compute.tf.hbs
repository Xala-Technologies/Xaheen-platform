# Google Cloud Compute Configuration
# Comprehensive compute setup with GKE, Cloud Run, and Compute Engine

{{#if compute.kubernetes}}
# Google Kubernetes Engine cluster
resource "google_container_cluster" "main" {
  name     = "${local.name_prefix}-gke"
  location = var.gke_location
  project  = var.project_id
  
  # We can't create a cluster with no node pool defined, but we want to only use
  # separately managed node pools. So we create the smallest possible default
  # node pool and immediately delete it.
  remove_default_node_pool = true
  initial_node_count       = 1
  
  {{#if networking.vpc}}
  network    = google_compute_network.main.name
  subnetwork = google_compute_subnetwork.main.name
  {{/if}}
  
  # Enable Workload Identity
  workload_identity_config {
    workload_pool = "${var.project_id}.svc.id.goog"
  }
  
  # Enable network policy
  network_policy {
    enabled = true
    provider = "CALICO"
  }
  
  # IP allocation policy for VPC-native cluster
  {{#if networking.vpc}}
  ip_allocation_policy {
    cluster_secondary_range_name  = "pods"
    services_secondary_range_name = "services"
  }
  {{/if}}
  
  # Master auth configuration
  master_auth {
    client_certificate_config {
      issue_client_certificate = false
    }
  }
  
  # Master authorized networks
  master_authorized_networks_config {
    {{#each compute.authorizedNetworks}}
    cidr_blocks {
      cidr_block   = "{{cidr}}"
      display_name = "{{name}}"
    }
    {{/each}}
  }
  
  # Private cluster configuration
  {{#if compute.privateCluster}}
  private_cluster_config {
    enable_private_nodes    = true
    enable_private_endpoint = false
    master_ipv4_cidr_block  = var.master_ipv4_cidr_block
    
    master_global_access_config {
      enabled = true
    }
  }
  {{/if}}
  
  # Addons
  addons_config {
    http_load_balancing {
      disabled = false
    }
    
    horizontal_pod_autoscaling {
      disabled = false
    }
    
    network_policy_config {
      disabled = false
    }
    
    dns_cache_config {
      enabled = true
    }
    
    gce_persistent_disk_csi_driver_config {
      enabled = true
    }
    
    {{#if monitoring.logging}}
    cloudrun_config {
      disabled = false
    }
    {{/if}}
  }
  
  # Enable binary authorization
  {{#if security.binaryAuthorization}}
  binary_authorization {
    evaluation_mode = "PROJECT_SINGLETON_POLICY_ENFORCE"
  }
  {{/if}}
  
  # Database encryption
  {{#if security.keyManagement}}
  database_encryption {
    state    = "ENCRYPTED"
    key_name = google_kms_crypto_key.main.id
  }
  {{/if}}
  
  # Maintenance policy
  maintenance_policy {
    daily_maintenance_window {
      start_time = "03:00"
    }
  }
  
  # Resource labels
  resource_labels = local.labels
  
  depends_on = [
    google_project_service.apis,
    {{#if networking.vpc}}
    google_compute_subnetwork.main,
    {{/if}}
    {{#if security.keyManagement}}
    google_kms_crypto_key.main
    {{/if}}
  ]
}

# Primary node pool
resource "google_container_node_pool" "primary" {
  name       = "${local.name_prefix}-primary-pool"
  location   = var.gke_location
  cluster    = google_container_cluster.main.name
  project    = var.project_id
  
  initial_node_count = var.gke_initial_node_count
  
  autoscaling {
    min_node_count = var.gke_min_node_count
    max_node_count = var.gke_max_node_count
  }
  
  management {
    auto_repair  = true
    auto_upgrade = true
  }
  
  node_config {
    preemptible  = var.environment != "production"
    machine_type = var.gke_machine_type
    disk_size_gb = var.gke_disk_size
    disk_type    = "pd-ssd"
    image_type   = "COS_CONTAINERD"
    
    service_account = google_service_account.gke_nodes.email
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only",
      "https://www.googleapis.com/auth/servicecontrol",
      "https://www.googleapis.com/auth/service.management.readonly",
      "https://www.googleapis.com/auth/trace.append"
    ]
    
    labels = merge(local.labels, {
      node-pool = "primary"
    })
    
    tags = ["gke-node", "${local.name_prefix}-gke"]
    
    # Enable Workload Identity
    workload_metadata_config {
      mode = "GKE_METADATA"
    }
    
    # Security configurations
    shielded_instance_config {
      enable_secure_boot          = true
      enable_integrity_monitoring = true
    }
    
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  # Upgrade settings
  upgrade_settings {
    max_surge       = 1
    max_unavailable = 0
  }
  
  depends_on = [google_service_account.gke_nodes]
}

# Service account for GKE nodes
resource "google_service_account" "gke_nodes" {
  account_id   = "${var.project_name}-gke-nodes"
  display_name = "GKE Nodes Service Account"
  description  = "Service account for GKE cluster nodes"
  project      = var.project_id
}

# IAM bindings for GKE nodes
resource "google_project_iam_member" "gke_nodes" {
  for_each = toset([
    "roles/logging.logWriter",
    "roles/monitoring.metricWriter",
    "roles/monitoring.viewer",
    "roles/stackdriver.resourceMetadata.writer"
  ])
  
  project = var.project_id
  role    = each.key
  member  = "serviceAccount:${google_service_account.gke_nodes.email}"
}

# Spot node pool for non-critical workloads
{{#if compute.spotInstances}}
resource "google_container_node_pool" "spot" {
  name       = "${local.name_prefix}-spot-pool"
  location   = var.gke_location
  cluster    = google_container_cluster.main.name
  project    = var.project_id
  
  initial_node_count = 0
  
  autoscaling {
    min_node_count = 0
    max_node_count = var.gke_spot_max_nodes
  }
  
  management {
    auto_repair  = true
    auto_upgrade = true
  }
  
  node_config {
    preemptible  = true
    spot         = true
    machine_type = var.gke_spot_machine_type
    disk_size_gb = var.gke_disk_size
    disk_type    = "pd-standard"
    image_type   = "COS_CONTAINERD"
    
    service_account = google_service_account.gke_nodes.email
    oauth_scopes = [
      "https://www.googleapis.com/auth/logging.write",
      "https://www.googleapis.com/auth/monitoring",
      "https://www.googleapis.com/auth/devstorage.read_only"
    ]
    
    labels = merge(local.labels, {
      node-pool = "spot"
    })
    
    tags = ["gke-node", "${local.name_prefix}-gke", "spot"]
    
    taint {
      key    = "spot"
      value  = "true"
      effect = "NO_SCHEDULE"
    }
    
    workload_metadata_config {
      mode = "GKE_METADATA"
    }
    
    shielded_instance_config {
      enable_secure_boot          = true
      enable_integrity_monitoring = true
    }
    
    metadata = {
      disable-legacy-endpoints = "true"
    }
  }
  
  upgrade_settings {
    max_surge       = 1
    max_unavailable = 1
  }
}
{{/if}}
{{/if}}

{{#if compute.cloudRun}}
# Cloud Run services
{{#each compute.services}}
resource "google_cloud_run_service" "{{name}}" {
  name     = "${local.name_prefix}-{{name}}"
  location = var.region
  project  = var.project_id
  
  template {
    metadata {
      annotations = {
        "autoscaling.knative.dev/minScale" = "{{minInstances}}"
        "autoscaling.knative.dev/maxScale" = "{{maxInstances}}"
        "run.googleapis.com/cpu-throttling" = "{{cpuThrottling}}"
        {{#if ../networking.vpc}}
        "run.googleapis.com/vpc-access-connector" = google_vpc_access_connector.main.name
        "run.googleapis.com/vpc-access-egress" = "{{vpcEgress}}"
        {{/if}}
      }
      
      labels = merge(local.labels, {
        service = "{{name}}"
      })
    }
    
    spec {
      container_concurrency = {{concurrency}}
      timeout_seconds      = {{timeoutSeconds}}
      service_account_name = google_service_account.cloud_run.email
      
      containers {
        image = "{{image}}"
        
        ports {
          container_port = {{containerPort}}
        }
        
        resources {
          limits = {
            cpu    = "{{cpu}}"
            memory = "{{memory}}"
          }
          requests = {
            cpu    = "{{cpuRequest}}"
            memory = "{{memoryRequest}}"
          }
        }
        
        {{#each environmentVariables}}
        env {
          name  = "{{name}}"
          value = "{{value}}"
        }
        {{/each}}
        
        {{#each secrets}}
        env {
          name = "{{name}}"
          value_from {
            secret_key_ref {
              name = "{{secretName}}"
              key  = "{{key}}"
            }
          }
        }
        {{/each}}
        
        # Health check
        liveness_probe {
          http_get {
            path = "/health"
            port = {{containerPort}}
          }
          initial_delay_seconds = 30
          period_seconds        = 10
          timeout_seconds       = 5
          failure_threshold     = 3
        }
        
        startup_probe {
          http_get {
            path = "/health"
            port = {{containerPort}}
          }
          initial_delay_seconds = 10
          period_seconds        = 3
          timeout_seconds       = 2
          failure_threshold     = 10
        }
      }
    }
  }
  
  traffic {
    percent         = 100
    latest_revision = true
  }
  
  depends_on = [
    google_project_service.apis,
    google_service_account.cloud_run
  ]
}

# IAM policy for Cloud Run service {{name}}
{{#if public}}
resource "google_cloud_run_service_iam_member" "{{name}}_public" {
  service  = google_cloud_run_service.{{name}}.name
  location = google_cloud_run_service.{{name}}.location
  project  = var.project_id
  role     = "roles/run.invoker"
  member   = "allUsers"
}
{{else}}
resource "google_cloud_run_service_iam_member" "{{name}}_internal" {
  service  = google_cloud_run_service.{{name}}.name
  location = google_cloud_run_service.{{name}}.location
  project  = var.project_id
  role     = "roles/run.invoker"
  member   = "serviceAccount:${google_service_account.cloud_run.email}"
}
{{/if}}

# Custom domain mapping for {{name}}
{{#if customDomain}}
resource "google_cloud_run_domain_mapping" "{{name}}" {
  location = var.region
  name     = "{{customDomain}}"
  project  = var.project_id

  metadata {
    namespace = var.project_id
    labels    = local.labels
  }

  spec {
    route_name = google_cloud_run_service.{{name}}.name
  }
}
{{/if}}
{{/each}}

# VPC Connector for Cloud Run
{{#if networking.vpc}}
resource "google_vpc_access_connector" "main" {
  name          = "${local.name_prefix}-vpc-connector"
  project       = var.project_id
  region        = var.region
  network       = google_compute_network.main.name
  ip_cidr_range = var.vpc_connector_cidr
  
  min_instances = var.vpc_connector_min_instances
  max_instances = var.vpc_connector_max_instances
  
  depends_on = [
    google_project_service.apis,
    google_compute_network.main
  ]
}
{{/if}}
{{/if}}

{{#if compute.instances}}
# Compute Engine instances
{{#each compute.instances}}
resource "google_compute_instance" "{{name}}" {
  name         = "${local.name_prefix}-{{name}}"
  machine_type = "{{instanceType}}"
  zone         = var.zone
  project      = var.project_id
  
  tags = concat(["{{name}}"], {{securityGroups}})
  
  boot_disk {
    initialize_params {
      image = var.instance_image
      size  = var.instance_disk_size
      type  = "pd-ssd"
      
      {{#if ../security.encryption}}
      kms_key_self_link = google_kms_crypto_key.main.id
      {{/if}}
    }
  }
  
  {{#if ../networking.vpc}}
  network_interface {
    network    = google_compute_network.main.name
    subnetwork = google_compute_subnetwork.main.name
    
    {{#if staticIP}}
    access_config {
      nat_ip = google_compute_address.{{name}}.address
    }
    {{else}}
    access_config {
      // Ephemeral IP
    }
    {{/if}}
  }
  {{else}}
  network_interface {
    network = "default"
    
    {{#if staticIP}}
    access_config {
      nat_ip = google_compute_address.{{name}}.address
    }
    {{else}}
    access_config {
      // Ephemeral IP
    }
    {{/if}}
  }
  {{/if}}
  
  service_account {
    email  = google_service_account.compute_engine.email
    scopes = ["cloud-platform"]
  }
  
  {{#if userData}}
  metadata_startup_script = "{{userData}}"
  {{/if}}
  
  {{#if keyPair}}
  metadata = {
    ssh-keys = "{{keyPair}}"
  }
  {{/if}}
  
  # Security configurations
  shielded_instance_config {
    enable_secure_boot          = true
    enable_integrity_monitoring = true
    enable_vtpm                 = true
  }
  
  labels = merge(local.labels, {
    instance = "{{name}}"
  })
  
  depends_on = [
    google_project_service.apis,
    google_service_account.compute_engine
  ]
}

# Static IP for instance {{name}}
{{#if staticIP}}
resource "google_compute_address" "{{name}}" {
  name    = "${local.name_prefix}-{{name}}-ip"
  region  = var.region
  project = var.project_id
}
{{/if}}
{{/each}}

# Instance group for load balancing
{{#if compute.loadBalancer}}
resource "google_compute_instance_group" "main" {
  name    = "${local.name_prefix}-instance-group"
  zone    = var.zone
  project = var.project_id
  
  instances = [
    {{#each compute.instances}}
    google_compute_instance.{{name}}.id,
    {{/each}}
  ]
  
  named_port {
    name = "http"
    port = "80"
  }
  
  named_port {
    name = "https"
    port = "443"
  }
}

# Health check for load balancer
resource "google_compute_health_check" "main" {
  name    = "${local.name_prefix}-health-check"
  project = var.project_id
  
  timeout_sec         = 5
  check_interval_sec  = 10
  healthy_threshold   = 2
  unhealthy_threshold = 3
  
  http_health_check {
    request_path = "/health"
    port         = "80"
  }
}

# Backend service
resource "google_compute_backend_service" "main" {
  name        = "${local.name_prefix}-backend"
  project     = var.project_id
  protocol    = "HTTP"
  timeout_sec = 30
  
  backend {
    group = google_compute_instance_group.main.id
  }
  
  health_checks = [google_compute_health_check.main.id]
}

# URL map
resource "google_compute_url_map" "main" {
  name            = "${local.name_prefix}-url-map"
  project         = var.project_id
  default_service = google_compute_backend_service.main.id
}

# HTTP proxy
resource "google_compute_target_http_proxy" "main" {
  name    = "${local.name_prefix}-http-proxy"
  project = var.project_id
  url_map = google_compute_url_map.main.id
}

# Global forwarding rule
resource "google_compute_global_forwarding_rule" "main" {
  name       = "${local.name_prefix}-forwarding-rule"
  project    = var.project_id
  target     = google_compute_target_http_proxy.main.id
  port_range = "80"
  ip_address = google_compute_global_address.main.address
}

# Global IP address
resource "google_compute_global_address" "main" {
  name    = "${local.name_prefix}-global-ip"
  project = var.project_id
}
{{/if}}
{{/if}}