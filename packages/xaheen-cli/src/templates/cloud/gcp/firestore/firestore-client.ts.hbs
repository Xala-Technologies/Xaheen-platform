/**
 * Firestore Client Configuration
 * Type-safe Firestore client for {{projectName}}
 */

import { 
  initializeApp, 
  getApps, 
  FirebaseApp,
  FirebaseOptions 
} from 'firebase/app';
import {
  getFirestore,
  Firestore,
  connectFirestoreEmulator,
  enableMultiTabIndexedDbPersistence,
  enableNetwork,
  disableNetwork,
  clearIndexedDbPersistence,
  terminate,
  collection,
  doc,
  query,
  where,
  orderBy,
  limit,
  startAfter,
  endBefore,
  getDocs,
  getDoc,
  addDoc,
  setDoc,
  updateDoc,
  deleteDoc,
  writeBatch,
  runTransaction,
  onSnapshot,
  serverTimestamp,
  arrayUnion,
  arrayRemove,
  increment,
  DocumentReference,
  DocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  Query,
  WriteBatch,
  Transaction,
  FieldValue,
  Timestamp,
  GeoPoint,
  Unsubscribe
} from 'firebase/firestore';
import { getAuth, User } from 'firebase/auth';
import { logger } from '../functions/src/utils/logger';

/**
 * Firebase configuration
 */
const firebaseConfig: FirebaseOptions = {
  apiKey: process.env.FIREBASE_API_KEY,
  authDomain: process.env.FIREBASE_AUTH_DOMAIN || '{{projectId}}.firebaseapp.com',
  projectId: process.env.FIREBASE_PROJECT_ID || '{{projectId}}',
  storageBucket: process.env.FIREBASE_STORAGE_BUCKET || '{{projectId}}.appspot.com',
  messagingSenderId: process.env.FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.FIREBASE_APP_ID,
  measurementId: process.env.FIREBASE_MEASUREMENT_ID
};

/**
 * Document interfaces for type safety
 */
export interface BaseDocument {
  id?: string;
  createdAt: Timestamp;
  updatedAt: Timestamp;
}

export interface UserDocument extends BaseDocument {
  email: string;
  name: string;
  avatar?: string;
  role: 'user' | 'admin' | 'moderator';
  organizations: string[];
  permissions: string[];
  lastLoginAt?: Timestamp;
  isActive: boolean;
  preferences: UserPreferences;
  gdprConsent: GDPRConsent;
}

export interface UserPreferences {
  language: string;
  timezone: string;
  notifications: {
    email: boolean;
    push: boolean;
    sms: boolean;
  };
  privacy: {
    profileVisible: boolean;
    shareAnalytics: boolean;
  };
}

export interface GDPRConsent {
  consent: boolean;
  purpose: string;
  version: string;
  timestamp: Timestamp;
  ipAddress?: string;
  userAgent?: string;
}

export interface OrganizationDocument extends BaseDocument {
  name: string;
  description?: string;
  website?: string;
  address?: Address;
  contactEmail: string;
  phoneNumber?: string;
  orgNumber?: string; // Norwegian organization number
  members: Record<string, OrganizationMember>;
  settings: OrganizationSettings;
  subscription: SubscriptionInfo;
}

export interface Address {
  street: string;
  city: string;
  postalCode: string;
  country: string;
  coordinates?: GeoPoint;
}

export interface OrganizationMember {
  role: 'owner' | 'admin' | 'member' | 'viewer';
  permissions: string[];
  joinedAt: Timestamp;
  invitedBy?: string;
}

export interface OrganizationSettings {
  allowGuestAccess: boolean;
  requireTwoFactor: boolean;
  dataRetentionDays: number;
  backupEnabled: boolean;
  auditLogEnabled: boolean;
}

export interface SubscriptionInfo {
  plan: 'free' | 'pro' | 'enterprise';
  status: 'active' | 'cancelled' | 'expired' | 'trial';
  currentPeriodStart: Timestamp;
  currentPeriodEnd: Timestamp;
  customerId?: string;
  subscriptionId?: string;
}

export interface ProjectDocument extends BaseDocument {
  name: string;
  description?: string;
  organizationId: string;
  status: 'active' | 'archived' | 'deleted';
  visibility: 'private' | 'organization' | 'public';
  members: Record<string, ProjectMember>;
  tags: string[];
  metadata: Record<string, any>;
}

export interface ProjectMember {
  role: 'owner' | 'admin' | 'editor' | 'viewer';
  permissions: string[];
  addedAt: Timestamp;
  addedBy: string;
}

export interface NotificationDocument extends BaseDocument {
  userId: string;
  title: string;
  message: string;
  type: 'info' | 'warning' | 'error' | 'success';
  read: boolean;
  readAt?: Timestamp;
  actionUrl?: string;
  metadata?: Record<string, any>;
}

export interface AuditLogDocument extends BaseDocument {
  userId: string;
  action: string;
  resource: string;
  resourceId: string;
  metadata: Record<string, any>;
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
}

export interface FileUploadDocument extends BaseDocument {
  filename: string;
  originalName: string;
  contentType: string;
  size: number;
  uploadedBy: string;
  organizationId?: string;
  projectId?: string;
  storagePath: string;
  downloadUrl?: string;
  isPublic: boolean;
  metadata: Record<string, any>;
}

/**
 * Collection names (centralized for consistency)
 */
export const COLLECTIONS = {
  USERS: 'users',
  USER_PRIVATE: 'private',
  USER_PREFERENCES: 'preferences',
  USER_ACTIVITY: 'activity',
  PROFILES: 'profiles',
  ORGANIZATIONS: 'organizations',
  ORG_MEMBERS: 'members',
  ORG_SETTINGS: 'settings',
  PROJECTS: 'projects',
  PROJECT_DOCUMENTS: 'documents',
  PROJECT_COMMENTS: 'comments',
  NOTIFICATIONS: 'notifications',
  AUDIT_LOGS: 'audit_logs',
  GDPR_CONSENTS: 'gdpr_consents',
  DATA_PROCESSING: 'data_processing',
  NORWEGIAN_COMPLIANCE: 'norwegian_compliance',
  BANKID_SESSIONS: 'bankid_sessions',
  VIPPS_PAYMENTS: 'vipps_payments',
  FILE_UPLOADS: 'file_uploads',
  ANALYTICS: 'analytics',
  FEATURE_FLAGS: 'feature_flags',
  AB_TESTS: 'ab_tests',
  SUPPORT_TICKETS: 'support_tickets',
  PUBLIC_CONTENT: 'public_content',
  TRANSLATIONS: 'translations',
  RATE_LIMITS: 'rate_limits',
  MONITORING: 'monitoring'
} as const;

/**
 * Firestore Client Class
 */
export class FirestoreClient {
  private app: FirebaseApp;
  private db: Firestore;
  private auth: any;

  constructor() {
    // Initialize Firebase app
    this.app = getApps().length === 0 ? initializeApp(firebaseConfig) : getApps()[0];
    
    // Initialize Firestore
    this.db = getFirestore(this.app);
    this.auth = getAuth(this.app);

    // Connect to emulator in development
    if (process.env.NODE_ENV === 'development' && !process.env.FIRESTORE_EMULATOR_CONNECTED) {
      try {
        connectFirestoreEmulator(this.db, 'localhost', 8080);
        process.env.FIRESTORE_EMULATOR_CONNECTED = 'true';
        logger.info('Connected to Firestore emulator');
      } catch (error) {
        logger.warn('Failed to connect to Firestore emulator', { error: error.message });
      }
    }

    // Enable offline persistence in browser environments
    if (typeof window !== 'undefined') {
      this.enableOfflinePersistence();
    }
  }

  /**
   * Enable offline persistence
   */
  private async enableOfflinePersistence(): Promise<void> {
    try {
      await enableMultiTabIndexedDbPersistence(this.db);
      logger.info('Firestore offline persistence enabled');
    } catch (error) {
      if (error.code === 'failed-precondition') {
        logger.warn('Multiple tabs open, offline persistence disabled');
      } else if (error.code === 'unimplemented') {
        logger.warn('Browser does not support offline persistence');
      } else {
        logger.error('Failed to enable offline persistence', { error: error.message });
      }
    }
  }

  /**
   * Get Firestore instance
   */
  getFirestore(): Firestore {
    return this.db;
  }

  /**
   * Get current user
   */
  getCurrentUser(): User | null {
    return this.auth.currentUser;
  }

  /**
   * Check if user is authenticated
   */
  isAuthenticated(): boolean {
    return this.auth.currentUser !== null;
  }

  /**
   * Collection helpers with type safety
   */
  users(): CollectionReference<UserDocument> {
    return collection(this.db, COLLECTIONS.USERS) as CollectionReference<UserDocument>;
  }

  user(uid: string): DocumentReference<UserDocument> {
    return doc(this.db, COLLECTIONS.USERS, uid) as DocumentReference<UserDocument>;
  }

  organizations(): CollectionReference<OrganizationDocument> {
    return collection(this.db, COLLECTIONS.ORGANIZATIONS) as CollectionReference<OrganizationDocument>;
  }

  organization(orgId: string): DocumentReference<OrganizationDocument> {
    return doc(this.db, COLLECTIONS.ORGANIZATIONS, orgId) as DocumentReference<OrganizationDocument>;
  }

  projects(): CollectionReference<ProjectDocument> {
    return collection(this.db, COLLECTIONS.PROJECTS) as CollectionReference<ProjectDocument>;
  }

  project(projectId: string): DocumentReference<ProjectDocument> {
    return doc(this.db, COLLECTIONS.PROJECTS, projectId) as DocumentReference<ProjectDocument>;
  }

  notifications(userId: string): CollectionReference<NotificationDocument> {
    return collection(this.db, COLLECTIONS.NOTIFICATIONS) as CollectionReference<NotificationDocument>;
  }

  auditLogs(): CollectionReference<AuditLogDocument> {
    return collection(this.db, COLLECTIONS.AUDIT_LOGS) as CollectionReference<AuditLogDocument>;
  }

  fileUploads(): CollectionReference<FileUploadDocument> {
    return collection(this.db, COLLECTIONS.FILE_UPLOADS) as CollectionReference<FileUploadDocument>;
  }

  /**
   * User operations
   */
  async createUser(userData: Omit<UserDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const userRef = doc(this.users());
    const timestamp = serverTimestamp() as Timestamp;
    
    await setDoc(userRef, {
      ...userData,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    // Log user creation
    await this.logAuditEvent('user.created', 'user', userRef.id, { email: userData.email });

    return userRef.id;
  }

  async updateUser(uid: string, updates: Partial<UserDocument>): Promise<void> {
    const userRef = this.user(uid);
    
    await updateDoc(userRef, {
      ...updates,
      updatedAt: serverTimestamp()
    });

    // Log user update
    await this.logAuditEvent('user.updated', 'user', uid, updates);
  }

  async getUserProfile(uid: string): Promise<UserDocument | null> {
    const userDoc = await getDoc(this.user(uid));
    return userDoc.exists() ? { id: userDoc.id, ...userDoc.data() } : null;
  }

  /**
   * Organization operations
   */
  async createOrganization(orgData: Omit<OrganizationDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const orgRef = doc(this.organizations());
    const timestamp = serverTimestamp() as Timestamp;
    
    await setDoc(orgRef, {
      ...orgData,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    // Log organization creation
    await this.logAuditEvent('organization.created', 'organization', orgRef.id, { name: orgData.name });

    return orgRef.id;
  }

  async getUserOrganizations(userId: string): Promise<OrganizationDocument[]> {
    const orgsQuery = query(
      this.organizations(),
      where(`members.${userId}`, '!=', null)
    );
    
    const snapshot = await getDocs(orgsQuery);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  }

  /**
   * Project operations
   */
  async createProject(projectData: Omit<ProjectDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const projectRef = doc(this.projects());
    const timestamp = serverTimestamp() as Timestamp;
    
    await setDoc(projectRef, {
      ...projectData,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    // Log project creation
    await this.logAuditEvent('project.created', 'project', projectRef.id, { 
      name: projectData.name,
      organizationId: projectData.organizationId
    });

    return projectRef.id;
  }

  async getUserProjects(userId: string): Promise<ProjectDocument[]> {
    const projectsQuery = query(
      this.projects(),
      where(`members.${userId}`, '!=', null),
      orderBy('updatedAt', 'desc')
    );
    
    const snapshot = await getDocs(projectsQuery);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  }

  /**
   * Notification operations
   */
  async createNotification(notificationData: Omit<NotificationDocument, 'id' | 'createdAt' | 'updatedAt'>): Promise<string> {
    const notificationRef = doc(collection(this.db, COLLECTIONS.NOTIFICATIONS));
    const timestamp = serverTimestamp() as Timestamp;
    
    await setDoc(notificationRef, {
      ...notificationData,
      createdAt: timestamp,
      updatedAt: timestamp
    });

    return notificationRef.id;
  }

  async markNotificationAsRead(notificationId: string): Promise<void> {
    const notificationRef = doc(this.db, COLLECTIONS.NOTIFICATIONS, notificationId);
    
    await updateDoc(notificationRef, {
      read: true,
      readAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });
  }

  async getUserNotifications(userId: string, limit: number = 20): Promise<NotificationDocument[]> {
    const notificationsQuery = query(
      collection(this.db, COLLECTIONS.NOTIFICATIONS),
      where('userId', '==', userId),
      orderBy('createdAt', 'desc'),
      limit(limit)
    );
    
    const snapshot = await getDocs(notificationsQuery);
    return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
  }

  /**
   * Real-time subscriptions
   */
  subscribeToUserNotifications(
    userId: string,
    callback: (notifications: NotificationDocument[]) => void
  ): Unsubscribe {
    const notificationsQuery = query(
      collection(this.db, COLLECTIONS.NOTIFICATIONS),
      where('userId', '==', userId),
      where('read', '==', false),
      orderBy('createdAt', 'desc'),
      limit(10)
    );

    return onSnapshot(notificationsQuery, (snapshot) => {
      const notifications = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data()
      })) as NotificationDocument[];
      
      callback(notifications);
    });
  }

  subscribeToProject(
    projectId: string,
    callback: (project: ProjectDocument | null) => void
  ): Unsubscribe {
    const projectRef = this.project(projectId);

    return onSnapshot(projectRef, (doc) => {
      if (doc.exists()) {
        callback({ id: doc.id, ...doc.data() });
      } else {
        callback(null);
      }
    });
  }

  /**
   * Batch operations
   */
  async batchWrite(operations: Array<{
    type: 'set' | 'update' | 'delete';
    ref: DocumentReference;
    data?: any;
  }>): Promise<void> {
    const batch = writeBatch(this.db);

    for (const operation of operations) {
      switch (operation.type) {
        case 'set':
          batch.set(operation.ref, operation.data);
          break;
        case 'update':
          batch.update(operation.ref, operation.data);
          break;
        case 'delete':
          batch.delete(operation.ref);
          break;
      }
    }

    await batch.commit();
  }

  /**
   * Transaction operations
   */
  async runTransaction<T>(
    updateFunction: (transaction: Transaction) => Promise<T>
  ): Promise<T> {
    return await runTransaction(this.db, updateFunction);
  }

  /**
   * GDPR Compliance operations
   */
  async recordGDPRConsent(userId: string, consent: GDPRConsent): Promise<void> {
    const consentRef = doc(this.db, COLLECTIONS.GDPR_CONSENTS, userId);
    
    await setDoc(consentRef, {
      ...consent,
      createdAt: serverTimestamp(),
      updatedAt: serverTimestamp()
    });

    // Log consent
    await this.logAuditEvent('gdpr.consent_recorded', 'user', userId, {
      consent: consent.consent,
      purpose: consent.purpose
    });
  }

  async deleteUserData(userId: string): Promise<void> {
    // This would implement the "right to be forgotten"
    // In a real implementation, you'd need to carefully delete
    // or anonymize all user data across all collections
    
    const batch = writeBatch(this.db);
    
    // Delete user document
    batch.delete(this.user(userId));
    
    // Delete user private data, preferences, etc.
    // You'd need to implement comprehensive data deletion here
    
    await batch.commit();

    // Log data deletion
    await this.logAuditEvent('gdpr.data_deleted', 'user', userId, {
      deletedBy: this.getCurrentUser()?.uid || 'system'
    });
  }

  /**
   * Audit logging
   */
  private async logAuditEvent(
    action: string,
    resource: string,
    resourceId: string,
    metadata: Record<string, any> = {}
  ): Promise<void> {
    const currentUser = this.getCurrentUser();
    if (!currentUser) return;

    const auditRef = doc(this.auditLogs());
    const timestamp = serverTimestamp() as Timestamp;

    await setDoc(auditRef, {
      userId: currentUser.uid,
      action,
      resource,
      resourceId,
      metadata,
      createdAt: timestamp,
      updatedAt: timestamp
    });
  }

  /**
   * Utility methods
   */
  async enableNetwork(): Promise<void> {
    await enableNetwork(this.db);
  }

  async disableNetwork(): Promise<void> {
    await disableNetwork(this.db);
  }

  async clearPersistence(): Promise<void> {
    await clearIndexedDbPersistence(this.db);
  }

  async terminate(): Promise<void> {
    await terminate(this.db);
  }

  /**
   * Helper for server timestamps
   */
  serverTimestamp(): FieldValue {
    return serverTimestamp();
  }

  /**
   * Helper for array operations
   */
  arrayUnion(...elements: any[]): FieldValue {
    return arrayUnion(...elements);
  }

  arrayRemove(...elements: any[]): FieldValue {
    return arrayRemove(...elements);
  }

  /**
   * Helper for numeric increments
   */
  increment(n: number): FieldValue {
    return increment(n);
  }
}

// Export singleton instance
export const firestoreClient = new FirestoreClient();

// Re-export Firestore types for convenience
export {
  Timestamp,
  GeoPoint,
  DocumentReference,
  DocumentSnapshot,
  QuerySnapshot,
  CollectionReference,
  Query,
  WriteBatch,
  Transaction,
  FieldValue,
  Unsubscribe
};