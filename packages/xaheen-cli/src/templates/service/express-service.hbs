/**
 * {{className}} - Express Service
 *
 * Generated by Xaheen CLI Service Generator
 * @since {{generatedAt}}
 */

import { {{repositoryName}} } from '../repositories/{{name}}.repository.js';
import { {{modelName}}Repository } from '../interfaces/{{name}}.service.interface.js';
{{#if validation}}
import { validate{{modelName}} } from '../validation/{{name}}.validation.js';
{{/if}}
{{#if events}}
import { EventEmitter } from 'events';
{{/if}}
{{#if caching}}
import { CacheService } from '../services/cache.service.js';
{{/if}}
{{#if logging}}
import { Logger } from '../utils/logger.js';
{{/if}}
import { AppError } from '../utils/app-error.js';
import type {
  {{modelName}},
  Create{{modelName}}Input,
  Update{{modelName}}Input,
  {{modelName}}ListResponse,
  FindManyOptions,
} from '../types/{{name}}.types.js';

/**
 * {{className}} - Business Logic Service
 * 
 * This service encapsulates all business logic for {{modelName}} operations.
 * It provides a clean API for controllers and handles validation, caching, and events.
 */
export class {{className}}{{#if events}} extends EventEmitter{{/if}} {
  {{#if logging}}
  private readonly logger = new Logger('{{className}}');
  {{/if}}

  constructor(
    private readonly {{camelCase repositoryName}}: {{repositoryName}},
    {{#if caching}}
    private readonly cacheService: CacheService,
    {{/if}}
  ) {
    {{#if events}}
    super();
    {{/if}}
    {{#if logging}}
    this.logger.info('{{className}} initialized');
    {{/if}}
  }

{{#each methods}}
  /**
   * {{description}}
   */
  async {{name}}({{#each parameters}}{{name}}{{#if optional}}?{{/if}}: {{type}}{{#unless @last}}, {{/unless}}{{/each}}): {{returnType}} {
    {{#if ../logging}}
    this.logger.debug('{{name}} method called', { {{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}} });
    {{/if}}

    try {
      {{#if (eq name 'findMany')}}
      {{#if ../caching}}
      // Check cache first
      const cacheKey = `{{../name}}:list:${JSON.stringify(options || {})}`;
      const cached = await this.cacheService.get(cacheKey);
      if (cached) {
        {{#if ../logging}}
        this.logger.debug('Returning cached result for findMany');
        {{/if}}
        return cached;
      }
      {{/if}}

      const result = await this.{{../camelCase repositoryName}}.findMany(options);

      {{#if ../caching}}
      // Cache the result for 5 minutes
      await this.cacheService.set(cacheKey, result, 300);
      {{/if}}

      {{#if ../events}}
      this.emit('{{../name}}:found:many', { count: result.data.length, options });
      {{/if}}

      return result;
      {{else if (eq name 'findById')}}
      {{#if ../validation}}
      // Validate ID format
      const validatedId = validate{{../modelName}}.id({ id });
      const entityId = validatedId.id;
      {{else}}
      const entityId = id;
      {{/if}}

      {{#if ../caching}}
      // Check cache first
      const cacheKey = `{{../name}}:${entityId}`;
      const cached = await this.cacheService.get(cacheKey);
      if (cached) {
        {{#if ../logging}}
        this.logger.debug('Returning cached {{../name}}', { id: entityId });
        {{/if}}
        return cached;
      }
      {{/if}}

      const {{../camelCase name}} = await this.{{../camelCase repositoryName}}.findById(entityId);

      if (!{{../camelCase name}}) {
        {{#if ../logging}}
        this.logger.warn('{{../modelName}} not found', { id: entityId });
        {{/if}}
        return null;
      }

      {{#if ../caching}}
      // Cache the result for 5 minutes
      await this.cacheService.set(cacheKey, {{../camelCase name}}, 300);
      {{/if}}

      {{#if ../events}}
      this.emit('{{../name}}:found', { {{../name}}: {{../camelCase name}} });
      {{/if}}

      return {{../camelCase name}};
      {{else if (eq name 'create')}}
      {{#if ../validation}}
      // Validate input data
      const validatedInput = validate{{../modelName}}.create(input);
      {{else}}
      const validatedInput = input;
      {{/if}}

      // Business logic validation
      await this.validateCreateInput(validatedInput);

      const {{../camelCase name}} = await this.{{../camelCase repositoryName}}.create(validatedInput);

      {{#if ../caching}}
      // Invalidate list cache
      await this.cacheService.invalidatePattern(`{{../name}}:list:*`);
      
      // Cache the new entity
      await this.cacheService.set(`{{../name}}:${{{../camelCase name}}.id}`, {{../camelCase name}}, 300);
      {{/if}}

      {{#if ../events}}
      this.emit('{{../name}}:created', { {{../name}}: {{../camelCase name}} });
      {{/if}}

      {{#if ../logging}}
      this.logger.info('{{../modelName}} created successfully', { id: {{../camelCase name}}.id });
      {{/if}}

      return {{../camelCase name}};
      {{else if (eq name 'update')}}
      {{#if ../validation}}
      // Validate ID and input data
      const validatedId = validate{{../modelName}}.id({ id });
      const validatedInput = validate{{../modelName}}.update(input);
      const entityId = validatedId.id;
      {{else}}
      const entityId = id;
      const validatedInput = input;
      {{/if}}

      // Check if entity exists
      const existing = await this.{{../camelCase repositoryName}}.findById(entityId);
      if (!existing) {
        {{#if ../logging}}
        this.logger.warn('{{../modelName}} not found for update', { id: entityId });
        {{/if}}
        return null;
      }

      // Business logic validation
      await this.validateUpdateInput(entityId, validatedInput, existing);

      const {{../camelCase name}} = await this.{{../camelCase repositoryName}}.update(entityId, validatedInput);

      {{#if ../caching}}
      // Invalidate related caches
      await this.cacheService.delete(`{{../name}}:${entityId}`);
      await this.cacheService.invalidatePattern(`{{../name}}:list:*`);
      {{/if}}

      {{#if ../events}}
      this.emit('{{../name}}:updated', { {{../name}}: {{../camelCase name}}, previous: existing });
      {{/if}}

      {{#if ../logging}}
      this.logger.info('{{../modelName}} updated successfully', { id: entityId });
      {{/if}}

      return {{../camelCase name}};
      {{else if (eq name 'delete')}}
      {{#if ../validation}}
      // Validate ID format
      const validatedId = validate{{../modelName}}.id({ id });
      const entityId = validatedId.id;
      {{else}}
      const entityId = id;
      {{/if}}

      // Check if entity exists
      const existing = await this.{{../camelCase repositoryName}}.findById(entityId);
      if (!existing) {
        {{#if ../logging}}
        this.logger.warn('{{../modelName}} not found for deletion', { id: entityId });
        {{/if}}
        return false;
      }

      // Business logic validation
      await this.validateDeleteInput(entityId, existing);

      const deleted = await this.{{../camelCase repositoryName}}.delete(entityId);

      if (deleted) {
        {{#if ../caching}}
        // Invalidate related caches
        await this.cacheService.delete(`{{../name}}:${entityId}`);
        await this.cacheService.invalidatePattern(`{{../name}}:list:*`);
        {{/if}}

        {{#if ../events}}
        this.emit('{{../name}}:deleted', { {{../name}}: existing });
        {{/if}}

        {{#if ../logging}}
        this.logger.info('{{../modelName}} deleted successfully', { id: entityId });
        {{/if}}
      }

      return deleted;
      {{else}}
      // TODO: Implement {{name}} method logic
      {{#if ../logging}}
      this.logger.debug('{{name}} method executed');
      {{/if}}
      
      {{#if ../events}}
      this.emit('{{../name}}:{{name}}', { {{#each parameters}}{{name}}{{#unless @last}}, {{/unless}}{{/each}} });
      {{/if}}

      throw new Error('{{name}} method not implemented');
      {{/if}}
    } catch (error) {
      {{#if ../logging}}
      this.logger.error('Error in {{name}} method', error);
      {{/if}}
      
      {{#if ../events}}
      this.emit('{{../name}}:error', { method: '{{name}}', error });
      {{/if}}

      if (error instanceof AppError) {
        throw error;
      }

      throw new AppError(`Failed to {{name}} {{../name}}: ${error.message}`, 500);
    }
  }

{{/each}}
  /**
   * Get service statistics
   */
  async getStats(): Promise<any> {
    try {
      const total = await this.{{camelCase repositoryName}}.count();
      
      return {
        total,
        service: '{{className}}',
        lastUpdated: new Date().toISOString(),
      };
    } catch (error) {
      {{#if logging}}
      this.logger.error('Error getting stats', error);
      {{/if}}
      throw new AppError(`Failed to get {{name}} stats: ${error.message}`, 500);
    }
  }

  /**
   * Validate create input (business logic)
   */
  private async validateCreateInput(input: Create{{modelName}}Input): Promise<void> {
    // Add your business logic validation here
    // Example: Check for duplicate values, validate relationships, etc.
    
    {{#if logging}}
    this.logger.debug('Validating create input', { input });
    {{/if}}
  }

  /**
   * Validate update input (business logic)
   */
  private async validateUpdateInput(
    id: string,
    input: Update{{modelName}}Input,
    existing: {{modelName}},
  ): Promise<void> {
    // Add your business logic validation here
    // Example: Check for conflicts, validate state transitions, etc.
    
    {{#if logging}}
    this.logger.debug('Validating update input', { id, input, existing });
    {{/if}}
  }

  /**
   * Validate delete input (business logic)
   */
  private async validateDeleteInput(id: string, existing: {{modelName}}): Promise<void> {
    // Add your business logic validation here
    // Example: Check for dependencies, validate permissions, etc.
    
    {{#if logging}}
    this.logger.debug('Validating delete input', { id, existing });
    {{/if}}
  }

  {{#if caching}}
  /**
   * Clear all cache entries for this service
   */
  async clearCache(): Promise<void> {
    await this.cacheService.invalidatePattern(`{{name}}:*`);
    {{#if logging}}
    this.logger.info('Cache cleared for {{className}}');
    {{/if}}
  }
  {{/if}}

  {{#if events}}
  /**
   * Get event statistics
   */
  getEventStats(): any {
    return {
      listenerCount: this.listenerCount.bind(this),
      eventNames: this.eventNames.bind(this),
      maxListeners: this.getMaxListeners.bind(this),
    };
  }
  {{/if}}
}

/**
 * Create and export service instance
 */
export const {{camelCase name}}Service = new {{className}}(
  new {{repositoryName}}(),
  {{#if caching}}
  new CacheService(),
  {{/if}}
);