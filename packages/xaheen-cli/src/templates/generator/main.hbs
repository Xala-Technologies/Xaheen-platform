{{!-- Generator Implementation Template --}}
{{!-- Generated: {{now}} --}}
{{!-- Template: {{template.name}} --}}

import { BaseGenerator, GeneratorResult } from '../base.generator';
import { promises as fs } from 'fs';
import path from 'path';
import chalk from 'chalk';

export interface {{pascalCase metadata.name}}Options {
  readonly name: string;
  readonly dryRun?: boolean;
  readonly force?: boolean;
  readonly typescript?: boolean;
  readonly tests?: boolean;
  readonly stories?: boolean;
{{#each template.variables}}
  {{#unless (eq name "name")}}
  readonly {{camelCase name}}{{#unless required}}?{{/unless}}: {{type}};
  {{/unless}}
{{/each}}
}

/**
 * {{metadata.description}}
 * 
 * Generated by Xaheen Meta-Generator
 * Category: {{metadata.category}}
 * Platforms: {{join metadata.platforms ", "}}
 * Framework: {{join metadata.framework ", "}}
 */
export class {{pascalCase metadata.name}}Generator extends BaseGenerator<{{pascalCase metadata.name}}Options> {
  getGeneratorType(): string {
    return '{{kebabCase metadata.name}}';
  }

  async generate(options: {{pascalCase metadata.name}}Options): Promise<GeneratorResult> {
    try {
      await this.validateOptions(options);
      
      const startTime = Date.now();
      this.logger.info(`üîÑ Generating {{metadata.name}}: ${chalk.cyan(options.name)}`);
      
      const files: string[] = [];
      const commands: string[] = [];
      const naming = this.getNamingConvention(options.name);
      
      // Detect project structure
      const projectStructure = await this.detectProjectStructure();
      
      {{#if options.customOptions.generateMainFile}}
      // Generate main file
      const mainFile = await this.generateMainFile(naming, options, projectStructure);
      files.push(mainFile);
      {{/if}}
      
      {{#if options.customOptions.generateTypes}}
      // Generate types file
      const typesFile = await this.generateTypesFile(naming, options, projectStructure);
      files.push(typesFile);
      {{/if}}
      
      // Generate tests if requested
      if (options.tests && projectStructure.usesJest) {
        const testFile = await this.generateTestFile(naming, options, projectStructure);
        files.push(testFile);
        commands.push('npm test');
      }
      
      // Generate stories if requested
      if (options.stories && projectStructure.usesStorybook) {
        const storyFile = await this.generateStoryFile(naming, options, projectStructure);
        files.push(storyFile);
        commands.push('npm run storybook');
      }
      
      const executionTime = Date.now() - startTime;
      this.logger.success(`‚ú® Generated {{metadata.name}} in ${chalk.yellow(executionTime)}ms`);
      
      return {
        success: true,
        message: `Successfully generated {{metadata.name}}: ${chalk.green(options.name)}`,
        files,
        commands,
        nextSteps: [
          'Review the generated files',
          'Customize the implementation as needed',
          {{#if metadata.category === 'component'}}
          'Add to your component library',
          'Update exports in index file',
          {{/if}}
          {{#if options.tests}}
          'Run tests to ensure everything works',
          {{/if}}
          {{#if options.stories}}
          'Check Storybook for component documentation',
          {{/if}}
          'Test in your application'
        ]
      };
      
    } catch (error: any) {
      this.logger.error(`Failed to generate {{metadata.name}}: ${error.message}`, error);
      
      return {
        success: false,
        message: `‚ùå Generation failed: ${error.message}`,
        files: [],
        commands: []
      };
    }
  }

  {{#if options.customOptions.generateMainFile}}
  /**
   * Generate the main implementation file
   */
  private async generateMainFile(
    naming: any,
    options: {{pascalCase metadata.name}}Options,
    projectStructure: any
  ): Promise<string> {
    const filePlacement = this.getFilePlacement('{{kebabCase metadata.category}}', naming.className);
    
    return await this.generateFile(
      '{{kebabCase metadata.name}}/main.hbs',
      filePlacement.filePath,
      {
        ...options,
        naming,
        projectStructure,
        metadata: {
          name: '{{metadata.name}}',
          category: '{{metadata.category}}',
          platforms: {{json metadata.platforms}},
          framework: {{json metadata.framework}}
        },
        // Norwegian compliance features
        norwegianCompliance: {
          classification: 'OPEN',
          dataProtection: true,
          accessibilityCompliant: true
        },
        // Accessibility features
        accessibility: {
          wcagCompliant: true,
          keyboardNavigation: true,
          screenReaderSupport: true,
          highContrast: true
        },
        // Internationalization
        i18n: {
          norwegianSupport: true,
          rtlSupport: {{#if (includes metadata.framework "headless")}}true{{else}}false{{/if}},
          dateTimeLocalization: true
        }
      },
      { dryRun: options.dryRun, force: options.force }
    );
  }
  {{/if}}

  {{#if options.customOptions.generateTypes}}
  /**
   * Generate types file
   */
  private async generateTypesFile(
    naming: any,
    options: {{pascalCase metadata.name}}Options,
    projectStructure: any
  ): Promise<string> {
    const filePlacement = this.getFilePlacement('types', naming.className);
    
    return await this.generateFile(
      '{{kebabCase metadata.name}}/types.hbs',
      filePlacement.filePath,
      {
        ...options,
        naming,
        projectStructure,
        strictTypes: true,
        exportTypes: true
      },
      { dryRun: options.dryRun, force: options.force }
    );
  }
  {{/if}}

  /**
   * Generate test file
   */
  private async generateTestFile(
    naming: any,
    options: {{pascalCase metadata.name}}Options,
    projectStructure: any
  ): Promise<string> {
    const filePlacement = this.getFilePlacement('{{kebabCase metadata.category}}', naming.className);
    
    return await this.generateFile(
      '{{kebabCase metadata.name}}/test.hbs',
      filePlacement.testPath!,
      {
        ...options,
        naming,
        projectStructure,
        testFramework: projectStructure.usesJest ? 'jest' : 'vitest',
        includeAccessibilityTests: true,
        includeRegressionTests: true,
        includePerformanceTests: {{#if (eq metadata.category "component")}}true{{else}}false{{/if}}
      },
      { dryRun: options.dryRun, force: options.force }
    );
  }

  /**
   * Generate story file
   */
  private async generateStoryFile(
    naming: any,
    options: {{pascalCase metadata.name}}Options,
    projectStructure: any
  ): Promise<string> {
    const filePlacement = this.getFilePlacement('{{kebabCase metadata.category}}', naming.className);
    
    return await this.generateFile(
      '{{kebabCase metadata.name}}/story.hbs',
      filePlacement.storyPath!,
      {
        ...options,
        naming,
        projectStructure,
        includeControls: true,
        includeAccessibilityTests: true,
        includeVariants: {{#if (eq metadata.category "component")}}true{{else}}false{{/if}}
      },
      { dryRun: options.dryRun, force: options.force }
    );
  }

  /**
   * Validate generator options
   */
  protected async validateOptions(options: {{pascalCase metadata.name}}Options): Promise<void> {
    await super.validateOptions(options);
    
    {{#each template.variables}}
    {{#if required}}
    if (!options.{{camelCase name}}) {
      throw new Error('{{pascalCase name}} is required');
    }
    {{/if}}
    
    {{#if validation}}
    // Validate {{name}}
    if (options.{{camelCase name}}) {
      const pattern = new RegExp('{{validation}}');
      if (!pattern.test(String(options.{{camelCase name}}))) {
        throw new Error('Invalid {{name}} format');
      }
    }
    {{/if}}
    {{/each}}
    
    // Category-specific validations
    {{#if (eq metadata.category "component")}}
    // Component-specific validations
    if (options.name && !/^[A-Z][A-Za-z]*$/.test(options.name)) {
      throw new Error('Component name must be PascalCase');
    }
    {{/if}}
    
    {{#if (eq metadata.category "service")}}
    // Service-specific validations
    if (options.name && !/^[a-z][a-zA-Z]*Service$/.test(options.name)) {
      this.logger.warn('Service names typically end with "Service"');
    }
    {{/if}}
  }

  /**
   * Get file placement for generated files
   */
  protected getFilePlacement(type: string, name: string): {
    filePath: string;
    testPath?: string;
    storyPath?: string;
  } {
    const naming = this.getNamingConvention(name);
    const extension = '{{#if (includes metadata.platforms "react")}}tsx{{else}}ts{{/if}}';
    
    {{#if (eq metadata.category "component")}}
    return {
      filePath: `src/components/${naming.className}.${extension}`,
      testPath: `src/components/__tests__/${naming.className}.test.${extension}`,
      storyPath: `src/components/${naming.className}.stories.${extension}`
    };
    {{else if (eq metadata.category "service")}}
    return {
      filePath: `src/services/${naming.kebabCase}.service.ts`,
      testPath: `src/services/__tests__/${naming.kebabCase}.service.test.ts`
    };
    {{else if (eq metadata.category "layout")}}
    return {
      filePath: `src/layouts/${naming.className}.${extension}`,
      testPath: `src/layouts/__tests__/${naming.className}.test.${extension}`,
      storyPath: `src/layouts/${naming.className}.stories.${extension}`
    };
    {{else}}
    return {
      filePath: `src/{{kebabCase metadata.category}}s/${naming.kebabCase}.${extension}`,
      testPath: `src/{{kebabCase metadata.category}}s/__tests__/${naming.kebabCase}.test.${extension}`
    };
    {{/if}}
  }
}

export default {{pascalCase metadata.name}}Generator;