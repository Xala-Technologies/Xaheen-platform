# Default values for {{projectName}}
# Generated by Xaheen CLI - Production-ready configuration

# ========================================
# Global Configuration
# ========================================
global:
  # Image registry and pull policy
  imageRegistry: "{{registry}}"
  imagePullSecrets: []
  storageClass: "standard"
  
# ========================================
# Application Configuration
# ========================================
image:
  repository: {{image.repository}}
  tag: "{{image.tag}}"
  pullPolicy: {{image.pullPolicy}}
  # Overrides the image tag whose default is the chart appVersion
  # tag: ""

# Image pull secrets
imagePullSecrets: []
nameOverride: ""
fullnameOverride: ""

# ========================================
# Deployment Configuration
# ========================================
replicaCount: {{replicaCount}}

# Deployment strategy
strategy:
  type: RollingUpdate
  rollingUpdate:
    maxSurge: 1
    maxUnavailable: 0

# Pod disruption budget
podDisruptionBudget:
  enabled: true
  minAvailable: 1
  # maxUnavailable: 50%

# ========================================
# Container Configuration
# ========================================
container:
  name: {{projectName}}
  port: {{containerPort}}
  
  # Environment variables
  env:
    NODE_ENV: production
    PORT: "{{containerPort}}"
    {{#each environmentVariables}}
    {{@key}}: "{{this}}"
    {{/each}}

  # Environment variables from secrets/configmaps
  envFrom: []
  # - secretRef:
  #     name: app-secrets
  # - configMapRef:
  #     name: app-config

  # Startup probe
  startupProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 10
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 30
    successThreshold: 1

  # Liveness probe
  livenessProbe:
    httpGet:
      path: /health
      port: http
    initialDelaySeconds: 30
    periodSeconds: 30
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1

  # Readiness probe
  readinessProbe:
    httpGet:
      path: /health/ready
      port: http
    initialDelaySeconds: 5
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1

  # Resource requests and limits
  resources:
    limits:
      cpu: {{resources.limits.cpu}}
      memory: {{resources.limits.memory}}
    requests:
      cpu: {{resources.requests.cpu}}
      memory: {{resources.requests.memory}}

  # Security context
  securityContext:
    runAsNonRoot: true
    runAsUser: 1001
    runAsGroup: 1001
    allowPrivilegeEscalation: false
    readOnlyRootFilesystem: true
    capabilities:
      drop:
        - ALL

# ========================================
# Pod Configuration
# ========================================
podSecurityContext:
  fsGroup: 1001
  fsGroupChangePolicy: "OnRootMismatch"
  seccompProfile:
    type: RuntimeDefault

podAnnotations:
  prometheus.io/scrape: "true"
  prometheus.io/port: "{{containerPort}}"
  prometheus.io/path: "/metrics"

podLabels: {}

# Node selection
nodeSelector: {}
tolerations: []
affinity: {}

# Pod topology spread constraints
topologySpreadConstraints: []

# Priority class
priorityClassName: ""

# Runtime class
runtimeClassName: ""

# ========================================
# Service Configuration
# ========================================
service:
  enabled: true
  type: ClusterIP
  port: {{servicePort}}
  targetPort: http
  protocol: TCP
  annotations: {}
  labels: {}
  
  # Load balancer configuration (for LoadBalancer type)
  loadBalancerIP: ""
  loadBalancerSourceRanges: []
  
  # External traffic policy (for LoadBalancer/NodePort)
  externalTrafficPolicy: Cluster

# ========================================
# Ingress Configuration
# ========================================
ingress:
  enabled: {{ingress.enabled}}
  className: "{{ingress.className}}"
  annotations:
    {{#each ingress.annotations}}
    {{@key}}: {{this}}
    {{/each}}
  hosts:
    {{#each ingress.hosts}}
    - host: {{host}}
      paths:
        {{#each paths}}
        - path: {{path}}
          pathType: {{pathType}}
        {{/each}}
    {{/each}}
  tls:
    {{#each ingress.tls}}
    - secretName: {{secretName}}
      hosts:
        {{#each hosts}}
        - {{this}}
        {{/each}}
    {{/each}}

# ========================================
# Horizontal Pod Autoscaler
# ========================================
autoscaling:
  enabled: {{hpa.enabled}}
  minReplicas: {{hpa.minReplicas}}
  maxReplicas: {{hpa.maxReplicas}}
  targetCPUUtilizationPercentage: {{hpa.targetCPU}}
  targetMemoryUtilizationPercentage: {{hpa.targetMemory}}
  
  # Custom metrics (KEDA, Prometheus adapter, etc.)
  behavior: {}
  metrics: []

# ========================================
# Vertical Pod Autoscaler
# ========================================
verticalPodAutoscaler:
  enabled: false
  updateMode: "Off"  # Off, Initial, Auto
  controlledResources: []
  maxAllowed: {}
  minAllowed: {}

# ========================================
# ConfigMap and Secret Configuration
# ========================================
configMap:
  enabled: {{configMap.enabled}}
  data:
    {{#each configMap.data}}
    {{@key}}: |
      {{this}}
    {{/each}}

secret:
  enabled: {{secret.enabled}}
  type: Opaque
  data: {}
  stringData:
    {{#each secret.stringData}}
    {{@key}}: "{{this}}"
    {{/each}}

# External secrets operator
externalSecrets:
  enabled: false
  secretStore:
    kind: SecretStore  # SecretStore or ClusterSecretStore
    name: vault-backend
  data: []

# ========================================
# Persistence Configuration
# ========================================
persistence:
  enabled: {{persistence.enabled}}
  storageClass: "{{persistence.storageClass}}"
  accessMode: ReadWriteOnce
  size: {{persistence.size}}
  annotations: {}
  mountPath: /app/data
  subPath: ""

# Additional volumes
extraVolumes: []
extraVolumeMounts: []

# ========================================
# Service Account Configuration
# ========================================
serviceAccount:
  create: true
  annotations: {}
  name: ""
  automountServiceAccountToken: false

# ========================================
# RBAC Configuration
# ========================================
rbac:
  create: {{rbac.enabled}}
  rules: []

# ========================================
# Network Policy Configuration
# ========================================
networkPolicy:
  enabled: {{networkPolicy.enabled}}
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: {{namespace}}
        - podSelector:
            matchLabels:
              app.kubernetes.io/name: {{projectName}}
      ports:
        - protocol: TCP
          port: {{containerPort}}
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    - to: []
      ports:
        - protocol: TCP
          port: 443
        - protocol: TCP
          port: 80

# ========================================
# Pod Security Policy (deprecated) / Pod Security Standards
# ========================================
podSecurityPolicy:
  enabled: false

# Pod Security Standards
podSecurityStandards:
  enforce: restricted
  audit: restricted
  warn: restricted

# ========================================
# Service Monitor for Prometheus
# ========================================
serviceMonitor:
  enabled: {{monitoring.serviceMonitor.enabled}}
  namespace: "{{monitoring.namespace}}"
  labels: {}
  annotations: {}
  interval: 30s
  scrapeTimeout: 10s
  path: /metrics
  port: http
  scheme: http
  tlsConfig: {}
  honorLabels: false
  metricRelabelings: []
  relabelings: []

# ========================================
# Database Configuration
# ========================================
{{#if useDatabase}}
postgresql:
  enabled: {{database.enabled}}
  auth:
    postgresPassword: "{{database.password}}"
    username: "{{database.username}}"
    password: "{{database.password}}"
    database: "{{database.name}}"
  primary:
    persistence:
      enabled: true
      size: {{database.storage.size}}
      storageClass: "{{database.storage.class}}"
  metrics:
    enabled: {{monitoring.enabled}}
    serviceMonitor:
      enabled: {{monitoring.serviceMonitor.enabled}}
{{/if}}

# ========================================
# Redis Configuration
# ========================================
{{#if useRedis}}
redis:
  enabled: {{redis.enabled}}
  auth:
    enabled: true
    password: "{{redis.password}}"
  master:
    persistence:
      enabled: true
      size: {{redis.storage.size}}
      storageClass: "{{redis.storage.class}}"
  metrics:
    enabled: {{monitoring.enabled}}
    serviceMonitor:
      enabled: {{monitoring.serviceMonitor.enabled}}
{{/if}}

# ========================================
# Monitoring Configuration
# ========================================
{{#if enableMonitoring}}
prometheus:
  enabled: {{monitoring.prometheus.enabled}}
  server:
    persistentVolume:
      size: {{monitoring.prometheus.storage.size}}
      storageClass: "{{monitoring.prometheus.storage.class}}"
  alertmanager:
    enabled: {{monitoring.alertmanager.enabled}}
    persistentVolume:
      size: {{monitoring.alertmanager.storage.size}}

grafana:
  enabled: {{monitoring.grafana.enabled}}
  adminPassword: "{{monitoring.grafana.adminPassword}}"
  persistence:
    enabled: true
    size: {{monitoring.grafana.storage.size}}
    storageClassName: "{{monitoring.grafana.storage.class}}"
  sidecar:
    dashboards:
      enabled: true
      searchNamespace: ALL
    datasources:
      enabled: true
      searchNamespace: ALL
{{/if}}

# ========================================
# Istio Service Mesh Configuration
# ========================================
{{#if enableIstio}}
istio:
  enabled: {{istio.enabled}}
  
  # Istio injection
  injection:
    enabled: true
    
  # Virtual Service
  virtualService:
    enabled: {{istio.virtualService.enabled}}
    hosts:
      {{#each istio.virtualService.hosts}}
      - {{this}}
      {{/each}}
    gateways:
      {{#each istio.virtualService.gateways}}
      - {{this}}
      {{/each}}
    
  # Destination Rule
  destinationRule:
    enabled: {{istio.destinationRule.enabled}}
    trafficPolicy:
      tls:
        mode: ISTIO_MUTUAL
        
  # Gateway
  gateway:
    enabled: {{istio.gateway.enabled}}
    hosts:
      {{#each istio.gateway.hosts}}
      - {{this}}
      {{/each}}
    tls:
      mode: SIMPLE
      credentialName: {{istio.gateway.tlsSecret}}
      
  # Peer Authentication
  peerAuthentication:
    enabled: {{istio.peerAuthentication.enabled}}
    mtls:
      mode: STRICT
      
  # Authorization Policy  
  authorizationPolicy:
    enabled: {{istio.authorizationPolicy.enabled}}
    rules: []
{{/if}}

# ========================================
# Cert-Manager Configuration
# ========================================
{{#if enableCertManager}}
certManager:
  enabled: {{certManager.enabled}}
  issuer:
    name: letsencrypt-prod
    server: https://acme-v02.api.letsencrypt.org/directory
    email: {{certManager.email}}
    privateKeySecretRef: letsencrypt-prod
  certificate:
    secretName: {{projectName}}-tls
    dnsNames:
      {{#each certManager.dnsNames}}
      - {{this}}
      {{/each}}
{{/if}}

# ========================================
# Testing Configuration
# ========================================
tests:
  enabled: {{tests.enabled}}
  image:
    repository: curlimages/curl
    tag: latest
    pullPolicy: IfNotPresent