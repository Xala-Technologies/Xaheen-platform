# Default values for {{imageName}}
# This is a YAML-formatted file.
# Generated by Xaheen CLI on {{timestamp}}

# Global configuration
global:
  imageRegistry: "{{registryUrl}}"
  storageClass: ""
  
# Application configuration
app:
  name: {{imageName}}
  version: {{imageTag}}
  environment: {{environment}}
  
# Image configuration
image:
  registry: {{registryUrl}}
  repository: {{imageName}}
  tag: "{{imageTag}}"
  pullPolicy: {{#if (eq environment "development")}}Always{{else}}IfNotPresent{{/if}}
  pullSecrets: []
    # - name: myregistrykey

# Service account configuration
serviceAccount:
  create: true
  annotations: {}
  name: ""
  automountServiceAccountToken: true

# Pod configuration
replicaCount: {{#if (eq environment "production")}}3{{else}}1{{/if}}

# Container configuration
container:
  port: {{port}}
  {{#if exposePorts}}
  additionalPorts:
    {{#each exposePorts}}
    - name: port-{{this}}
      containerPort: {{this}}
      protocol: TCP
    {{/each}}
  {{/if}}
  
# Environment variables
env:
  NODE_ENV: "{{environment}}"
  PORT: "{{port}}"
  SERVICE_NAME: "{{imageName}}"
  SERVICE_VERSION: "{{imageTag}}"
  {{#each environmentVariables}}
  {{@key}}: "{{this}}"
  {{/each}}

# Secrets (base64 encoded)
secrets:
  {{#each secrets}}
  {{this}}: ""  # TODO: Add base64 encoded secret
  {{/each}}

# Resource limits and requests
resources:
  limits:
    cpu: {{#if (eq environment "production")}}500m{{else}}300m{{/if}}
    memory: {{#if (eq environment "production")}}512Mi{{else}}256Mi{{/if}}
  requests:
    cpu: {{#if (eq environment "production")}}200m{{else}}100m{{/if}}
    memory: {{#if (eq environment "production")}}256Mi{{else}}128Mi{{/if}}

# Health checks
healthCheck:
  enabled: {{enableHealthCheck}}
  livenessProbe:
    httpGet:
      path: /health
      port: http
      scheme: HTTP
    initialDelaySeconds: 30
    periodSeconds: 10
    timeoutSeconds: 5
    failureThreshold: 3
    successThreshold: 1
  readinessProbe:
    httpGet:
      path: /ready
      port: http
      scheme: HTTP
    initialDelaySeconds: 5
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 3
    successThreshold: 1
  startupProbe:
    httpGet:
      path: /health
      port: http
      scheme: HTTP
    initialDelaySeconds: 10
    periodSeconds: 5
    timeoutSeconds: 3
    failureThreshold: 6
    successThreshold: 1

# Security context
securityContext:
  enabled: {{enableSecurity}}
  runAsNonRoot: true
  runAsUser: 1001
  runAsGroup: 1001
  fsGroup: 1001
  allowPrivilegeEscalation: false
  capabilities:
    drop:
      - ALL
  readOnlyRootFilesystem: true
  seccompProfile:
    type: RuntimeDefault

# Pod security context
podSecurityContext:
  enabled: {{enableSecurity}}
  runAsNonRoot: true
  runAsUser: 1001
  runAsGroup: 1001
  fsGroup: 1001
  seccompProfile:
    type: RuntimeDefault

# Service configuration
service:
  type: ClusterIP
  port: 80
  targetPort: http
  annotations: {}
  {{#if enablePrometheus}}
  metrics:
    enabled: true
    port: 9090
    targetPort: metrics
    annotations:
      prometheus.io/scrape: "true"
      prometheus.io/port: "9090"
      prometheus.io/path: "/metrics"
  {{/if}}

# Ingress configuration
ingress:
  enabled: {{enableIngress}}
  className: "nginx"
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    {{#if enableSsl}}
    cert-manager.io/cluster-issuer: "letsencrypt-prod"
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    {{/if}}
    {{#if rateLimiting}}
    nginx.ingress.kubernetes.io/rate-limit: "100"
    nginx.ingress.kubernetes.io/rate-limit-window: "1m"
    {{/if}}
  hosts:
    - host: {{domain}}
      paths:
        - path: /
          pathType: Prefix
  {{#if enableSsl}}
  tls:
    - secretName: {{imageName}}-tls
      hosts:
        - {{domain}}
  {{/if}}

# Horizontal Pod Autoscaler
autoscaling:
  enabled: {{enableHpa}}
  minReplicas: {{#if (eq environment "production")}}2{{else}}1{{/if}}
  maxReplicas: {{#if (eq environment "production")}}10{{else}}3{{/if}}
  targetCPUUtilizationPercentage: 70
  targetMemoryUtilizationPercentage: 80
  {{#if enablePrometheus}}
  customMetrics:
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "100"
  {{/if}}
  behavior:
    scaleUp:
      stabilizationWindowSeconds: 60
      policies:
        - type: Pods
          value: 2
          periodSeconds: 60
    scaleDown:
      stabilizationWindowSeconds: 300
      policies:
        - type: Pods
          value: 1
          periodSeconds: 60

# Pod Disruption Budget
podDisruptionBudget:
  enabled: {{enablePdb}}
  minAvailable: {{#if (eq environment "production")}}50%{{else}}1{{/if}}

# Network Policy
networkPolicy:
  enabled: {{enableNetworkPolicy}}
  policyTypes:
    - Ingress
    - Egress
  ingress:
    - from:
        - namespaceSelector:
            matchLabels:
              name: nginx-ingress
        - namespaceSelector:
            matchLabels:
              name: monitoring
      ports:
        - protocol: TCP
          port: {{port}}
        {{#if enablePrometheus}}
        - protocol: TCP
          port: 9090
        {{/if}}
  egress:
    - to: []
      ports:
        - protocol: TCP
          port: 53
        - protocol: UDP
          port: 53
    - to:
        - namespaceSelector:
            matchLabels:
              name: kube-system

# Volumes and Volume Mounts
volumes: []
  # - name: config-volume
  #   configMap:
  #     name: {{imageName}}-config
  # - name: secret-volume
  #   secret:
  #     secretName: {{imageName}}-secrets

volumeMounts: []
  # - name: config-volume
  #   mountPath: /etc/config
  #   readOnly: true
  # - name: secret-volume
  #   mountPath: /etc/secrets
  #   readOnly: true

# Node selection
nodeSelector: {}

# Tolerations
tolerations: []

# Affinity
affinity:
  podAntiAffinity:
    preferredDuringSchedulingIgnoredDuringExecution:
      - weight: 100
        podAffinityTerm:
          labelSelector:
            matchExpressions:
              - key: app.kubernetes.io/name
                operator: In
                values:
                  - {{imageName}}
          topologyKey: kubernetes.io/hostname

# Pod annotations
podAnnotations:
  {{#if enablePrometheus}}
  prometheus.io/scrape: "true"
  prometheus.io/port: "9090"
  prometheus.io/path: "/metrics"
  {{/if}}
  {{#if enableTracing}}
  sidecar.jaegertracing.io/inject: "true"
  {{/if}}

# Pod labels
podLabels: {}

{{#if (eq projectType "fullstack")}}
# Database configuration (PostgreSQL)
postgresql:
  enabled: true
  auth:
    postgresPassword: "postgres"
    username: "{{imageName}}"
    password: "{{imageName}}"
    database: "{{imageName}}"
  primary:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      limits:
        memory: 256Mi
        cpu: 250m
      requests:
        memory: 256Mi
        cpu: 250m
  metrics:
    enabled: {{enablePrometheus}}
    serviceMonitor:
      enabled: {{enablePrometheus}}

# Redis configuration
redis:
  enabled: true
  auth:
    enabled: true
    password: "redis"
  master:
    persistence:
      enabled: true
      size: 8Gi
    resources:
      limits:
        memory: 256Mi
        cpu: 250m
      requests:
        memory: 256Mi
        cpu: 250m
  metrics:
    enabled: {{enablePrometheus}}
    serviceMonitor:
      enabled: {{enablePrometheus}}
{{/if}}

{{#if enablePrometheus}}
# Monitoring configuration
monitoring:
  prometheus:
    enabled: true
    serviceMonitor:
      enabled: true
      interval: 30s
      scrapeTimeout: 10s
      path: /metrics
      port: metrics
      labels: {}
      annotations: {}
  grafana:
    enabled: true
    dashboards:
      enabled: true
      configMapName: {{imageName}}-grafana-dashboards
  alerting:
    enabled: true
    rules:
      - alert: HighErrorRate
        expr: rate(http_requests_total{status=~"5.."}[5m]) > 0.1
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High error rate detected"
          description: "Error rate is above 10% for more than 2 minutes"
      - alert: HighMemoryUsage
        expr: container_memory_usage_bytes / container_spec_memory_limit_bytes > 0.9
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High memory usage"
          description: "Memory usage is above 90% for more than 5 minutes"
      - alert: HighCPUUsage
        expr: rate(container_cpu_usage_seconds_total[5m]) > 0.8
        for: 5m
        labels:
          severity: warning
        annotations:
          summary: "High CPU usage"
          description: "CPU usage is above 80% for more than 5 minutes"
{{/if}}

{{#if enableTracing}}
# Tracing configuration
tracing:
  jaeger:
    enabled: true
    agent:
      host: jaeger-agent
      port: 6832
    collector:
      endpoint: http://jaeger-collector:14268/api/traces
    sampling:
      type: const
      param: {{#if (eq environment "production")}}0.1{{else}}1{{/if}}
  opentelemetry:
    enabled: true
    collector:
      endpoint: http://otel-collector:4317
    instrumentations:
      - http
      - express
      - redis
      - postgresql
{{/if}}

{{#if enableLogging}}
# Logging configuration
logging:
  loki:
    enabled: true
    url: http://loki:3100
  structured:
    enabled: true
    format: json
    level: {{#if (eq environment "development")}}debug{{else}}info{{/if}}
  correlation:
    enabled: true
    traceIdHeader: x-trace-id
{{/if}}

# Migration jobs
migrations:
  enabled: {{#if (eq projectType "fullstack")}}true{{else}}false{{/if}}
  image:
    registry: {{registryUrl}}
    repository: {{imageName}}-migrations
    tag: "{{imageTag}}"
    pullPolicy: IfNotPresent
  backoffLimit: 3
  activeDeadlineSeconds: 600
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Configuration for different environments
environments:
  development:
    replicaCount: 1
    resources:
      limits:
        cpu: 300m
        memory: 256Mi
      requests:
        cpu: 100m
        memory: 128Mi
  staging:
    replicaCount: 2
    resources:
      limits:
        cpu: 400m
        memory: 384Mi
      requests:
        cpu: 150m
        memory: 192Mi
  production:
    replicaCount: 3
    resources:
      limits:
        cpu: 500m
        memory: 512Mi
      requests:
        cpu: 200m
        memory: 256Mi