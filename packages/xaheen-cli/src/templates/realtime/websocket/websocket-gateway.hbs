/**
 * WebSocket Gateway
 * Generated by Xaheen CLI
 */

import {
  WebSocketGateway,
  WebSocketServer,
  SubscribeMessage,
  MessageBody,
  ConnectedSocket,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
} from '@nestjs/websockets';
import { Server, Socket } from 'socket.io';
import { Logger, UseGuards, UsePipes, ValidationPipe } from '@nestjs/common';
{{#if authentication.enabled}}
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
{{/if}}

@WebSocketGateway({{wsPort}}, {
  cors: {
    origin: {{#if cors.origin}}'{{{cors.origin}}}'{{else}}true{{/if}},
    credentials: {{cors.credentials}}
  },
  namespace: '/{{namespace}}'
})
export class {{pascalCase name}}WebSocketGateway
  implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect
{
  @WebSocketServer()
  server: Server;

  private readonly logger = new Logger({{pascalCase name}}WebSocketGateway.name);
  private connectedClients = new Map<string, Socket>();
  private roomMembers = new Map<string, Set<string>>();

  afterInit(server: Server) {
    this.logger.log('WebSocket Gateway initialized');
  }

  handleConnection(client: Socket, ...args: any[]) {
    this.logger.log(`Client connected: ${client.id}`);
    this.connectedClients.set(client.id, client);

    // Send welcome message
    client.emit('connected', {
      clientId: client.id,
      timestamp: Date.now()
    });
  }

  handleDisconnect(client: Socket) {
    this.logger.log(`Client disconnected: ${client.id}`);
    this.connectedClients.delete(client.id);

    // Remove from all rooms
    for (const [room, members] of this.roomMembers) {
      if (members.has(client.id)) {
        members.delete(client.id);
        client.to(room).emit('user-left', {
          userId: client.id,
          room,
          timestamp: Date.now()
        });
      }
    }
  }

  {{#each features}}
  {{#if (eq this 'chat')}}
  @SubscribeMessage('join-room')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleJoinRoom(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { room: string; userId?: string }
  ) {
    client.join(data.room);
    
    if (!this.roomMembers.has(data.room)) {
      this.roomMembers.set(data.room, new Set());
    }
    
    this.roomMembers.get(data.room)!.add(client.id);

    // Notify room members
    client.to(data.room).emit('user-joined', {
      userId: data.userId || client.id,
      room: data.room,
      timestamp: Date.now()
    });

    // Send room info to client
    client.emit('room-joined', {
      room: data.room,
      members: Array.from(this.roomMembers.get(data.room)!),
      timestamp: Date.now()
    });
  }

  @SubscribeMessage('leave-room')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleLeaveRoom(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { room: string; userId?: string }
  ) {
    client.leave(data.room);
    
    const roomMembers = this.roomMembers.get(data.room);
    if (roomMembers) {
      roomMembers.delete(client.id);
      
      if (roomMembers.size === 0) {
        this.roomMembers.delete(data.room);
      }
    }

    // Notify room members
    client.to(data.room).emit('user-left', {
      userId: data.userId || client.id,
      room: data.room,
      timestamp: Date.now()
    });
  }

  @SubscribeMessage('send-message')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  @UsePipes(new ValidationPipe())
  handleMessage(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: {
      room: string;
      message: string;
      userId?: string;
      messageType?: 'text' | 'image' | 'file';
    }
  ) {
    const messageData = {
      id: this.generateId(),
      ...data,
      userId: data.userId || client.id,
      timestamp: Date.now()
    };

    // Emit to room
    this.server.to(data.room).emit('new-message', messageData);

    // Acknowledge to sender
    client.emit('message-sent', {
      messageId: messageData.id,
      timestamp: messageData.timestamp
    });
  }
  {{/if}}

  {{#if (eq this 'notifications')}}
  @SubscribeMessage('subscribe-notifications')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleSubscribeNotifications(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { userId: string; topics?: string[] }
  ) {
    const notificationRoom = `notifications:${data.userId}`;
    client.join(notificationRoom);

    if (data.topics) {
      data.topics.forEach(topic => {
        client.join(`notifications:topic:${topic}`);
      });
    }

    client.emit('notifications-subscribed', {
      userId: data.userId,
      topics: data.topics || [],
      timestamp: Date.now()
    });
  }

  @SubscribeMessage('send-notification')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleSendNotification(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: {
      userId?: string;
      topic?: string;
      title: string;
      message: string;
      type: 'info' | 'success' | 'warning' | 'error';
    }
  ) {
    const notification = {
      id: this.generateId(),
      ...data,
      timestamp: Date.now()
    };

    if (data.userId) {
      this.server.to(`notifications:${data.userId}`).emit('notification', notification);
    } else if (data.topic) {
      this.server.to(`notifications:topic:${data.topic}`).emit('notification', notification);
    } else {
      this.server.emit('notification', notification);
    }

    client.emit('notification-sent', {
      notificationId: notification.id,
      timestamp: notification.timestamp
    });
  }
  {{/if}}

  {{#if (eq this 'live-updates')}}
  @SubscribeMessage('subscribe-updates')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleSubscribeUpdates(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { entityType: string; entityId?: string }
  ) {
    const updateRoom = data.entityId 
      ? `updates:${data.entityType}:${data.entityId}`
      : `updates:${data.entityType}`;
    
    client.join(updateRoom);

    client.emit('updates-subscribed', {
      entityType: data.entityType,
      entityId: data.entityId,
      room: updateRoom,
      timestamp: Date.now()
    });
  }

  public broadcastUpdate(entityType: string, entityId: string, update: any) {
    const specificRoom = `updates:${entityType}:${entityId}`;
    const generalRoom = `updates:${entityType}`;

    const updateData = {
      id: this.generateId(),
      entityType,
      entityId,
      update,
      timestamp: Date.now()
    };

    this.server.to(specificRoom).emit('entity-updated', updateData);
    this.server.to(generalRoom).emit('entity-updated', updateData);
  }
  {{/if}}

  {{#if (eq this 'collaborative-editing')}}
  @SubscribeMessage('join-document')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleJoinDocument(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: { documentId: string; userId: string }
  ) {
    const documentRoom = `document:${data.documentId}`;
    client.join(documentRoom);

    // Notify other users
    client.to(documentRoom).emit('user-joined-document', {
      documentId: data.documentId,
      userId: data.userId,
      timestamp: Date.now()
    });

    client.emit('document-joined', {
      documentId: data.documentId,
      timestamp: Date.now()
    });
  }

  @SubscribeMessage('document-operation')
  {{#if ../authentication.enabled}}
  @UseGuards(JwtAuthGuard)
  {{/if}}
  handleDocumentOperation(
    @ConnectedSocket() client: Socket,
    @MessageBody() data: {
      documentId: string;
      operation: any;
      userId: string;
      revision: number;
    }
  ) {
    const documentRoom = `document:${data.documentId}`;
    
    // Broadcast to other clients in the document
    client.to(documentRoom).emit('document-operation', {
      ...data,
      timestamp: Date.now()
    });
  }
  {{/if}}
  {{/each}}

  // Utility methods
  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  public getConnectedClientsCount(): number {
    return this.connectedClients.size;
  }

  public getRoomMembersCount(room: string): number {
    return this.roomMembers.get(room)?.size || 0;
  }

  public broadcastToRoom(room: string, event: string, data: any) {
    this.server.to(room).emit(event, {
      ...data,
      timestamp: Date.now()
    });
  }

  public broadcastToAll(event: string, data: any) {
    this.server.emit(event, {
      ...data,
      timestamp: Date.now()
    });
  }
}