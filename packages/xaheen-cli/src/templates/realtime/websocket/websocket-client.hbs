/**
 * WebSocket Client
 * Generated by Xaheen CLI
 */

import { io, Socket } from 'socket.io-client';

export interface WebSocketClientOptions {
  url: string;
  namespace?: string;
  autoConnect?: boolean;
  auth?: {
    token?: string;
    [key: string]: any;
  };
  reconnection?: boolean;
  reconnectionAttempts?: number;
  reconnectionDelay?: number;
}

export interface MessageHandler {
  (data: any): void;
}

export class {{pascalCase name}}WebSocketClient {
  private socket: Socket | null = null;
  private isConnected = false;
  private messageHandlers = new Map<string, MessageHandler[]>();
  private connectionPromise: Promise<void> | null = null;

  constructor(private options: WebSocketClientOptions) {
    if (options.autoConnect !== false) {
      this.connect();
    }
  }

  public async connect(): Promise<void> {
    if (this.connectionPromise) {
      return this.connectionPromise;
    }

    this.connectionPromise = new Promise((resolve, reject) => {
      const socketOptions: any = {
        auth: this.options.auth || {},
        reconnection: this.options.reconnection ?? true,
        reconnectionAttempts: this.options.reconnectionAttempts ?? 5,
        reconnectionDelay: this.options.reconnectionDelay ?? 1000,
      };

      const url = this.options.namespace 
        ? `${this.options.url}/${this.options.namespace}`
        : this.options.url;

      this.socket = io(url, socketOptions);

      this.socket.on('connect', () => {
        this.isConnected = true;
        console.log('WebSocket connected:', this.socket?.id);
        resolve();
      });

      this.socket.on('disconnect', () => {
        this.isConnected = false;
        console.log('WebSocket disconnected');
      });

      this.socket.on('connect_error', (error) => {
        console.error('WebSocket connection error:', error);
        reject(error);
      });

      // Setup message routing
      this.setupMessageRouting();
    });

    return this.connectionPromise;
  }

  public disconnect(): void {
    if (this.socket) {
      this.socket.disconnect();
      this.socket = null;
      this.isConnected = false;
      this.connectionPromise = null;
    }
  }

  public on(event: string, handler: MessageHandler): () => void {
    if (!this.messageHandlers.has(event)) {
      this.messageHandlers.set(event, []);
    }

    this.messageHandlers.get(event)!.push(handler);

    // Return unsubscribe function
    return () => {
      const handlers = this.messageHandlers.get(event);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }

  public emit(event: string, data?: any): Promise<any> {
    return new Promise((resolve, reject) => {
      if (!this.socket || !this.isConnected) {
        reject(new Error('WebSocket not connected'));
        return;
      }

      this.socket.emit(event, data, (response: any) => {
        if (response && response.error) {
          reject(new Error(response.error));
        } else {
          resolve(response);
        }
      });
    });
  }

  {{#each features}}
  {{#if (eq this 'chat')}}
  // Chat functionality
  public async joinRoom(room: string, userId?: string): Promise<void> {
    return this.emit('join-room', { room, userId });
  }

  public async leaveRoom(room: string, userId?: string): Promise<void> {
    return this.emit('leave-room', { room, userId });
  }

  public async sendMessage(
    room: string,
    message: string,
    messageType: 'text' | 'image' | 'file' = 'text',
    userId?: string
  ): Promise<void> {
    return this.emit('send-message', {
      room,
      message,
      messageType,
      userId
    });
  }

  public onMessage(handler: (data: any) => void): () => void {
    return this.on('new-message', handler);
  }

  public onUserJoined(handler: (data: any) => void): () => void {
    return this.on('user-joined', handler);
  }

  public onUserLeft(handler: (data: any) => void): () => void {
    return this.on('user-left', handler);
  }
  {{/if}}

  {{#if (eq this 'notifications')}}
  // Notifications functionality
  public async subscribeNotifications(userId: string, topics?: string[]): Promise<void> {
    return this.emit('subscribe-notifications', { userId, topics });
  }

  public async sendNotification(notification: {
    userId?: string;
    topic?: string;
    title: string;
    message: string;
    type: 'info' | 'success' | 'warning' | 'error';
  }): Promise<void> {
    return this.emit('send-notification', notification);
  }

  public onNotification(handler: (data: any) => void): () => void {
    return this.on('notification', handler);
  }
  {{/if}}

  {{#if (eq this 'live-updates')}}
  // Live updates functionality
  public async subscribeUpdates(entityType: string, entityId?: string): Promise<void> {
    return this.emit('subscribe-updates', { entityType, entityId });
  }

  public onEntityUpdated(handler: (data: any) => void): () => void {
    return this.on('entity-updated', handler);
  }
  {{/if}}

  {{#if (eq this 'collaborative-editing')}}
  // Collaborative editing functionality
  public async joinDocument(documentId: string, userId: string): Promise<void> {
    return this.emit('join-document', { documentId, userId });
  }

  public async sendDocumentOperation(
    documentId: string,
    operation: any,
    userId: string,
    revision: number
  ): Promise<void> {
    return this.emit('document-operation', {
      documentId,
      operation,
      userId,
      revision
    });
  }

  public onDocumentOperation(handler: (data: any) => void): () => void {
    return this.on('document-operation', handler);
  }

  public onUserJoinedDocument(handler: (data: any) => void): () => void {
    return this.on('user-joined-document', handler);
  }
  {{/if}}
  {{/each}}

  private setupMessageRouting(): void {
    if (!this.socket) return;

    // Route all events to registered handlers
    this.socket.onAny((event: string, data: any) => {
      const handlers = this.messageHandlers.get(event);
      if (handlers) {
        handlers.forEach(handler => {
          try {
            handler(data);
          } catch (error) {
            console.error(`Error in handler for event ${event}:`, error);
          }
        });
      }
    });
  }

  public get connected(): boolean {
    return this.isConnected;
  }

  public get socketId(): string | undefined {
    return this.socket?.id;
  }
}

// React Hook for WebSocket
{{#if includeReactHook}}
import { useEffect, useRef, useState } from 'react';

export function useWebSocket(options: WebSocketClientOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const clientRef = useRef<{{pascalCase name}}WebSocketClient | null>(null);

  useEffect(() => {
    const client = new {{pascalCase name}}WebSocketClient({
      ...options,
      autoConnect: false
    });

    clientRef.current = client;

    client.on('connect', () => {
      setIsConnected(true);
      setError(null);
    });

    client.on('disconnect', () => {
      setIsConnected(false);
    });

    client.on('connect_error', (err) => {
      setError(new Error(err.message));
      setIsConnected(false);
    });

    client.connect().catch(setError);

    return () => {
      client.disconnect();
    };
  }, [options.url, options.namespace]);

  return {
    client: clientRef.current,
    isConnected,
    error
  };
}
{{/if}}

export default {{pascalCase name}}WebSocketClient;