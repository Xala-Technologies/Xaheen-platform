/**
 * Redis Queue Implementation
 * Generated by Xaheen CLI
 */

import { Injectable, Logger } from '@nestjs/common';
import { InjectRedis } from '@nestjs-modules/ioredis';
import Redis from 'ioredis';

export interface QueueMessage<T = any> {
  id: string;
  payload: T;
  timestamp: number;
  attempts: number;
  maxAttempts: number;
  delay: number;
  priority: number;
  metadata: Record<string, any>;
  lastError?: string;
  failedAt?: number;
}

export interface QueueOptions {
  priority?: number;
  delay?: number;
  maxAttempts?: number;
  timeout?: number;
  metadata?: Record<string, any>;
}

export interface MessageProcessingResult {
  success: boolean;
  result?: any;
  error?: string;
}

@Injectable()
export class {{pascalCase name}}RedisQueueService {
  private readonly logger = new Logger({{pascalCase name}}RedisQueueService.name);
  private processingIntervals = new Map<string, NodeJS.Timeout>();

  constructor(
    @InjectRedis() private readonly redis: Redis
  ) {}

  async addToQueue<T>(queueName: string, message: QueueMessage<T>): Promise<void> {
    const queueKey = `queue:${queueName}`;
    const serialized = JSON.stringify(message);
    
    if (message.priority > 0) {
      // Use sorted set for priority queues
      await this.redis.zadd(`${queueKey}:priority`, message.priority, serialized);
    } else if (message.delay > 0) {
      // Use sorted set for delayed messages
      const executeAt = Date.now() + message.delay;
      await this.redis.zadd(`${queueKey}:delayed`, executeAt, serialized);
    } else {
      // Regular FIFO queue
      await this.redis.rpush(queueKey, serialized);
    }

    this.logger.debug(`Message added to queue ${queueName}: ${message.id}`);
  }

  async processQueue<T>(
    queueName: string,
    processor: (message: QueueMessage<T>) => Promise<MessageProcessingResult>,
    options: {
      concurrency?: number;
      pollInterval?: number;
    } = {}
  ): Promise<void> {
    const { concurrency = 1, pollInterval = 1000 } = options;
    
    // Start multiple workers for concurrency
    for (let i = 0; i < concurrency; i++) {
      this.startQueueWorker(queueName, processor, pollInterval);
    }

    // Start delayed message processor
    this.startDelayedMessageProcessor(queueName);
  }

  private startQueueWorker<T>(
    queueName: string,
    processor: (message: QueueMessage<T>) => Promise<MessageProcessingResult>,
    pollInterval: number
  ): void {
    const queueKey = `queue:${queueName}`;
    const processingKey = `processing:${queueName}`;
    const workerId = `worker_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const processMessages = async () => {
      try {
        // Check for priority messages first
        let result = await this.redis.zpopmax(`${queueKey}:priority`);
        
        if (!result || result.length === 0) {
          // Check regular queue
          result = await this.redis.brpoplpush(queueKey, processingKey, 1);
          if (result) {
            result = [result, '0']; // Format to match zpopmax
          }
        }

        if (result && result.length >= 1) {
          const messageData = result[0];
          
          try {
            const message: QueueMessage<T> = JSON.parse(messageData);
            
            // Process message
            const processingResult = await processor(message);
            
            if (processingResult.success) {
              // Remove from processing queue
              await this.redis.lrem(processingKey, 1, messageData);
              this.logger.debug(`Message processed successfully: ${message.id}`);
            } else {
              // Handle retry logic
              await this.handleRetry(queueName, message, processingResult.error || 'Unknown error');
              await this.redis.lrem(processingKey, 1, messageData);
            }
          } catch (error) {
            const message: QueueMessage<T> = JSON.parse(messageData);
            await this.handleRetry(queueName, message, error.message);
            await this.redis.lrem(processingKey, 1, messageData);
          }
        }
      } catch (error) {
        this.logger.error(`Queue worker error for ${queueName}:`, error);
      }

      // Continue processing
      setTimeout(processMessages, pollInterval);
    };

    // Start processing
    processMessages();
    
    this.logger.log(`Started queue worker ${workerId} for ${queueName}`);
  }

  private startDelayedMessageProcessor(queueName: string): void {
    const delayedKey = `queue:${queueName}:delayed`;
    const queueKey = `queue:${queueName}`;

    const processDelayedMessages = async () => {
      try {
        const now = Date.now();
        
        // Get messages that are ready to be processed
        const results = await this.redis.zrangebyscore(delayedKey, 0, now, 'LIMIT', 0, 10);
        
        for (const messageData of results) {
          // Move message to regular queue
          await this.redis.multi()
            .zrem(delayedKey, messageData)
            .rpush(queueKey, messageData)
            .exec();
          
          this.logger.debug(`Moved delayed message to active queue: ${queueName}`);
        }
      } catch (error) {
        this.logger.error(`Delayed message processor error for ${queueName}:`, error);
      }
    };

    // Process delayed messages every 5 seconds
    const interval = setInterval(processDelayedMessages, 5000);
    this.processingIntervals.set(`delayed:${queueName}`, interval);
  }

  private async handleRetry<T>(
    queueName: string,
    message: QueueMessage<T>,
    error: string
  ): Promise<void> {
    message.attempts++;
    message.lastError = error;
    message.failedAt = Date.now();

    if (message.attempts < message.maxAttempts) {
      // Calculate exponential backoff delay
      const retryDelay = Math.pow(2, message.attempts) * 1000;
      message.delay = retryDelay;
      
      // Add back to queue with delay
      await this.addToQueue(queueName, message);
      
      this.logger.warn(
        `Message ${message.id} failed (attempt ${message.attempts}/${message.maxAttempts}), retrying in ${retryDelay}ms`
      );
    } else {
      // Send to dead letter queue
      {{#if dlq}}
      await this.addToDeadLetterQueue(queueName, message, error);
      {{/if}}
      
      this.logger.error(
        `Message ${message.id} failed permanently after ${message.attempts} attempts`
      );
    }
  }

  {{#if dlq}}
  private async addToDeadLetterQueue<T>(
    originalQueue: string,
    message: QueueMessage<T>,
    error: string
  ): Promise<void> {
    const dlqKey = `dlq:${originalQueue}`;
    const dlqMessage = {
      ...message,
      originalQueue,
      sentToDLQAt: Date.now(),
      reason: error
    };

    await this.redis.rpush(dlqKey, JSON.stringify(dlqMessage));
    this.logger.warn(`Message sent to DLQ: ${message.id} from ${originalQueue}`);
  }

  async reprocessFromDLQ(queueName: string, limit = 10): Promise<number> {
    const dlqKey = `dlq:${queueName}`;
    const queueKey = `queue:${queueName}`;
    
    const messages = await this.redis.lrange(dlqKey, 0, limit - 1);
    let reprocessedCount = 0;

    for (const messageData of messages) {
      try {
        const dlqMessage = JSON.parse(messageData);
        
        // Reset attempts and remove DLQ-specific fields
        const message = {
          ...dlqMessage,
          attempts: 0,
          delay: 0
        };
        delete message.originalQueue;
        delete message.sentToDLQAt;
        delete message.reason;

        // Move back to active queue
        await this.redis.multi()
          .lrem(dlqKey, 1, messageData)
          .rpush(queueKey, JSON.stringify(message))
          .exec();

        reprocessedCount++;
        this.logger.log(`Reprocessed message from DLQ: ${message.id}`);
      } catch (error) {
        this.logger.error('Error reprocessing message from DLQ:', error);
      }
    }

    return reprocessedCount;
  }

  async getDLQLength(queueName: string): Promise<number> {
    return await this.redis.llen(`dlq:${queueName}`);
  }
  {{/if}}

  async getQueueLength(queueName: string): Promise<number> {
    const regular = await this.redis.llen(`queue:${queueName}`);
    const priority = await this.redis.zcard(`queue:${queueName}:priority`);
    const delayed = await this.redis.zcard(`queue:${queueName}:delayed`);
    
    return regular + priority + delayed;
  }

  async getProcessingLength(queueName: string): Promise<number> {
    return await this.redis.llen(`processing:${queueName}`);
  }

  async purgeQueue(queueName: string): Promise<number> {
    const queueKey = `queue:${queueName}`;
    const priorityKey = `${queueKey}:priority`;
    const delayedKey = `${queueKey}:delayed`;
    const processingKey = `processing:${queueName}`;

    const pipeline = this.redis.pipeline();
    pipeline.llen(queueKey);
    pipeline.zcard(priorityKey);
    pipeline.zcard(delayedKey);
    pipeline.llen(processingKey);
    
    const lengths = await pipeline.exec();
    const totalLength = lengths?.reduce((sum, [err, length]) => sum + (length as number || 0), 0) || 0;

    // Delete all queue keys
    await this.redis.multi()
      .del(queueKey)
      .del(priorityKey)
      .del(delayedKey)
      .del(processingKey)
      .exec();

    return totalLength;
  }

  async pauseQueue(queueName: string): Promise<void> {
    // Stop processing by clearing intervals
    const intervalKeys = Array.from(this.processingIntervals.keys()).filter(key => 
      key.includes(queueName)
    );

    for (const key of intervalKeys) {
      const interval = this.processingIntervals.get(key);
      if (interval) {
        clearInterval(interval);
        this.processingIntervals.delete(key);
      }
    }

    this.logger.log(`Paused queue: ${queueName}`);
  }

  async resumeQueue<T>(
    queueName: string,
    processor: (message: QueueMessage<T>) => Promise<MessageProcessingResult>
  ): Promise<void> {
    // Restart processing
    await this.processQueue(queueName, processor);
    this.logger.log(`Resumed queue: ${queueName}`);
  }

  async getQueueStats(queueName: string): Promise<{
    waiting: number;
    processing: number;
    delayed: number;
    priority: number;
    {{#if dlq}}
    dlq: number;
    {{/if}}
  }> {
    const queueKey = `queue:${queueName}`;
    
    return {
      waiting: await this.redis.llen(queueKey),
      processing: await this.redis.llen(`processing:${queueName}`),
      delayed: await this.redis.zcard(`${queueKey}:delayed`),
      priority: await this.redis.zcard(`${queueKey}:priority`),
      {{#if dlq}}
      dlq: await this.redis.llen(`dlq:${queueName}`)
      {{/if}}
    };
  }

  // Pub/Sub functionality
  async publish(channel: string, message: any): Promise<number> {
    const serialized = JSON.stringify({
      ...message,
      timestamp: Date.now()
    });
    
    return await this.redis.publish(`channel:${channel}`, serialized);
  }

  async subscribe(
    channel: string,
    callback: (message: any) => void
  ): Promise<Redis> {
    const subscriber = this.redis.duplicate();
    
    await subscriber.subscribe(`channel:${channel}`);
    
    subscriber.on('message', (receivedChannel, message) => {
      if (receivedChannel === `channel:${channel}`) {
        try {
          const parsed = JSON.parse(message);
          callback(parsed);
        } catch (error) {
          this.logger.error(`Error parsing pub/sub message for channel ${channel}:`, error);
        }
      }
    });

    return subscriber;
  }

  onModuleDestroy(): void {
    // Clear all processing intervals
    for (const interval of this.processingIntervals.values()) {
      clearInterval(interval);
    }
    this.processingIntervals.clear();
  }
}