/**
 * RabbitMQ Service Implementation
 * Generated by Xaheen CLI
 */

import { Injectable, Logger, OnModuleDestroy } from '@nestjs/common';
import * as amqp from 'amqplib';

export interface RabbitMQMessage<T = any> {
  id: string;
  payload: T;
  timestamp: number;
  attempts: number;
  maxAttempts: number;
  routingKey: string;
  exchange: string;
  metadata: Record<string, any>;
}

export interface RabbitMQOptions {
  durable?: boolean;
  persistent?: boolean;
  prefetch?: number;
  retryDelay?: number;
  maxRetries?: number;
}

export interface ExchangeOptions {
  type: 'direct' | 'topic' | 'fanout' | 'headers';
  durable?: boolean;
  autoDelete?: boolean;
}

export interface QueueOptions {
  durable?: boolean;
  exclusive?: boolean;
  autoDelete?: boolean;
  messageTtl?: number;
  maxLength?: number;
  deadLetterExchange?: string;
  deadLetterRoutingKey?: string;
}

@Injectable()
export class {{pascalCase name}}RabbitMQService implements OnModuleDestroy {
  private readonly logger = new Logger({{pascalCase name}}RabbitMQService.name);
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;
  private consumers = new Map<string, amqp.Replies.Consume>();

  constructor() {
    this.connect();
  }

  async connect(): Promise<void> {
    try {
      const connectionUrl = process.env.RABBITMQ_URL || 'amqp://localhost:5672';
      
      this.connection = await amqp.connect(connectionUrl, {
        heartbeat: 60,
        {{#if clustering}}
        clientProperties: {
          connection_name: `{{name}}-${process.pid}`
        }
        {{/if}}
      });

      this.channel = await this.connection.createChannel();
      
      {{#if performance.prefetch}}
      // Set prefetch count for better load balancing
      await this.channel.prefetch({{performance.prefetch}});
      {{/if}}

      this.connection.on('error', (error) => {
        this.logger.error('RabbitMQ connection error:', error);
      });

      this.connection.on('close', () => {
        this.logger.warn('RabbitMQ connection closed');
        this.reconnect();
      });

      this.logger.log('Connected to RabbitMQ');
    } catch (error) {
      this.logger.error('Failed to connect to RabbitMQ:', error);
      throw error;
    }
  }

  private async reconnect(): Promise<void> {
    this.logger.log('Attempting to reconnect to RabbitMQ...');
    
    // Wait before reconnecting
    await new Promise(resolve => setTimeout(resolve, 5000));
    
    try {
      await this.connect();
    } catch (error) {
      this.logger.error('Reconnection failed, retrying...', error);
      this.reconnect();
    }
  }

  async createExchange(
    exchangeName: string,
    options: ExchangeOptions = { type: 'direct', durable: true }
  ): Promise<void> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    await this.channel.assertExchange(exchangeName, options.type, {
      durable: options.durable ?? true,
      autoDelete: options.autoDelete ?? false
    });

    this.logger.debug(`Exchange created: ${exchangeName} (${options.type})`);
  }

  async createQueue(
    queueName: string,
    options: QueueOptions = { durable: true }
  ): Promise<amqp.Replies.AssertQueue> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    const queueArgs: any = {};
    
    if (options.messageTtl) {
      queueArgs['x-message-ttl'] = options.messageTtl;
    }
    
    if (options.maxLength) {
      queueArgs['x-max-length'] = options.maxLength;
    }
    
    {{#if dlq}}
    if (options.deadLetterExchange) {
      queueArgs['x-dead-letter-exchange'] = options.deadLetterExchange;
      if (options.deadLetterRoutingKey) {
        queueArgs['x-dead-letter-routing-key'] = options.deadLetterRoutingKey;
      }
    }
    {{/if}}

    const result = await this.channel.assertQueue(queueName, {
      durable: options.durable ?? true,
      exclusive: options.exclusive ?? false,
      autoDelete: options.autoDelete ?? false,
      arguments: queueArgs
    });

    this.logger.debug(`Queue created: ${queueName}`);
    return result;
  }

  async bindQueue(
    queueName: string,
    exchangeName: string,
    routingKey: string = ''
  ): Promise<void> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    await this.channel.bindQueue(queueName, exchangeName, routingKey);
    this.logger.debug(`Queue bound: ${queueName} -> ${exchangeName} (${routingKey})`);
  }

  async publish<T>(
    exchangeName: string,
    routingKey: string,
    message: T,
    options: RabbitMQOptions = {}
  ): Promise<boolean> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    const rabbitMQMessage: RabbitMQMessage<T> = {
      id: this.generateId(),
      payload: message,
      timestamp: Date.now(),
      attempts: 0,
      maxAttempts: options.maxRetries || 3,
      routingKey,
      exchange: exchangeName,
      metadata: {}
    };

    const buffer = Buffer.from(JSON.stringify(rabbitMQMessage));
    
    const publishOptions: amqp.Options.Publish = {
      persistent: options.persistent ?? true,
      timestamp: Date.now(),
      messageId: rabbitMQMessage.id,
      deliveryMode: options.persistent ? 2 : 1
    };

    const result = this.channel.publish(exchangeName, routingKey, buffer, publishOptions);
    
    if (result) {
      this.logger.debug(`Message published: ${rabbitMQMessage.id} to ${exchangeName}/${routingKey}`);
    } else {
      this.logger.warn(`Failed to publish message: ${rabbitMQMessage.id}`);
    }

    return result;
  }

  async consume<T>(
    queueName: string,
    callback: (message: RabbitMQMessage<T>) => Promise<{ success: boolean; error?: string }>,
    options: RabbitMQOptions = {}
  ): Promise<string> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    const consumerTag = `consumer_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const consumer = await this.channel.consume(
      queueName,
      async (msg) => {
        if (!msg) return;

        try {
          const rabbitMQMessage: RabbitMQMessage<T> = JSON.parse(msg.content.toString());
          
          this.logger.debug(`Processing message: ${rabbitMQMessage.id} from ${queueName}`);

          const result = await callback(rabbitMQMessage);

          if (result.success) {
            this.channel!.ack(msg);
            this.logger.debug(`Message acknowledged: ${rabbitMQMessage.id}`);
          } else {
            // Check if we should retry
            rabbitMQMessage.attempts++;
            
            if (rabbitMQMessage.attempts < rabbitMQMessage.maxAttempts) {
              // Reject and requeue with delay
              setTimeout(() => {
                this.channel!.nack(msg, false, true);
              }, options.retryDelay || 1000);
              
              this.logger.warn(
                `Message retrying: ${rabbitMQMessage.id} (attempt ${rabbitMQMessage.attempts}/${rabbitMQMessage.maxAttempts})`
              );
            } else {
              // Max retries reached, reject without requeue (goes to DLQ if configured)
              this.channel!.nack(msg, false, false);
              
              this.logger.error(
                `Message failed permanently: ${rabbitMQMessage.id} after ${rabbitMQMessage.attempts} attempts`
              );
            }
          }
        } catch (error) {
          this.logger.error(`Error processing message from ${queueName}:`, error);
          this.channel!.nack(msg, false, false);
        }
      },
      {
        consumerTag,
        noAck: false
      }
    );

    this.consumers.set(consumerTag, consumer);
    this.logger.log(`Started consumer: ${consumerTag} for queue: ${queueName}`);

    return consumerTag;
  }

  async stopConsumer(consumerTag: string): Promise<void> {
    if (!this.channel) return;

    const consumer = this.consumers.get(consumerTag);
    if (consumer) {
      await this.channel.cancel(consumerTag);
      this.consumers.delete(consumerTag);
      this.logger.log(`Stopped consumer: ${consumerTag}`);
    }
  }

  {{#if features}}
  {{#each features}}
  {{#if (eq this 'job-processing')}}
  // Job processing specific methods
  async submitJob<T>(
    jobType: string,
    payload: T,
    options: { priority?: number; delay?: number } = {}
  ): Promise<string> {
    const exchangeName = 'jobs';
    const routingKey = `job.${jobType}`;
    
    // Create exchange if it doesn't exist
    await this.createExchange(exchangeName, { type: 'topic' });
    
    // Create queue for this job type
    const queueName = `jobs.${jobType}`;
    await this.createQueue(queueName, { 
      durable: true,
      arguments: options.priority ? { 'x-max-priority': 10 } : undefined
    });
    await this.bindQueue(queueName, exchangeName, routingKey);

    const jobId = this.generateId();
    const jobMessage = {
      id: jobId,
      type: jobType,
      payload,
      priority: options.priority || 0,
      delay: options.delay || 0,
      submittedAt: Date.now()
    };

    await this.publish(exchangeName, routingKey, jobMessage, {
      persistent: true
    });

    return jobId;
  }

  async processJobs<T>(
    jobType: string,
    processor: (job: any) => Promise<any>
  ): Promise<string> {
    const queueName = `jobs.${jobType}`;
    
    return this.consume(queueName, async (message) => {
      try {
        const result = await processor(message.payload);
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
  }
  {{/if}}

  {{#if (eq this 'pub-sub')}}
  // Pub/Sub specific methods
  async subscribeToTopic<T>(
    topic: string,
    callback: (message: T) => Promise<void>
  ): Promise<string> {
    const exchangeName = 'pubsub';
    const queueName = `topic.${topic}.${this.generateId()}`;
    
    // Create topic exchange
    await this.createExchange(exchangeName, { type: 'topic' });
    
    // Create temporary queue for this subscription
    await this.createQueue(queueName, { 
      exclusive: true,
      autoDelete: true
    });
    
    await this.bindQueue(queueName, exchangeName, topic);

    return this.consume(queueName, async (message) => {
      try {
        await callback(message.payload);
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
  }

  async publishToTopic<T>(topic: string, message: T): Promise<boolean> {
    const exchangeName = 'pubsub';
    
    // Create exchange if it doesn't exist
    await this.createExchange(exchangeName, { type: 'topic' });
    
    return this.publish(exchangeName, topic, message);
  }
  {{/if}}

  {{#if (eq this 'event-streaming')}}
  // Event streaming specific methods
  async publishEvent<T>(
    eventType: string,
    eventData: T,
    routingKey?: string
  ): Promise<string> {
    const exchangeName = 'events';
    const routing = routingKey || eventType;
    
    await this.createExchange(exchangeName, { type: 'topic' });
    
    const event = {
      id: this.generateId(),
      type: eventType,
      data: eventData,
      timestamp: Date.now(),
      source: '{{name}}'
    };

    await this.publish(exchangeName, routing, event);
    return event.id;
  }

  async subscribeToEvents<T>(
    eventPattern: string,
    handler: (event: any) => Promise<void>
  ): Promise<string> {
    const exchangeName = 'events';
    const queueName = `events.${eventPattern.replace(/[.*]/g, '_')}.${this.generateId()}`;
    
    await this.createExchange(exchangeName, { type: 'topic' });
    await this.createQueue(queueName, { durable: false, autoDelete: true });
    await this.bindQueue(queueName, exchangeName, eventPattern);

    return this.consume(queueName, async (message) => {
      try {
        await handler(message.payload);
        return { success: true };
      } catch (error) {
        return { success: false, error: error.message };
      }
    });
  }
  {{/if}}
  {{/each}}
  {{/if}}

  {{#if dlq}}
  // Dead Letter Queue methods
  async setupDeadLetterQueue(originalQueueName: string): Promise<void> {
    const dlqName = `${originalQueueName}.dlq`;
    const dlqExchangeName = `${originalQueueName}.dlq.exchange`;
    
    // Create DLQ exchange and queue
    await this.createExchange(dlqExchangeName, { type: 'direct' });
    await this.createQueue(dlqName, { durable: true });
    await this.bindQueue(dlqName, dlqExchangeName, 'dlq');
  }

  async reprocessFromDLQ(
    originalQueueName: string,
    limit: number = 10
  ): Promise<number> {
    const dlqName = `${originalQueueName}.dlq`;
    let reprocessedCount = 0;

    // This would require more complex logic to peek messages and republish them
    // Implementation depends on specific requirements
    
    return reprocessedCount;
  }
  {{/if}}

  // Utility methods
  async getQueueInfo(queueName: string): Promise<{
    messageCount: number;
    consumerCount: number;
  }> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    const queueInfo = await this.channel.checkQueue(queueName);
    
    return {
      messageCount: queueInfo.messageCount,
      consumerCount: queueInfo.consumerCount
    };
  }

  async purgeQueue(queueName: string): Promise<number> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    const result = await this.channel.purgeQueue(queueName);
    this.logger.warn(`Purged ${result.messageCount} messages from queue: ${queueName}`);
    
    return result.messageCount;
  }

  async deleteQueue(queueName: string): Promise<void> {
    if (!this.channel) throw new Error('RabbitMQ channel not available');

    await this.channel.deleteQueue(queueName);
    this.logger.warn(`Deleted queue: ${queueName}`);
  }

  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  async onModuleDestroy(): Promise<void> {
    // Stop all consumers
    for (const consumerTag of this.consumers.keys()) {
      await this.stopConsumer(consumerTag);
    }

    // Close channel and connection
    if (this.channel) {
      await this.channel.close();
      this.channel = null;
    }

    if (this.connection) {
      await this.connection.close();
      this.connection = null;
    }

    this.logger.log('RabbitMQ service destroyed');
  }
}