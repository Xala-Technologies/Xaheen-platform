/**
 * SSE Client with Reconnection
 * Generated by Xaheen CLI
 */

export interface SSEClientOptions {
  url: string;
  retry?: number;
  retryDelay?: number;
  maxRetries?: number;
  headers?: Record<string, string>;
  withCredentials?: boolean;
  onOpen?: (event: Event) => void;
  onMessage?: (data: any) => void;
  onError?: (error: Event) => void;
  onClose?: (event: CloseEvent) => void;
  onReconnect?: (attempt: number) => void;
}

export class {{pascalCase name}}SSEClient {
  private eventSource: EventSource | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private isConnecting = false;
  private isDestroyed = false;
  private eventHandlers = new Map<string, ((data: any) => void)[]>();

  constructor(private options: SSEClientOptions) {
    this.connect();
  }

  private connect(): void {
    if (this.isConnecting || this.isDestroyed) return;

    this.isConnecting = true;
    
    try {
      const eventSourceInit: EventSourceInit = {};
      
      if (this.options.withCredentials) {
        eventSourceInit.withCredentials = this.options.withCredentials;
      }

      this.eventSource = new EventSource(this.options.url, eventSourceInit);

      this.eventSource.onopen = (event) => {
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        console.log('SSE connected');
        this.options.onOpen?.(event);
      };

      this.eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.options.onMessage?.(data);
          
          // Trigger specific event handlers
          this.triggerEventHandlers('message', data);
        } catch (error) {
          console.error('Error parsing SSE message:', error);
        }
      };

      this.eventSource.onerror = (event) => {
        this.isConnecting = false;
        console.error('SSE error:', event);
        this.options.onError?.(event);
        
        if (this.eventSource?.readyState === EventSource.CLOSED) {
          this.handleReconnect();
        }
      };

      // Setup custom event listeners
      this.setupCustomEventListeners();

    } catch (error) {
      this.isConnecting = false;
      console.error('Error creating EventSource:', error);
      this.handleReconnect();
    }
  }

  private setupCustomEventListeners(): void {
    if (!this.eventSource) return;

    {{#each features}}
    {{#if (eq this 'progress-tracking')}}
    this.eventSource.addEventListener('progress-update', (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        this.triggerEventHandlers('progress-update', data);
      } catch (error) {
        console.error('Error parsing progress update:', error);
      }
    });
    {{/if}}

    {{#if (eq this 'notifications')}}
    this.eventSource.addEventListener('notification', (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        this.triggerEventHandlers('notification', data);
      } catch (error) {
        console.error('Error parsing notification:', error);
      }
    });
    {{/if}}

    {{#if (eq this 'live-dashboard')}}
    this.eventSource.addEventListener('dashboard-metrics', (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        this.triggerEventHandlers('dashboard-metrics', data);
      } catch (error) {
        console.error('Error parsing dashboard metrics:', error);
      }
    });
    {{/if}}

    {{#if (eq this 'metrics-stream')}}
    this.eventSource.addEventListener('metric-update', (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        this.triggerEventHandlers('metric-update', data);
      } catch (error) {
        console.error('Error parsing metric update:', error);
      }
    });
    {{/if}}

    {{#if (eq this 'log-stream')}}
    this.eventSource.addEventListener('log-entry', (event) => {
      try {
        const data = JSON.parse((event as MessageEvent).data);
        this.triggerEventHandlers('log-entry', data);
      } catch (error) {
        console.error('Error parsing log entry:', error);
      }
    });
    {{/if}}
    {{/each}}

    // Setup ping/pong for heartbeat
    this.eventSource.addEventListener('ping', (event) => {
      // Optional: respond to ping if needed
      console.debug('SSE ping received');
    });
  }

  private handleReconnect(): void {
    if (this.isDestroyed) return;

    const maxRetries = this.options.maxRetries ?? 10;
    if (this.reconnectAttempts >= maxRetries) {
      console.error('Max SSE reconnection attempts reached');
      return;
    }

    this.reconnectAttempts++;
    const delay = this.calculateRetryDelay();

    console.log(`SSE reconnecting in ${delay}ms (attempt ${this.reconnectAttempts})`);
    this.options.onReconnect?.(this.reconnectAttempts);

    this.reconnectTimer = setTimeout(() => {
      if (!this.isDestroyed) {
        this.connect();
      }
    }, delay);
  }

  private calculateRetryDelay(): number {
    const baseDelay = this.options.retryDelay ?? 1000;
    const exponentialBackoff = Math.min(
      baseDelay * Math.pow(2, this.reconnectAttempts - 1),
      30000 // Max 30 seconds
    );
    
    // Add jitter to prevent thundering herd
    const jitter = Math.random() * 1000;
    return exponentialBackoff + jitter;
  }

  public addEventListener(type: string, listener: (data: any) => void): () => void {
    if (!this.eventHandlers.has(type)) {
      this.eventHandlers.set(type, []);
    }

    this.eventHandlers.get(type)!.push(listener);

    // Return unsubscribe function
    return () => {
      const handlers = this.eventHandlers.get(type);
      if (handlers) {
        const index = handlers.indexOf(listener);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }

  private triggerEventHandlers(type: string, data: any): void {
    const handlers = this.eventHandlers.get(type);
    if (handlers) {
      handlers.forEach(handler => {
        try {
          handler(data);
        } catch (error) {
          console.error(`Error in SSE event handler for ${type}:`, error);
        }
      });
    }
  }

  public close(): void {
    this.isDestroyed = true;
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }

    this.eventHandlers.clear();
  }

  public get readyState(): number {
    return this.eventSource?.readyState ?? EventSource.CLOSED;
  }

  public get isConnected(): boolean {
    return this.readyState === EventSource.OPEN;
  }

  public get url(): string {
    return this.eventSource?.url ?? '';
  }
}

{{#if includeReactHook}}
// React Hook for SSE
import { useEffect, useRef, useState } from 'react';

export function useSSE(options: SSEClientOptions) {
  const [data, setData] = useState<any>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Event | null>(null);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  
  const clientRef = useRef<{{pascalCase name}}SSEClient | null>(null);

  useEffect(() => {
    const client = new {{pascalCase name}}SSEClient({
      ...options,
      onOpen: (event) => {
        setIsConnected(true);
        setError(null);
        setReconnectAttempts(0);
        options.onOpen?.(event);
      },
      onMessage: (messageData) => {
        setData(messageData);
        options.onMessage?.(messageData);
      },
      onError: (errorEvent) => {
        setError(errorEvent);
        setIsConnected(false);
        options.onError?.(errorEvent);
      },
      onReconnect: (attempt) => {
        setReconnectAttempts(attempt);
        options.onReconnect?.(attempt);
      }
    });

    clientRef.current = client;

    return () => {
      client.close();
    };
  }, [options.url]);

  const addEventListener = (type: string, listener: (data: any) => void) => {
    return clientRef.current?.addEventListener(type, listener);
  };

  return {
    data,
    isConnected,
    error,
    reconnectAttempts,
    client: clientRef.current,
    addEventListener
  };
}

{{#each features}}
{{#if (eq this 'progress-tracking')}}
// Progress tracking hook
export function useProgressTracking(operationId: string, userId?: string) {
  const [progress, setProgress] = useState<any>(null);
  
  const url = `/api/sse/progress-tracking?operationId=${operationId}${userId ? `&userId=${userId}` : ''}`;
  
  const { isConnected, addEventListener } = useSSE({
    url,
    onMessage: (data) => {
      console.log('Progress SSE message:', data);
    }
  });

  useEffect(() => {
    const unsubscribe = addEventListener?.('progress-update', (data) => {
      setProgress(data);
    });

    return unsubscribe;
  }, [addEventListener]);

  return {
    progress,
    isConnected
  };
}
{{/if}}

{{#if (eq this 'notifications')}}
// Notifications hook
export function useNotifications(userId?: string, topics?: string[]) {
  const [notifications, setNotifications] = useState<any[]>([]);
  
  const queryParams = new URLSearchParams();
  if (userId) queryParams.set('userId', userId);
  if (topics) queryParams.set('topics', topics.join(','));
  
  const url = `/api/sse/notifications?${queryParams.toString()}`;
  
  const { isConnected, addEventListener } = useSSE({
    url,
    onMessage: (data) => {
      console.log('Notifications SSE message:', data);
    }
  });

  useEffect(() => {
    const unsubscribe = addEventListener?.('notification', (data) => {
      setNotifications(prev => [data, ...prev]);
    });

    return unsubscribe;
  }, [addEventListener]);

  const dismissNotification = (notificationId: string) => {
    setNotifications(prev => prev.filter(n => n.id !== notificationId));
  };

  return {
    notifications,
    isConnected,
    dismissNotification
  };
}
{{/if}}

{{#if (eq this 'live-dashboard')}}
// Dashboard metrics hook
export function useDashboardMetrics() {
  const [metrics, setMetrics] = useState<any>(null);
  
  const { isConnected, addEventListener } = useSSE({
    url: '/api/sse/live-dashboard',
    onMessage: (data) => {
      console.log('Dashboard SSE message:', data);
    }
  });

  useEffect(() => {
    const unsubscribe = addEventListener?.('dashboard-metrics', (data) => {
      setMetrics(data);
    });

    return unsubscribe;
  }, [addEventListener]);

  return {
    metrics,
    isConnected
  };
}
{{/if}}

{{#if (eq this 'metrics-stream')}}
// Metrics stream hook
export function useMetricsStream(metricNames?: string[]) {
  const [metrics, setMetrics] = useState<Record<string, any>>({});
  
  const queryParams = new URLSearchParams();
  if (metricNames) queryParams.set('metrics', metricNames.join(','));
  
  const url = `/api/sse/metrics-stream?${queryParams.toString()}`;
  
  const { isConnected, addEventListener } = useSSE({
    url,
    onMessage: (data) => {
      console.log('Metrics SSE message:', data);
    }
  });

  useEffect(() => {
    const unsubscribe = addEventListener?.('metric-update', (data) => {
      setMetrics(prev => ({
        ...prev,
        [data.name]: data
      }));
    });

    return unsubscribe;
  }, [addEventListener]);

  return {
    metrics,
    isConnected
  };
}
{{/if}}

{{#if (eq this 'log-stream')}}
// Log stream hook
export function useLogStream(levels?: string[], services?: string[]) {
  const [logs, setLogs] = useState<any[]>([]);
  
  const queryParams = new URLSearchParams();
  if (levels) queryParams.set('levels', levels.join(','));
  if (services) queryParams.set('services', services.join(','));
  
  const url = `/api/sse/log-stream?${queryParams.toString()}`;
  
  const { isConnected, addEventListener } = useSSE({
    url,
    onMessage: (data) => {
      console.log('Log SSE message:', data);
    }
  });

  useEffect(() => {
    const unsubscribe = addEventListener?.('log-entry', (data) => {
      setLogs(prev => [data, ...prev].slice(0, 1000)); // Keep last 1000 logs
    });

    return unsubscribe;
  }, [addEventListener]);

  const clearLogs = () => {
    setLogs([]);
  };

  return {
    logs,
    isConnected,
    clearLogs
  };
}
{{/if}}
{{/each}}
{{/if}}

export default {{pascalCase name}}SSEClient;