/**
 * Server-Sent Events Service
 * Generated by Xaheen CLI
 */

import { Injectable, Logger } from '@nestjs/common';
import { Request, Response } from 'express';

export interface SSEConnection {
  id: string;
  feature: string;
  userId?: string;
  req: Request;
  res: Response;
  createdAt: number;
  lastPing: number;
  isAlive: boolean;
  channels: Set<string>;
}

export interface SSEMessage {
  event?: string;
  data: any;
  id?: string;
  retry?: number;
}

@Injectable()
export class {{pascalCase name}}SSEService {
  private readonly logger = new Logger({{pascalCase name}}SSEService.name);
  private connections = new Map<string, SSEConnection>();
  private channels = new Map<string, Set<string>>();
  private heartbeatInterval: NodeJS.Timeout | null = null;

  constructor() {
    {{#if heartbeat.enabled}}
    this.startHeartbeat();
    {{/if}}
  }

  async handleConnection(
    connectionId: string,
    feature: string,
    req: Request,
    res: Response,
    query: any,
    userId?: string
  ): Promise<void> {
    const connection: SSEConnection = {
      id: connectionId,
      feature,
      userId,
      req,
      res,
      createdAt: Date.now(),
      lastPing: Date.now(),
      isAlive: true,
      channels: new Set()
    };

    this.connections.set(connectionId, connection);
    this.logger.log(`SSE connection established: ${connectionId} for feature: ${feature}`);

    // Subscribe to feature-specific channel
    this.subscribeToChannel(connectionId, `${feature}:${connectionId}`);

    // Feature-specific setup
    switch (feature) {
      {{#each features}}
      case '{{kebabCase this}}':
        await this.setup{{pascalCase this}}(connection, query);
        break;
      {{/each}}
    }
  }

  handleDisconnection(connectionId: string): void {
    const connection = this.connections.get(connectionId);
    if (!connection) return;

    // Remove from all channels
    for (const channelId of connection.channels) {
      this.unsubscribeFromChannel(connectionId, channelId);
    }

    this.connections.delete(connectionId);
    this.logger.log(`SSE connection closed: ${connectionId}`);
  }

  {{#each features}}
  {{#if (eq this 'live-dashboard')}}
  private async setupLiveDashboard(connection: SSEConnection, query: any): Promise<void> {
    // Subscribe to dashboard metrics channel
    this.subscribeToChannel(connection.id, 'dashboard-metrics');

    // Send initial metrics
    const metrics = await this.getDashboardMetrics();
    this.sendToConnection(connection.id, {
      event: 'dashboard-metrics',
      data: metrics
    });
  }

  private async getDashboardMetrics(): Promise<any> {
    // Implement dashboard metrics collection
    return {
      timestamp: Date.now(),
      activeUsers: Math.floor(Math.random() * 1000),
      requests: Math.floor(Math.random() * 10000),
      errors: Math.floor(Math.random() * 100),
      responseTime: Math.floor(Math.random() * 500),
      cpuUsage: Math.random() * 100,
      memoryUsage: Math.random() * 100
    };
  }
  {{/if}}

  {{#if (eq this 'progress-tracking')}}
  private async setupProgressTracking(connection: SSEConnection, query: any): Promise<void> {
    const { operationId, userId } = query;
    
    if (operationId) {
      this.subscribeToChannel(connection.id, `progress:${operationId}`);
    }
    
    if (userId) {
      this.subscribeToChannel(connection.id, `progress:user:${userId}`);
    }

    // Send any existing progress for the operation
    if (operationId) {
      const progress = await this.getOperationProgress(operationId);
      if (progress) {
        this.sendToConnection(connection.id, {
          event: 'progress-update',
          data: progress
        });
      }
    }
  }

  private async getOperationProgress(operationId: string): Promise<any> {
    // Implement progress retrieval logic
    return null;
  }

  public updateProgress(operationId: string, progress: number, message?: string): void {
    const progressData = {
      operationId,
      progress: Math.max(0, Math.min(100, progress)),
      message,
      timestamp: Date.now()
    };

    this.sendToChannel(`progress:${operationId}`, {
      event: 'progress-update',
      data: progressData
    });
  }
  {{/if}}

  {{#if (eq this 'notifications')}}
  private async setupNotifications(connection: SSEConnection, query: any): Promise<void> {
    const { userId, topics } = query;
    
    if (userId) {
      this.subscribeToChannel(connection.id, `notifications:user:${userId}`);
    }

    if (topics) {
      const topicList = typeof topics === 'string' ? topics.split(',') : topics;
      topicList.forEach((topic: string) => {
        this.subscribeToChannel(connection.id, `notifications:topic:${topic}`);
      });
    }

    // Subscribe to general notifications
    this.subscribeToChannel(connection.id, 'notifications:general');
  }

  public sendNotification(notification: {
    userId?: string;
    topic?: string;
    title: string;
    message: string;
    type: 'info' | 'success' | 'warning' | 'error';
  }): void {
    const notificationData = {
      id: this.generateId(),
      ...notification,
      timestamp: Date.now()
    };

    if (notification.userId) {
      this.sendToChannel(`notifications:user:${notification.userId}`, {
        event: 'notification',
        data: notificationData
      });
    } else if (notification.topic) {
      this.sendToChannel(`notifications:topic:${notification.topic}`, {
        event: 'notification',
        data: notificationData
      });
    } else {
      this.sendToChannel('notifications:general', {
        event: 'notification',
        data: notificationData
      });
    }
  }
  {{/if}}

  {{#if (eq this 'metrics-stream')}}
  private async setupMetricsStream(connection: SSEConnection, query: any): Promise<void> {
    const { metrics } = query;
    
    if (metrics) {
      const metricList = typeof metrics === 'string' ? metrics.split(',') : metrics;
      metricList.forEach((metric: string) => {
        this.subscribeToChannel(connection.id, `metrics:${metric}`);
      });
    } else {
      // Subscribe to all metrics
      this.subscribeToChannel(connection.id, 'metrics:all');
    }
  }

  public publishMetric(metricName: string, value: number, labels?: Record<string, string>): void {
    const metricData = {
      name: metricName,
      value,
      labels,
      timestamp: Date.now()
    };

    this.sendToChannel(`metrics:${metricName}`, {
      event: 'metric-update',
      data: metricData
    });

    this.sendToChannel('metrics:all', {
      event: 'metric-update',
      data: metricData
    });
  }
  {{/if}}

  {{#if (eq this 'log-stream')}}
  private async setupLogStream(connection: SSEConnection, query: any): Promise<void> {
    const { levels, services, search } = query;
    
    // Subscribe based on filters
    if (levels) {
      const levelList = typeof levels === 'string' ? levels.split(',') : levels;
      levelList.forEach((level: string) => {
        this.subscribeToChannel(connection.id, `logs:level:${level}`);
      });
    }

    if (services) {
      const serviceList = typeof services === 'string' ? services.split(',') : services;
      serviceList.forEach((service: string) => {
        this.subscribeToChannel(connection.id, `logs:service:${service}`);
      });
    }

    if (!levels && !services) {
      this.subscribeToChannel(connection.id, 'logs:all');
    }
  }

  public publishLog(log: {
    level: 'debug' | 'info' | 'warn' | 'error' | 'fatal';
    message: string;
    service: string;
    timestamp?: number;
    metadata?: any;
  }): void {
    const logData = {
      id: this.generateId(),
      timestamp: Date.now(),
      ...log
    };

    this.sendToChannel(`logs:level:${log.level}`, {
      event: 'log-entry',
      data: logData
    });

    this.sendToChannel(`logs:service:${log.service}`, {
      event: 'log-entry',
      data: logData
    });

    this.sendToChannel('logs:all', {
      event: 'log-entry',
      data: logData
    });
  }
  {{/if}}
  {{/each}}

  // Core SSE methods
  public sendToConnection(connectionId: string, message: SSEMessage): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection || !connection.isAlive) return false;

    try {
      const formattedMessage = this.formatSSEMessage(message);
      connection.res.write(formattedMessage);
      return true;
    } catch (error) {
      this.logger.error(`Error sending SSE message to ${connectionId}:`, error);
      this.handleDisconnection(connectionId);
      return false;
    }
  }

  public sendToChannel(channelId: string, message: SSEMessage): number {
    const connections = this.channels.get(channelId);
    if (!connections) return 0;

    let sentCount = 0;
    for (const connectionId of connections) {
      if (this.sendToConnection(connectionId, message)) {
        sentCount++;
      }
    }

    return sentCount;
  }

  public sendToUser(userId: string, message: SSEMessage): number {
    let sentCount = 0;
    for (const connection of this.connections.values()) {
      if (connection.userId === userId && connection.isAlive) {
        if (this.sendToConnection(connection.id, message)) {
          sentCount++;
        }
      }
    }
    return sentCount;
  }

  public broadcast(message: SSEMessage): number {
    let sentCount = 0;
    for (const connection of this.connections.values()) {
      if (connection.isAlive) {
        if (this.sendToConnection(connection.id, message)) {
          sentCount++;
        }
      }
    }
    return sentCount;
  }

  public subscribeToChannel(connectionId: string, channelId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    if (!this.channels.has(channelId)) {
      this.channels.set(channelId, new Set());
    }

    this.channels.get(channelId)!.add(connectionId);
    connection.channels.add(channelId);

    return true;
  }

  public unsubscribeFromChannel(connectionId: string, channelId: string): boolean {
    const connection = this.connections.get(connectionId);
    const channel = this.channels.get(channelId);

    if (!connection || !channel) return false;

    channel.delete(connectionId);
    connection.channels.delete(channelId);

    if (channel.size === 0) {
      this.channels.delete(channelId);
    }

    return true;
  }

  private formatSSEMessage(message: SSEMessage): string {
    let formatted = '';

    if (message.id) {
      formatted += `id: ${message.id}\n`;
    }

    if (message.event) {
      formatted += `event: ${message.event}\n`;
    }

    if (message.retry) {
      formatted += `retry: ${message.retry}\n`;
    }

    const data = typeof message.data === 'string' 
      ? message.data 
      : JSON.stringify(message.data);

    formatted += `data: ${data}\n\n`;

    return formatted;
  }

  {{#if heartbeat.enabled}}
  private startHeartbeat(): void {
    this.heartbeatInterval = setInterval(() => {
      const now = Date.now();
      for (const [connectionId, connection] of this.connections) {
        if (now - connection.lastPing > {{heartbeat.timeout}}) {
          this.handleDisconnection(connectionId);
        } else {
          this.sendToConnection(connectionId, {
            event: 'ping',
            data: { timestamp: now }
          });
          connection.lastPing = now;
        }
      }
    }, {{heartbeat.interval}});
  }
  {{/if}}

  public getHealthStatus(): { status: string; connections: number } {
    return {
      status: this.connections.size > 0 ? 'healthy' : 'idle',
      connections: this.connections.size
    };
  }

  public getMetrics(): any {
    return {
      totalConnections: this.connections.size,
      totalChannels: this.channels.size,
      connectionsByFeature: this.getConnectionsByFeature(),
      channelDistribution: this.getChannelDistribution()
    };
  }

  private getConnectionsByFeature(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    for (const connection of this.connections.values()) {
      distribution[connection.feature] = (distribution[connection.feature] || 0) + 1;
    }

    return distribution;
  }

  private getChannelDistribution(): Record<string, number> {
    const distribution: Record<string, number> = {};
    
    for (const [channelId, connections] of this.channels) {
      distribution[channelId] = connections.size;
    }

    return distribution;
  }

  private generateId(): string {
    return `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  onModuleDestroy(): void {
    {{#if heartbeat.enabled}}
    if (this.heartbeatInterval) {
      clearInterval(this.heartbeatInterval);
    }
    {{/if}}

    // Close all connections
    for (const connection of this.connections.values()) {
      connection.res.end();
    }

    this.connections.clear();
    this.channels.clear();
  }
}