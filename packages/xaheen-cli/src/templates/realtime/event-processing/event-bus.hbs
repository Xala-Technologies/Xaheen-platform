/**
 * Event Bus Implementation
 * Generated by Xaheen CLI
 */

import { Injectable, Logger } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';

export interface DomainEvent<T = any> {
  id: string;
  type: string;
  aggregateId: string;
  aggregateVersion: number;
  data: T;
  timestamp: number;
  sequence: number;
  metadata: EventMetadata;
}

export interface EventMetadata {
  correlationId?: string;
  causationId?: string;
  publisherId?: string;
  publishedAt?: number;
  [key: string]: any;
}

export interface EventHandler<T = any> {
  handle(event: DomainEvent<T>, context?: EventProcessingContext): Promise<any>;
}

export interface EventProcessingContext {
  isReplay?: boolean;
  correlationId?: string;
  causationId?: string;
  timestamp?: number;
  [key: string]: any;
}

export interface EventProcessingResult {
  success: boolean;
  result?: any;
  error?: string;
  processingTime?: number;
  handlerName?: string;
  retryAttempt?: number;
  retryDelay?: number;
  finalAttempt?: boolean;
}

export interface EventFilter {
  shouldProcess(event: DomainEvent): boolean;
}

@Injectable()
export class {{pascalCase name}}EventBus {
  private readonly logger = new Logger({{pascalCase name}}EventBus.name);
  private handlers = new Map<string, EventHandler[]>();
  private filters = new Map<string, EventFilter[]>();
  private eventHistory: DomainEvent[] = [];
  private sequenceNumber = 0;
  private processingStats = {
    eventsProcessed: 0,
    eventsPublished: 0,
    eventsFailed: 0,
    averageProcessingTime: 0
  };

  constructor(
    private readonly eventEmitter: EventEmitter2
  ) {
    this.setupEventTracking();
  }

  public async publish<T = any>(event: DomainEvent<T>): Promise<void> {
    try {
      const eventWithMetadata = this.enrichEventWithMetadata(event);
      
      // Store event history
      this.eventHistory.push(eventWithMetadata);
      
      // Apply filters
      if (this.shouldProcessEvent(eventWithMetadata)) {
        // Emit to NestJS event emitter
        await this.eventEmitter.emitAsync(event.type, eventWithMetadata);
        
        // Process through registered handlers
        await this.processEventHandlers(eventWithMetadata);
      }
      
      this.processingStats.eventsPublished++;
      this.logger.debug(`Event published: ${event.type} (${event.aggregateId})`);
      
    } catch (error) {
      this.processingStats.eventsFailed++;
      this.logger.error(`Failed to publish event: ${event.type}`, error);
      throw error;
    }
  }

  public async publishBatch<T = any>(events: DomainEvent<T>[]): Promise<void> {
    const publishPromises = events.map(event => this.publish(event));
    await Promise.all(publishPromises);
    
    this.logger.debug(`Batch events published: ${events.length} events`);
  }

  public registerHandler<T = any>(
    eventType: string,
    handler: EventHandler<T>
  ): () => void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    
    this.handlers.get(eventType)!.push(handler);
    
    this.logger.debug(`Event handler registered for: ${eventType}`);
    
    // Return unregister function
    return () => {
      const handlers = this.handlers.get(eventType);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }

  public registerFilter(eventType: string, filter: EventFilter): void {
    if (!this.filters.has(eventType)) {
      this.filters.set(eventType, []);
    }
    
    this.filters.get(eventType)!.push(filter);
    this.logger.debug(`Event filter registered for: ${eventType}`);
  }

  {{#if features}}
  {{#each features}}
  {{#if (eq this 'event-replay')}}
  public async replay(
    fromSequence?: number,
    toSequence?: number,
    eventTypes?: string[]
  ): Promise<void> {
    let eventsToReplay = this.eventHistory;
    
    // Filter by sequence numbers
    if (fromSequence !== undefined) {
      eventsToReplay = eventsToReplay.filter(e => e.sequence >= fromSequence);
    }
    
    if (toSequence !== undefined) {
      eventsToReplay = eventsToReplay.filter(e => e.sequence <= toSequence);
    }
    
    // Filter by event types
    if (eventTypes && eventTypes.length > 0) {
      eventsToReplay = eventsToReplay.filter(e => eventTypes.includes(e.type));
    }
    
    // Replay events in order
    for (const event of eventsToReplay) {
      await this.processEventHandlers(event, true);
    }
    
    this.logger.log(`Replayed ${eventsToReplay.length} events`);
  }
  {{/if}}

  {{#if (eq this 'domain-events')}}
  public async publishDomainEvent<T = any>(
    aggregateId: string,
    eventType: string,
    eventData: T,
    aggregateVersion: number,
    metadata?: Record<string, any>
  ): Promise<string> {
    const event: DomainEvent<T> = {
      id: this.generateEventId(),
      type: eventType,
      aggregateId,
      aggregateVersion,
      data: eventData,
      timestamp: Date.now(),
      sequence: 0, // Will be set by enrichEventWithMetadata
      metadata: {
        ...metadata,
        eventSource: 'domain'
      }
    };

    await this.publish(event);
    return event.id;
  }
  {{/if}}

  {{#if (eq this 'integration-events')}}
  public async publishIntegrationEvent<T = any>(
    eventType: string,
    eventData: T,
    targetService?: string,
    metadata?: Record<string, any>
  ): Promise<string> {
    const event: DomainEvent<T> = {
      id: this.generateEventId(),
      type: eventType,
      aggregateId: 'integration',
      aggregateVersion: 1,
      data: eventData,
      timestamp: Date.now(),
      sequence: 0,
      metadata: {
        ...metadata,
        eventSource: 'integration',
        targetService
      }
    };

    await this.publish(event);
    return event.id;
  }
  {{/if}}
  {{/each}}
  {{/if}}

  private async processEventHandlers<T = any>(
    event: DomainEvent<T>,
    isReplay = false
  ): Promise<void> {
    const handlers = this.handlers.get(event.type) || [];
    const startTime = Date.now();
    
    try {
      const results = await Promise.allSettled(
        handlers.map(handler => this.executeHandler(handler, event, isReplay))
      );
      
      // Log any handler failures
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          this.logger.error(
            `Handler ${index} failed for event ${event.type}: ${result.reason}`
          );
        }
      });
      
      const processingTime = Date.now() - startTime;
      this.updateProcessingStats(processingTime);
      
      this.processingStats.eventsProcessed++;
      
    } catch (error) {
      this.processingStats.eventsFailed++;
      throw error;
    }
  }

  private async executeHandler<T = any>(
    handler: EventHandler<T>,
    event: DomainEvent<T>,
    isReplay: boolean
  ): Promise<EventProcessingResult> {
    const startTime = Date.now();
    
    try {
      const result = await handler.handle(event, { isReplay });
      
      return {
        success: true,
        handlerName: handler.constructor.name,
        processingTime: Date.now() - startTime,
        result
      };
    } catch (error) {
      {{#if retry.enabled}}
      // Apply retry logic if enabled
      return await this.retryHandler(handler, event, error, isReplay);
      {{else}}
      throw error;
      {{/if}}
    }
  }

  {{#if retry.enabled}}
  private async retryHandler<T = any>(
    handler: EventHandler<T>,
    event: DomainEvent<T>,
    error: Error,
    isReplay: boolean,
    attempt = 1
  ): Promise<EventProcessingResult> {
    if (attempt > {{retry.maxAttempts}}) {
      return {
        success: false,
        handlerName: handler.constructor.name,
        error: error.message,
        finalAttempt: true
      };
    }

    const delay = this.calculateRetryDelay(attempt);
    
    await new Promise(resolve => setTimeout(resolve, delay));

    try {
      const result = await handler.handle(event, { isReplay });
      
      return {
        success: true,
        handlerName: handler.constructor.name,
        processingTime: Date.now() - event.timestamp,
        result,
        retryAttempt: attempt
      };
    } catch (retryError) {
      return await this.retryHandler(handler, event, retryError, isReplay, attempt + 1);
    }
  }

  private calculateRetryDelay(attempt: number): number {
    switch ('{{retry.backoffStrategy}}') {
      case 'exponential':
        return {{retry.baseDelay}} * Math.pow(2, attempt - 1);
      case 'linear':
        return {{retry.baseDelay}} * attempt;
      case 'fixed':
      default:
        return {{retry.baseDelay}};
    }
  }
  {{/if}}

  private enrichEventWithMetadata<T = any>(event: DomainEvent<T>): DomainEvent<T> {
    const metadata: EventMetadata = {
      ...event.metadata,
      publishedAt: Date.now(),
      publisherId: process.env.SERVICE_ID || '{{name}}',
      correlationId: event.metadata?.correlationId || this.generateCorrelationId(),
      causationId: event.metadata?.causationId || event.id
    };

    return {
      ...event,
      sequence: this.getNextSequenceNumber(),
      metadata
    };
  }

  private shouldProcessEvent<T = any>(event: DomainEvent<T>): boolean {
    const filters = this.filters.get(event.type) || [];
    
    return filters.every(filter => filter.shouldProcess(event));
  }

  private setupEventTracking(): void {
    // Track event emissions from NestJS EventEmitter
    this.eventEmitter.on('*', (eventType, event) => {
      this.logger.debug(`Event emitted via EventEmitter: ${eventType}`);
    });
  }

  private updateProcessingStats(processingTime: number): void {
    const currentAvg = this.processingStats.averageProcessingTime;
    const processed = this.processingStats.eventsProcessed;
    
    this.processingStats.averageProcessingTime = 
      (currentAvg * processed + processingTime) / (processed + 1);
  }

  private getNextSequenceNumber(): number {
    return ++this.sequenceNumber;
  }

  private generateCorrelationId(): string {
    return `corr_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private generateEventId(): string {
    return `evt_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  // Public query methods
  public getStats() {
    return {
      ...this.processingStats,
      totalHandlers: Array.from(this.handlers.values()).reduce((sum, handlers) => sum + handlers.length, 0),
      eventTypesHandled: this.handlers.size,
      eventHistorySize: this.eventHistory.length
    };
  }

  public getEventHistory(
    eventType?: string,
    aggregateId?: string,
    limit = 100
  ): DomainEvent[] {
    let filtered = this.eventHistory;
    
    if (eventType) {
      filtered = filtered.filter(e => e.type === eventType);
    }
    
    if (aggregateId) {
      filtered = filtered.filter(e => e.aggregateId === aggregateId);
    }
    
    return filtered.slice(-limit);
  }

  public getEventsByCorrelationId(correlationId: string): DomainEvent[] {
    return this.eventHistory.filter(e => e.metadata.correlationId === correlationId);
  }

  public getHandlerCount(eventType: string): number {
    return this.handlers.get(eventType)?.length || 0;
  }

  public getRegisteredEventTypes(): string[] {
    return Array.from(this.handlers.keys());
  }

  public clearEventHistory(): void {
    this.eventHistory = [];
    this.sequenceNumber = 0;
    this.logger.warn('Event history cleared');
  }

  {{#if eventSourcing.enabled}}
  // Event Sourcing support
  public async loadEventsForAggregate(
    aggregateId: string,
    fromVersion?: number
  ): Promise<DomainEvent[]> {
    let events = this.eventHistory.filter(e => e.aggregateId === aggregateId);
    
    if (fromVersion !== undefined) {
      events = events.filter(e => e.aggregateVersion > fromVersion);
    }
    
    return events.sort((a, b) => a.aggregateVersion - b.aggregateVersion);
  }

  public getLastEventForAggregate(aggregateId: string): DomainEvent | undefined {
    const events = this.eventHistory
      .filter(e => e.aggregateId === aggregateId)
      .sort((a, b) => b.aggregateVersion - a.aggregateVersion);
    
    return events[0];
  }
  {{/if}}
}