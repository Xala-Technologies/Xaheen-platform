import { BaseGenerator } from "../base.generator";
import { GeneratedFile } from "../../types/generator.types";

export interface EventProcessingOptions {
	projectName: string;
	framework: "nestjs" | "express" | "fastify" | "hono";
	patterns: EventPattern[];
	storage: "memory" | "redis" | "mongodb" | "postgresql" | "eventstore";
	features: EventProcessingFeature[];
	retry: {
		enabled: boolean;
		maxAttempts: number;
		backoffStrategy: "exponential" | "linear" | "fixed";
		baseDelay: number;
	};
	eventSourcing: {
		enabled: boolean;
		snapshotInterval: number;
		replayFromSnapshot: boolean;
	};
	monitoring: boolean;
	validation: {
		enabled: boolean;
		schemaRegistry: boolean;
	};
}

export type EventPattern =
	| "event-sourcing"
	| "cqrs"
	| "saga"
	| "event-replay"
	| "event-projection"
	| "event-handler"
	| "event-aggregation"
	| "event-filtering";

export type EventProcessingFeature =
	| "domain-events"
	| "integration-events"
	| "command-handling"
	| "query-handling"
	| "saga-orchestration"
	| "event-store"
	| "read-model-projection"
	| "event-versioning";

export class EventProcessingGenerator extends BaseGenerator {
	async generate(options: EventProcessingOptions): Promise<GeneratedFile[]> {
		const files: GeneratedFile[] = [];

		// Core event processing infrastructure
		files.push(this.generateEventBus(options));
		files.push(this.generateEventStore(options));
		files.push(this.generateEventProcessor(options));
		files.push(this.generateEventProcessingModule(options));

		// Pattern implementations
		for (const pattern of options.patterns) {
			files.push(...this.generatePatternImplementation(pattern, options));
		}

		// Feature implementations
		for (const feature of options.features) {
			files.push(...this.generateFeatureImplementation(feature, options));
		}

		// Event sourcing implementation
		if (options.eventSourcing.enabled) {
			files.push(...this.generateEventSourcingImplementation(options));
		}

		// Retry mechanism
		if (options.retry.enabled) {
			files.push(this.generateRetryHandler(options));
		}

		// Schema validation
		if (options.validation.enabled) {
			files.push(...this.generateValidationImplementation(options));
		}

		// Monitoring and metrics
		if (options.monitoring) {
			files.push(...this.generateMonitoringImplementation(options));
		}

		// Configuration and types
		files.push(this.generateTypes(options));
		files.push(this.generateConfiguration(options));

		// Testing utilities
		files.push(...this.generateTestFiles(options));

		// Client utilities and projections
		files.push(...this.generateClientUtils(options));

		return files;
	}

	private generateEventBus(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * Event Bus
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { 
  DomainEvent, 
  EventHandler, 
  EventProcessingResult,
  EventMetadata,
  EventFilter 
} from './types/event-processing.types';

@Injectable()
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus {
  private readonly logger = new Logger(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus.name);
  private handlers = new Map<string, EventHandler[]>();
  private filters = new Map<string, EventFilter[]>();
  private eventHistory: DomainEvent[] = [];
  private processingStats = {
    eventsProcessed: 0,
    eventsPublished: 0,
    eventsFailed: 0,
    averageProcessingTime: 0
  };

  constructor(
    private readonly eventEmitter: EventEmitter2
  ) {
    this.setupEventTracking();
  }

  public async publish<T = any>(event: DomainEvent<T>): Promise<void> {
    try {
      const eventWithMetadata = this.enrichEventWithMetadata(event);
      
      // Store event history
      this.eventHistory.push(eventWithMetadata);
      
      // Apply filters
      if (this.shouldProcessEvent(eventWithMetadata)) {
        // Emit to handlers
        await this.eventEmitter.emitAsync(event.type, eventWithMetadata);
        
        // Process through registered handlers
        await this.processEventHandlers(eventWithMetadata);
      }
      
      this.processingStats.eventsPublished++;
      this.logger.debug(\`Event published: \${event.type} (\${event.aggregateId})\`);
      
    } catch (error) {
      this.processingStats.eventsFailed++;
      this.logger.error(\`Failed to publish event: \${event.type}\`, error);
      throw error;
    }
  }

  public async publishBatch<T = any>(events: DomainEvent<T>[]): Promise<void> {
    const promises = events.map(event => this.publish(event));
    await Promise.all(promises);
    
    this.logger.debug(\`Batch events published: \${events.length} events\`);
  }

  public registerHandler<T = any>(
    eventType: string,
    handler: EventHandler<T>
  ): () => void {
    if (!this.handlers.has(eventType)) {
      this.handlers.set(eventType, []);
    }
    
    this.handlers.get(eventType)!.push(handler);
    
    this.logger.debug(\`Event handler registered for: \${eventType}\`);
    
    // Return unregister function
    return () => {
      const handlers = this.handlers.get(eventType);
      if (handlers) {
        const index = handlers.indexOf(handler);
        if (index > -1) {
          handlers.splice(index, 1);
        }
      }
    };
  }

  public registerFilter(eventType: string, filter: EventFilter): void {
    if (!this.filters.has(eventType)) {
      this.filters.set(eventType, []);
    }
    
    this.filters.get(eventType)!.push(filter);
    this.logger.debug(\`Event filter registered for: \${eventType}\`);
  }

  public async replay(
    fromSequence?: number,
    toSequence?: number,
    eventTypes?: string[]
  ): Promise<void> {
    let eventsToReplay = this.eventHistory;
    
    // Filter by sequence numbers
    if (fromSequence !== undefined) {
      eventsToReplay = eventsToReplay.filter(e => e.sequence >= fromSequence);
    }
    
    if (toSequence !== undefined) {
      eventsToReplay = eventsToReplay.filter(e => e.sequence <= toSequence);
    }
    
    // Filter by event types
    if (eventTypes && eventTypes.length > 0) {
      eventsToReplay = eventsToReplay.filter(e => eventTypes.includes(e.type));
    }
    
    // Replay events in order
    for (const event of eventsToReplay) {
      await this.processEventHandlers(event, true);
    }
    
    this.logger.log(\`Replayed \${eventsToReplay.length} events\`);
  }

  private async processEventHandlers<T = any>(
    event: DomainEvent<T>,
    isReplay = false
  ): Promise<void> {
    const handlers = this.handlers.get(event.type) || [];
    const startTime = Date.now();
    
    try {
      const results = await Promise.allSettled(
        handlers.map(handler => this.executeHandler(handler, event, isReplay))
      );
      
      // Log any handler failures
      results.forEach((result, index) => {
        if (result.status === 'rejected') {
          this.logger.error(
            \`Handler \${index} failed for event \${event.type}: \${result.reason}\`
          );
        }
      });
      
      const processingTime = Date.now() - startTime;
      this.updateProcessingStats(processingTime);
      
      this.processingStats.eventsProcessed++;
      
    } catch (error) {
      this.processingStats.eventsFailed++;
      throw error;
    }
  }

  private async executeHandler<T = any>(
    handler: EventHandler<T>,
    event: DomainEvent<T>,
    isReplay: boolean
  ): Promise<EventProcessingResult> {
    try {
      const result = await handler.handle(event, { isReplay });
      
      return {
        success: true,
        handlerName: handler.constructor.name,
        processingTime: Date.now() - event.timestamp,
        result
      };
    } catch (error) {
      ${
				options.retry.enabled
					? `
      // Apply retry logic if enabled
      return await this.retryHandler(handler, event, error, isReplay);
      `
					: `
      throw error;
      `
			}
    }
  }

  ${options.retry.enabled ? this.getRetryLogic(options) : ""}

  private enrichEventWithMetadata<T = any>(event: DomainEvent<T>): DomainEvent<T> {
    const metadata: EventMetadata = {
      ...event.metadata,
      publishedAt: Date.now(),
      publisherId: process.env.SERVICE_ID || 'unknown',
      correlationId: event.metadata?.correlationId || this.generateCorrelationId(),
      causationId: event.metadata?.causationId || event.id
    };

    return {
      ...event,
      sequence: this.getNextSequenceNumber(),
      metadata
    };
  }

  private shouldProcessEvent<T = any>(event: DomainEvent<T>): boolean {
    const filters = this.filters.get(event.type) || [];
    
    return filters.every(filter => filter.shouldProcess(event));
  }

  private setupEventTracking(): void {
    // Track event emissions
    this.eventEmitter.on('*', (event) => {
      this.logger.debug(\`Event emitted: \${event.type}\`);
    });
  }

  private updateProcessingStats(processingTime: number): void {
    const currentAvg = this.processingStats.averageProcessingTime;
    const processed = this.processingStats.eventsProcessed;
    
    this.processingStats.averageProcessingTime = 
      (currentAvg * processed + processingTime) / (processed + 1);
  }

  private getNextSequenceNumber(): number {
    return this.eventHistory.length + 1;
  }

  private generateCorrelationId(): string {
    return \`corr_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  public getStats() {
    return {
      ...this.processingStats,
      totalHandlers: Array.from(this.handlers.values()).reduce((sum, handlers) => sum + handlers.length, 0),
      eventTypesHandled: this.handlers.size,
      eventHistorySize: this.eventHistory.length
    };
  }

  public getEventHistory(
    eventType?: string,
    aggregateId?: string,
    limit = 100
  ): DomainEvent[] {
    let filtered = this.eventHistory;
    
    if (eventType) {
      filtered = filtered.filter(e => e.type === eventType);
    }
    
    if (aggregateId) {
      filtered = filtered.filter(e => e.aggregateId === aggregateId);
    }
    
    return filtered.slice(-limit);
  }

  public clearEventHistory(): void {
    this.eventHistory = [];
    this.logger.warn('Event history cleared');
  }
}`;

		return {
			path: `src/events/${options.projectName}-event-bus.service.ts`,
			content,
			type: "service",
		};
	}

	private generateEventStore(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * Event Store
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { 
  DomainEvent, 
  EventStream, 
  EventSnapshot,
  EventStoreQuery,
  EventStoreResult 
} from './types/event-processing.types';

@Injectable()
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore {
  private readonly logger = new Logger(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore.name);
  private events = new Map<string, DomainEvent[]>(); // aggregateId -> events
  private snapshots = new Map<string, EventSnapshot>(); // aggregateId -> snapshot
  private globalSequence = 0;

  constructor() {
    ${options.storage !== "memory" ? "this.initializeStorage();" : ""}
  }

  ${
		options.storage !== "memory"
			? `
  private async initializeStorage(): Promise<void> {
    // Initialize ${options.storage} storage
    this.logger.log('Initializing ${options.storage} event storage...');
  }
  `
			: ""
	}

  public async saveEvents(
    aggregateId: string,
    events: DomainEvent[],
    expectedVersion?: number
  ): Promise<void> {
    try {
      // Check optimistic concurrency if expected version provided
      if (expectedVersion !== undefined) {
        const currentVersion = await this.getCurrentVersion(aggregateId);
        if (currentVersion !== expectedVersion) {
          throw new Error(
            \`Concurrency conflict: expected version \${expectedVersion}, current version \${currentVersion}\`
          );
        }
      }

      // Assign sequence numbers
      const eventsWithSequence = events.map(event => ({
        ...event,
        sequence: ++this.globalSequence,
        aggregateVersion: this.getNextAggregateVersion(aggregateId)
      }));

      // Save events
      if (!this.events.has(aggregateId)) {
        this.events.set(aggregateId, []);
      }

      this.events.get(aggregateId)!.push(...eventsWithSequence);

      ${options.storage !== "memory" ? "await this.persistEvents(aggregateId, eventsWithSequence);" : ""}

      this.logger.debug(
        \`Saved \${events.length} events for aggregate \${aggregateId}\`
      );

    } catch (error) {
      this.logger.error(\`Failed to save events for aggregate \${aggregateId}\`, error);
      throw error;
    }
  }

  public async getEvents(
    aggregateId: string,
    fromVersion?: number,
    toVersion?: number
  ): Promise<DomainEvent[]> {
    let events = this.events.get(aggregateId) || [];

    if (fromVersion !== undefined) {
      events = events.filter(e => e.aggregateVersion >= fromVersion);
    }

    if (toVersion !== undefined) {
      events = events.filter(e => e.aggregateVersion <= toVersion);
    }

    return events.sort((a, b) => a.aggregateVersion - b.aggregateVersion);
  }

  public async getEventStream(
    query: EventStoreQuery
  ): Promise<EventStream> {
    const allEvents: DomainEvent[] = [];

    // Collect events from all aggregates
    for (const [aggregateId, events] of this.events) {
      // Apply filters
      let filteredEvents = events;

      if (query.aggregateIds && !query.aggregateIds.includes(aggregateId)) {
        continue;
      }

      if (query.eventTypes) {
        filteredEvents = filteredEvents.filter(e => 
          query.eventTypes!.includes(e.type)
        );
      }

      if (query.fromSequence !== undefined) {
        filteredEvents = filteredEvents.filter(e => 
          e.sequence >= query.fromSequence!
        );
      }

      if (query.toSequence !== undefined) {
        filteredEvents = filteredEvents.filter(e => 
          e.sequence <= query.toSequence!
        );
      }

      if (query.fromTimestamp !== undefined) {
        filteredEvents = filteredEvents.filter(e => 
          e.timestamp >= query.fromTimestamp!
        );
      }

      if (query.toTimestamp !== undefined) {
        filteredEvents = filteredEvents.filter(e => 
          e.timestamp <= query.toTimestamp!
        );
      }

      allEvents.push(...filteredEvents);
    }

    // Sort by sequence
    allEvents.sort((a, b) => a.sequence - b.sequence);

    // Apply limit
    const limitedEvents = query.limit 
      ? allEvents.slice(0, query.limit)
      : allEvents;

    return {
      events: limitedEvents,
      hasMore: query.limit ? allEvents.length > query.limit : false,
      totalCount: allEvents.length
    };
  }

  ${options.eventSourcing.enabled ? this.getEventSourcingMethods(options) : ""}

  public async getCurrentVersion(aggregateId: string): Promise<number> {
    const events = this.events.get(aggregateId) || [];
    return events.length > 0 
      ? Math.max(...events.map(e => e.aggregateVersion))
      : 0;
  }

  public async deleteAggregate(aggregateId: string): Promise<void> {
    this.events.delete(aggregateId);
    this.snapshots.delete(aggregateId);

    ${options.storage !== "memory" ? "await this.deleteFromStorage(aggregateId);" : ""}

    this.logger.warn(\`Deleted all events for aggregate: \${aggregateId}\`);
  }

  public async getAggregateIds(eventType?: string): Promise<string[]> {
    if (!eventType) {
      return Array.from(this.events.keys());
    }

    const aggregateIds: string[] = [];
    
    for (const [aggregateId, events] of this.events) {
      if (events.some(e => e.type === eventType)) {
        aggregateIds.push(aggregateId);
      }
    }

    return aggregateIds;
  }

  public async getEventTypes(): Promise<string[]> {
    const eventTypes = new Set<string>();
    
    for (const events of this.events.values()) {
      for (const event of events) {
        eventTypes.add(event.type);
      }
    }

    return Array.from(eventTypes);
  }

  public async getStats(): Promise<{
    totalEvents: number;
    totalAggregates: number;
    totalSnapshots: number;
    eventsByType: Record<string, number>;
  }> {
    let totalEvents = 0;
    const eventsByType: Record<string, number> = {};

    for (const events of this.events.values()) {
      totalEvents += events.length;
      
      for (const event of events) {
        eventsByType[event.type] = (eventsByType[event.type] || 0) + 1;
      }
    }

    return {
      totalEvents,
      totalAggregates: this.events.size,
      totalSnapshots: this.snapshots.size,
      eventsByType
    };
  }

  private getNextAggregateVersion(aggregateId: string): number {
    const events = this.events.get(aggregateId) || [];
    return events.length + 1;
  }

  ${options.storage !== "memory" ? this.getStorageMethods(options) : ""}
}`;

		return {
			path: `src/events/${options.projectName}-event-store.service.ts`,
			content,
			type: "service",
		};
	}

	private generateEventProcessor(
		options: EventProcessingOptions,
	): GeneratedFile {
		const content = `/**
 * Event Processor
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus } from './${options.projectName}-event-bus.service';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore } from './${options.projectName}-event-store.service';
import { 
  DomainEvent, 
  EventProcessor as IEventProcessor,
  EventProcessingContext,
  EventProcessingResult,
  EventProcessingStrategy 
} from './types/event-processing.types';

@Injectable()
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessor implements IEventProcessor {
  private readonly logger = new Logger(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessor.name);
  private processors = new Map<string, EventProcessingStrategy>();
  private isProcessing = false;
  private processingQueue: DomainEvent[] = [];
  private processingStats = {
    processed: 0,
    failed: 0,
    averageTime: 0,
    lastProcessedAt: 0
  };

  constructor(
    private readonly eventBus: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus,
    private readonly eventStore: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore
  ) {
    this.initializeProcessor();
  }

  private initializeProcessor(): void {
    // Register for event processing
    this.eventBus.registerHandler('*', {
      handle: this.processEvent.bind(this)
    });

    this.logger.log('Event processor initialized');
  }

  public registerProcessor(
    eventType: string,
    strategy: EventProcessingStrategy
  ): void {
    this.processors.set(eventType, strategy);
    this.logger.debug(\`Registered processor for event type: \${eventType}\`);
  }

  public async processEvent<T = any>(
    event: DomainEvent<T>,
    context?: EventProcessingContext
  ): Promise<EventProcessingResult> {
    const startTime = Date.now();
    
    try {
      // Add to processing queue
      this.processingQueue.push(event);

      // Get processing strategy
      const strategy = this.processors.get(event.type) || this.getDefaultStrategy();

      // Create processing context
      const processingContext: EventProcessingContext = {
        isReplay: context?.isReplay || false,
        correlationId: event.metadata?.correlationId,
        causationId: event.metadata?.causationId,
        timestamp: Date.now(),
        ...context
      };

      // Process event with strategy
      const result = await strategy.process(event, processingContext);

      // Update statistics
      const processingTime = Date.now() - startTime;
      this.updateStats(processingTime, true);

      // Remove from queue
      this.removeFromQueue(event);

      this.logger.debug(
        \`Event processed: \${event.type} in \${processingTime}ms\`
      );

      return result;

    } catch (error) {
      const processingTime = Date.now() - startTime;
      this.updateStats(processingTime, false);
      this.removeFromQueue(event);

      this.logger.error(
        \`Failed to process event: \${event.type} - \${error.message}\`
      );

      ${
				options.retry.enabled
					? `
      // Apply retry logic
      return await this.handleEventProcessingRetry(event, error, context);
      `
					: `
      throw error;
      `
			}
    }
  }

  public async processBatch<T = any>(
    events: DomainEvent<T>[],
    context?: EventProcessingContext
  ): Promise<EventProcessingResult[]> {
    const results: EventProcessingResult[] = [];

    for (const event of events) {
      const result = await this.processEvent(event, context);
      results.push(result);
    }

    this.logger.debug(\`Batch processed: \${events.length} events\`);
    return results;
  }

  public async reprocessFailedEvents(
    fromTimestamp?: number,
    eventTypes?: string[]
  ): Promise<void> {
    // Get failed events from store
    const query = {
      fromTimestamp,
      eventTypes,
      // Add filter for failed events based on your implementation
    };

    const stream = await this.eventStore.getEventStream(query);
    
    for (const event of stream.events) {
      try {
        await this.processEvent(event, { isReplay: true });
      } catch (error) {
        this.logger.error(\`Failed to reprocess event: \${event.id}\`, error);
      }
    }

    this.logger.log(\`Reprocessed \${stream.events.length} events\`);
  }

  private getDefaultStrategy(): EventProcessingStrategy {
    return {
      process: async <T>(event: DomainEvent<T>, context: EventProcessingContext) => {
        // Default processing - just log the event
        this.logger.debug(\`Processing event with default strategy: \${event.type}\`);
        
        return {
          success: true,
          processingTime: 0,
          result: { processed: true }
        };
      }
    };
  }

  ${options.retry.enabled ? this.getEventProcessingRetryLogic(options) : ""}

  private updateStats(processingTime: number, success: boolean): void {
    if (success) {
      this.processingStats.processed++;
    } else {
      this.processingStats.failed++;
    }

    // Update average processing time
    const total = this.processingStats.processed + this.processingStats.failed;
    this.processingStats.averageTime = 
      (this.processingStats.averageTime * (total - 1) + processingTime) / total;

    this.processingStats.lastProcessedAt = Date.now();
  }

  private removeFromQueue(event: DomainEvent): void {
    const index = this.processingQueue.findIndex(e => e.id === event.id);
    if (index > -1) {
      this.processingQueue.splice(index, 1);
    }
  }

  public getProcessingStats() {
    return {
      ...this.processingStats,
      queueLength: this.processingQueue.length,
      isProcessing: this.isProcessing
    };
  }

  public getProcessingQueue(): DomainEvent[] {
    return [...this.processingQueue];
  }

  public async pauseProcessing(): Promise<void> {
    this.isProcessing = false;
    this.logger.log('Event processing paused');
  }

  public async resumeProcessing(): Promise<void> {
    this.isProcessing = true;
    this.logger.log('Event processing resumed');
  }

  public async clearProcessingQueue(): Promise<void> {
    this.processingQueue = [];
    this.logger.warn('Processing queue cleared');
  }
}`;

		return {
			path: `src/events/${options.projectName}-event-processor.service.ts`,
			content,
			type: "service",
		};
	}

	private generateEventProcessingModule(
		options: EventProcessingOptions,
	): GeneratedFile {
		const content = `/**
 * Event Processing Module
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus } from './${options.projectName}-event-bus.service';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore } from './${options.projectName}-event-store.service';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessor } from './${options.projectName}-event-processor.service';

// Pattern implementations
${options.patterns
	.map((pattern) => {
		const serviceName = this.getPatternServiceName(pattern);
		return `import { ${serviceName} } from './patterns/${pattern.replace(/-/g, "-")}.service';`;
	})
	.join("\n")}

// Feature implementations
${options.features
	.map((feature) => {
		const serviceName = this.getFeatureServiceName(feature);
		return `import { ${serviceName} } from './features/${feature.replace(/-/g, "-")}.service';`;
	})
	.join("\n")}

${options.retry.enabled ? `import { EventRetryHandler } from './retry/event-retry.handler';` : ""}
${options.validation.enabled ? `import { EventValidationService } from './validation/event-validation.service';` : ""}
${options.monitoring ? `import { EventMonitoringService } from './monitoring/event-monitoring.service';` : ""}

@Module({
  imports: [
    EventEmitterModule.forRoot({
      wildcard: true,
      delimiter: '.',
      maxListeners: 20,
      verboseMemoryLeak: false,
      ignoreErrors: false,
    }),
  ],
  providers: [
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus,
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore,
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessor,
    
    // Pattern implementations
    ${options.patterns.map((pattern) => this.getPatternServiceName(pattern)).join(",\n    ")},
    
    // Feature implementations
    ${options.features.map((feature) => this.getFeatureServiceName(feature)).join(",\n    ")},
    
    ${options.retry.enabled ? "EventRetryHandler," : ""}
    ${options.validation.enabled ? "EventValidationService," : ""}
    ${options.monitoring ? "EventMonitoringService," : ""}
  ],
  exports: [
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus,
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore,
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessor,
    
    // Pattern implementations
    ${options.patterns.map((pattern) => this.getPatternServiceName(pattern)).join(",\n    ")},
    
    // Feature implementations
    ${options.features.map((feature) => this.getFeatureServiceName(feature)).join(",\n    ")},
  ]
})
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventProcessingModule {}`;

		return {
			path: `src/events/${options.projectName}-event-processing.module.ts`,
			content,
			type: "module",
		};
	}

	private generatePatternImplementation(
		pattern: EventPattern,
		options: EventProcessingOptions,
	): GeneratedFile[] {
		const files: GeneratedFile[] = [];

		switch (pattern) {
			case "event-sourcing":
				files.push(this.generateEventSourcingPattern(options));
				break;
			case "cqrs":
				files.push(this.generateCQRSPattern(options));
				break;
			case "saga":
				files.push(this.generateSagaPattern(options));
				break;
			case "event-replay":
				files.push(this.generateEventReplayPattern(options));
				break;
			case "event-projection":
				files.push(this.generateEventProjectionPattern(options));
				break;
			case "event-handler":
				files.push(this.generateEventHandlerPattern(options));
				break;
			case "event-aggregation":
				files.push(this.generateEventAggregationPattern(options));
				break;
			case "event-filtering":
				files.push(this.generateEventFilteringPattern(options));
				break;
		}

		return files;
	}

	private generateEventSourcingPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		const content = `/**
 * Event Sourcing Pattern Implementation
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore } from '../${options.projectName}-event-store.service';
import { DomainEvent, AggregateRoot, EventSnapshot } from '../types/event-processing.types';

@Injectable()
export class EventSourcingService {
  private readonly logger = new Logger(EventSourcingService.name);

  constructor(
    private readonly eventStore: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventStore
  ) {}

  public async saveAggregate<T extends AggregateRoot>(
    aggregate: T,
    expectedVersion?: number
  ): Promise<void> {
    const uncommittedEvents = aggregate.getUncommittedEvents();
    
    if (uncommittedEvents.length === 0) {
      return;
    }

    await this.eventStore.saveEvents(
      aggregate.getId(),
      uncommittedEvents,
      expectedVersion
    );

    aggregate.markEventsAsCommitted();
    
    this.logger.debug(
      \`Saved \${uncommittedEvents.length} events for aggregate \${aggregate.getId()}\`
    );
  }

  public async loadAggregate<T extends AggregateRoot>(
    aggregateId: string,
    aggregateType: new () => T,
    fromSnapshot?: boolean
  ): Promise<T> {
    const aggregate = new aggregateType();
    
    let fromVersion = 0;
    
    // Load from snapshot if enabled and available
    if (fromSnapshot && options.eventSourcing.enabled) {
      const snapshot = await this.eventStore.getSnapshot(aggregateId);
      if (snapshot) {
        aggregate.loadFromSnapshot(snapshot);
        fromVersion = snapshot.version;
      }
    }

    // Load events after snapshot
    const events = await this.eventStore.getEvents(aggregateId, fromVersion + 1);
    
    for (const event of events) {
      aggregate.applyEvent(event, false);
    }

    aggregate.markEventsAsCommitted();
    
    this.logger.debug(
      \`Loaded aggregate \${aggregateId} with \${events.length} events\`
    );
    
    return aggregate;
  }

  public async createSnapshot<T extends AggregateRoot>(
    aggregate: T
  ): Promise<void> {
    if (!options.eventSourcing.enabled) {
      return;
    }

    const snapshot: EventSnapshot = {
      aggregateId: aggregate.getId(),
      version: aggregate.getVersion(),
      data: aggregate.getSnapshotData(),
      timestamp: Date.now(),
      type: aggregate.constructor.name
    };

    await this.eventStore.saveSnapshot(snapshot);
    
    this.logger.debug(\`Created snapshot for aggregate \${aggregate.getId()}\`);
  }

  public async shouldCreateSnapshot<T extends AggregateRoot>(
    aggregate: T
  ): Promise<boolean> {
    if (!options.eventSourcing.enabled) {
      return false;
    }

    const eventsSinceSnapshot = aggregate.getVersion() % options.eventSourcing.snapshotInterval;
    return eventsSinceSnapshot === 0;
  }

  public async rehydrateAggregate<T extends AggregateRoot>(
    aggregateId: string,
    aggregateType: new () => T,
    toVersion?: number
  ): Promise<T> {
    const aggregate = new aggregateType();
    const events = await this.eventStore.getEvents(aggregateId, 1, toVersion);
    
    for (const event of events) {
      aggregate.applyEvent(event, false);
    }

    aggregate.markEventsAsCommitted();
    
    return aggregate;
  }
}

// Base Aggregate Root
export abstract class BaseAggregateRoot implements AggregateRoot {
  protected id: string;
  protected version: number = 0;
  private uncommittedEvents: DomainEvent[] = [];

  constructor(id?: string) {
    this.id = id || this.generateId();
  }

  public getId(): string {
    return this.id;
  }

  public getVersion(): number {
    return this.version;
  }

  public getUncommittedEvents(): DomainEvent[] {
    return [...this.uncommittedEvents];
  }

  public markEventsAsCommitted(): void {
    this.uncommittedEvents = [];
  }

  protected applyAndStoreEvent<T = any>(event: DomainEvent<T>): void {
    this.applyEvent(event, true);
    this.uncommittedEvents.push(event);
  }

  public applyEvent<T = any>(event: DomainEvent<T>, isNew: boolean): void {
    // Apply the event to update aggregate state
    this.applyEventToState(event);
    
    if (isNew) {
      this.version++;
    }
  }

  protected abstract applyEventToState<T = any>(event: DomainEvent<T>): void;

  public abstract getSnapshotData(): any;
  public abstract loadFromSnapshot(snapshot: EventSnapshot): void;

  protected generateId(): string {
    return \`agg_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  protected createEvent<T = any>(
    type: string,
    data: T,
    metadata?: Record<string, any>
  ): DomainEvent<T> {
    return {
      id: this.generateEventId(),
      type,
      aggregateId: this.id,
      aggregateVersion: this.version + 1,
      data,
      timestamp: Date.now(),
      sequence: 0, // Will be set by event store
      metadata: metadata || {}
    };
  }

  private generateEventId(): string {
    return \`evt_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }
}`;

		return {
			path: `src/events/patterns/event-sourcing.service.ts`,
			content,
			type: "service",
		};
	}

	private generateCQRSPattern(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * CQRS Pattern Implementation
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus } from '../${options.projectName}-event-bus.service';
import { 
  Command, 
  Query, 
  CommandHandler, 
  QueryHandler,
  CommandResult,
  QueryResult 
} from '../types/event-processing.types';

@Injectable()
export class CQRSService {
  private readonly logger = new Logger(CQRSService.name);
  private commandHandlers = new Map<string, CommandHandler>();
  private queryHandlers = new Map<string, QueryHandler>();

  constructor(
    private readonly eventBus: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus
  ) {}

  // Command handling
  public registerCommandHandler(
    commandType: string,
    handler: CommandHandler
  ): void {
    this.commandHandlers.set(commandType, handler);
    this.logger.debug(\`Registered command handler for: \${commandType}\`);
  }

  public async executeCommand<T = any>(command: Command<T>): Promise<CommandResult> {
    try {
      const handler = this.commandHandlers.get(command.type);
      
      if (!handler) {
        throw new Error(\`No command handler registered for: \${command.type}\`);
      }

      // Validate command
      if (handler.validate) {
        const validation = await handler.validate(command);
        if (!validation.isValid) {
          return {
            success: false,
            error: \`Command validation failed: \${validation.errors.join(', ')}\`,
            commandId: command.id
          };
        }
      }

      // Execute command
      const result = await handler.handle(command);

      // Publish events if any
      if (result.events && result.events.length > 0) {
        await this.eventBus.publishBatch(result.events);
      }

      this.logger.debug(\`Command executed: \${command.type}\`);
      
      return {
        success: true,
        result: result.data,
        commandId: command.id,
        events: result.events
      };

    } catch (error) {
      this.logger.error(\`Command execution failed: \${command.type}\`, error);
      
      return {
        success: false,
        error: error.message,
        commandId: command.id
      };
    }
  }

  // Query handling
  public registerQueryHandler(
    queryType: string,
    handler: QueryHandler
  ): void {
    this.queryHandlers.set(queryType, handler);
    this.logger.debug(\`Registered query handler for: \${queryType}\`);
  }

  public async executeQuery<T = any, R = any>(query: Query<T>): Promise<QueryResult<R>> {
    try {
      const handler = this.queryHandlers.get(query.type);
      
      if (!handler) {
        throw new Error(\`No query handler registered for: \${query.type}\`);
      }

      // Execute query
      const result = await handler.handle(query);

      this.logger.debug(\`Query executed: \${query.type}\`);
      
      return {
        success: true,
        data: result,
        queryId: query.id
      };

    } catch (error) {
      this.logger.error(\`Query execution failed: \${query.type}\`, error);
      
      return {
        success: false,
        error: error.message,
        queryId: query.id
      };
    }
  }

  public async executeBatchCommands<T = any>(
    commands: Command<T>[]
  ): Promise<CommandResult[]> {
    const results: CommandResult[] = [];
    
    for (const command of commands) {
      const result = await this.executeCommand(command);
      results.push(result);
      
      // Stop on first failure if desired
      if (!result.success) {
        this.logger.warn(\`Batch command execution stopped at: \${command.type}\`);
        break;
      }
    }
    
    return results;
  }

  public getRegisteredCommands(): string[] {
    return Array.from(this.commandHandlers.keys());
  }

  public getRegisteredQueries(): string[] {
    return Array.from(this.queryHandlers.keys());
  }
}

// Command and Query builders
export class CommandBuilder<T = any> {
  private command: Partial<Command<T>> = {};

  static create<T = any>(): CommandBuilder<T> {
    return new CommandBuilder<T>();
  }

  type(type: string): CommandBuilder<T> {
    this.command.type = type;
    return this;
  }

  data(data: T): CommandBuilder<T> {
    this.command.data = data;
    return this;
  }

  metadata(metadata: Record<string, any>): CommandBuilder<T> {
    this.command.metadata = metadata;
    return this;
  }

  correlationId(correlationId: string): CommandBuilder<T> {
    if (!this.command.metadata) this.command.metadata = {};
    this.command.metadata.correlationId = correlationId;
    return this;
  }

  build(): Command<T> {
    if (!this.command.type || this.command.data === undefined) {
      throw new Error('Command must have type and data');
    }

    return {
      id: this.generateId(),
      type: this.command.type,
      data: this.command.data,
      timestamp: Date.now(),
      metadata: this.command.metadata || {}
    };
  }

  private generateId(): string {
    return \`cmd_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }
}

export class QueryBuilder<T = any> {
  private query: Partial<Query<T>> = {};

  static create<T = any>(): QueryBuilder<T> {
    return new QueryBuilder<T>();
  }

  type(type: string): QueryBuilder<T> {
    this.query.type = type;
    return this;
  }

  parameters(parameters: T): QueryBuilder<T> {
    this.query.parameters = parameters;
    return this;
  }

  metadata(metadata: Record<string, any>): QueryBuilder<T> {
    this.query.metadata = metadata;
    return this;
  }

  build(): Query<T> {
    if (!this.query.type) {
      throw new Error('Query must have type');
    }

    return {
      id: this.generateId(),
      type: this.query.type,
      parameters: this.query.parameters,
      timestamp: Date.now(),
      metadata: this.query.metadata || {}
    };
  }

  private generateId(): string {
    return \`qry_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }
}`;

		return {
			path: `src/events/patterns/cqrs.service.ts`,
			content,
			type: "service",
		};
	}

	private generateSagaPattern(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * Saga Pattern Implementation
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus } from '../${options.projectName}-event-bus.service';
import { 
  DomainEvent, 
  SagaDefinition,
  SagaInstance,
  SagaStep,
  SagaStatus,
  CompensationAction 
} from '../types/event-processing.types';

@Injectable()
export class SagaService {
  private readonly logger = new Logger(SagaService.name);
  private sagaDefinitions = new Map<string, SagaDefinition>();
  private sagaInstances = new Map<string, SagaInstance>();

  constructor(
    private readonly eventBus: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}EventBus
  ) {}

  public registerSaga(definition: SagaDefinition): void {
    this.sagaDefinitions.set(definition.name, definition);
    
    // Register event handlers for saga triggers
    for (const triggerEvent of definition.triggerEvents) {
      this.eventBus.registerHandler(triggerEvent, {
        handle: (event) => this.handleSagaTrigger(definition.name, event)
      });
    }

    this.logger.debug(\`Registered saga: \${definition.name}\`);
  }

  public async startSaga(
    sagaName: string,
    triggerEvent: DomainEvent,
    context?: Record<string, any>
  ): Promise<string> {
    const definition = this.sagaDefinitions.get(sagaName);
    if (!definition) {
      throw new Error(\`Saga definition not found: \${sagaName}\`);
    }

    const sagaId = this.generateSagaId();
    const sagaInstance: SagaInstance = {
      id: sagaId,
      sagaName,
      status: SagaStatus.Started,
      currentStep: 0,
      context: context || {},
      startedAt: Date.now(),
      steps: [],
      compensationActions: []
    };

    this.sagaInstances.set(sagaId, sagaInstance);

    // Start executing saga steps
    await this.executeSagaStep(sagaInstance, triggerEvent);

    this.logger.debug(\`Started saga: \${sagaName} with ID: \${sagaId}\`);
    return sagaId;
  }

  private async handleSagaTrigger(
    sagaName: string,
    event: DomainEvent
  ): Promise<void> {
    try {
      await this.startSaga(sagaName, event);
    } catch (error) {
      this.logger.error(\`Failed to start saga \${sagaName} from trigger event\`, error);
    }
  }

  private async executeSagaStep(
    sagaInstance: SagaInstance,
    triggerEvent?: DomainEvent
  ): Promise<void> {
    const definition = this.sagaDefinitions.get(sagaInstance.sagaName)!;
    const step = definition.steps[sagaInstance.currentStep];

    if (!step) {
      // Saga completed successfully
      await this.completeSaga(sagaInstance);
      return;
    }

    try {
      sagaInstance.status = SagaStatus.InProgress;

      // Execute step
      const stepResult = await step.execute(sagaInstance.context, triggerEvent);

      // Record step execution
      sagaInstance.steps.push({
        stepIndex: sagaInstance.currentStep,
        stepName: step.name,
        executedAt: Date.now(),
        result: stepResult,
        status: 'completed'
      });

      // Add compensation action if provided
      if (step.compensationAction) {
        sagaInstance.compensationActions.push({
          stepIndex: sagaInstance.currentStep,
          action: step.compensationAction,
          context: { ...sagaInstance.context, stepResult }
        });
      }

      // Update context with step result
      if (stepResult) {
        sagaInstance.context = { ...sagaInstance.context, ...stepResult };
      }

      // Move to next step
      sagaInstance.currentStep++;
      
      // Continue with next step
      await this.executeSagaStep(sagaInstance);

    } catch (error) {
      this.logger.error(
        \`Saga step failed: \${sagaInstance.sagaName} step \${sagaInstance.currentStep}\`,
        error
      );

      // Record failed step
      sagaInstance.steps.push({
        stepIndex: sagaInstance.currentStep,
        stepName: step.name,
        executedAt: Date.now(),
        error: error.message,
        status: 'failed'
      });

      // Start compensation
      await this.compensateSaga(sagaInstance, error);
    }
  }

  private async compensateSaga(
    sagaInstance: SagaInstance,
    error: Error
  ): Promise<void> {
    sagaInstance.status = SagaStatus.Compensating;
    sagaInstance.failureReason = error.message;
    sagaInstance.failedAt = Date.now();

    // Execute compensation actions in reverse order
    const compensationActions = [...sagaInstance.compensationActions].reverse();

    for (const compensation of compensationActions) {
      try {
        await compensation.action.compensate(compensation.context);
        
        this.logger.debug(
          \`Compensation executed for step \${compensation.stepIndex} in saga \${sagaInstance.id}\`
        );
      } catch (compensationError) {
        this.logger.error(
          \`Compensation failed for step \${compensation.stepIndex} in saga \${sagaInstance.id}\`,
          compensationError
        );
        // Continue with other compensations even if one fails
      }
    }

    sagaInstance.status = SagaStatus.Compensated;
    sagaInstance.completedAt = Date.now();

    this.logger.warn(\`Saga compensated: \${sagaInstance.sagaName} (\${sagaInstance.id})\`);
  }

  private async completeSaga(sagaInstance: SagaInstance): Promise<void> {
    sagaInstance.status = SagaStatus.Completed;
    sagaInstance.completedAt = Date.now();

    this.logger.debug(\`Saga completed: \${sagaInstance.sagaName} (\${sagaInstance.id})\`);

    // Publish saga completion event
    await this.eventBus.publish({
      id: this.generateEventId(),
      type: 'SagaCompleted',
      aggregateId: sagaInstance.id,
      aggregateVersion: 1,
      data: {
        sagaName: sagaInstance.sagaName,
        sagaId: sagaInstance.id,
        duration: sagaInstance.completedAt! - sagaInstance.startedAt,
        stepsExecuted: sagaInstance.steps.length
      },
      timestamp: Date.now(),
      sequence: 0,
      metadata: {}
    });
  }

  public getSagaInstance(sagaId: string): SagaInstance | undefined {
    return this.sagaInstances.get(sagaId);
  }

  public getSagasByStatus(status: SagaStatus): SagaInstance[] {
    return Array.from(this.sagaInstances.values()).filter(
      saga => saga.status === status
    );
  }

  public async retrySaga(sagaId: string): Promise<void> {
    const sagaInstance = this.sagaInstances.get(sagaId);
    if (!sagaInstance) {
      throw new Error(\`Saga instance not found: \${sagaId}\`);
    }

    if (sagaInstance.status !== SagaStatus.Failed) {
      throw new Error(\`Cannot retry saga in status: \${sagaInstance.status}\`);
    }

    // Reset to last successful step
    const lastSuccessfulStep = sagaInstance.steps
      .filter(step => step.status === 'completed')
      .pop();

    sagaInstance.currentStep = lastSuccessfulStep ? lastSuccessfulStep.stepIndex + 1 : 0;
    sagaInstance.status = SagaStatus.Started;

    await this.executeSagaStep(sagaInstance);

    this.logger.debug(\`Retrying saga: \${sagaId}\`);
  }

  private generateSagaId(): string {
    return \`saga_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  private generateEventId(): string {
    return \`evt_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  public getSagaStats(): {
    totalSagas: number;
    completedSagas: number;
    failedSagas: number;
    inProgressSagas: number;
    averageDuration: number;
  } {
    const sagas = Array.from(this.sagaInstances.values());
    const completed = sagas.filter(s => s.status === SagaStatus.Completed);
    const failed = sagas.filter(s => s.status === SagaStatus.Failed || s.status === SagaStatus.Compensated);
    const inProgress = sagas.filter(s => s.status === SagaStatus.InProgress || s.status === SagaStatus.Started);

    const averageDuration = completed.length > 0
      ? completed.reduce((sum, saga) => sum + (saga.completedAt! - saga.startedAt), 0) / completed.length
      : 0;

    return {
      totalSagas: sagas.length,
      completedSagas: completed.length,
      failedSagas: failed.length,
      inProgressSagas: inProgress.length,
      averageDuration
    };
  }
}

// Saga builder utility
export class SagaBuilder {
  private definition: Partial<SagaDefinition> = {
    steps: [],
    triggerEvents: []
  };

  static create(): SagaBuilder {
    return new SagaBuilder();
  }

  name(name: string): SagaBuilder {
    this.definition.name = name;
    return this;
  }

  triggerOn(eventType: string): SagaBuilder {
    this.definition.triggerEvents!.push(eventType);
    return this;
  }

  step(step: SagaStep): SagaBuilder {
    this.definition.steps!.push(step);
    return this;
  }

  build(): SagaDefinition {
    if (!this.definition.name || !this.definition.steps!.length) {
      throw new Error('Saga must have name and at least one step');
    }

    return this.definition as SagaDefinition;
  }
}`;

		return {
			path: `src/events/patterns/saga.service.ts`,
			content,
			type: "service",
		};
	}

	// Continue with additional pattern implementations...
	private generateEventReplayPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		return {
			path: `src/events/patterns/event-replay.service.ts`,
			content: "// Event Replay pattern implementation",
			type: "service",
		};
	}

	private generateEventProjectionPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		return {
			path: `src/events/patterns/event-projection.service.ts`,
			content: "// Event Projection pattern implementation",
			type: "service",
		};
	}

	private generateEventHandlerPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		return {
			path: `src/events/patterns/event-handler.service.ts`,
			content: "// Event Handler pattern implementation",
			type: "service",
		};
	}

	private generateEventAggregationPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		return {
			path: `src/events/patterns/event-aggregation.service.ts`,
			content: "// Event Aggregation pattern implementation",
			type: "service",
		};
	}

	private generateEventFilteringPattern(
		options: EventProcessingOptions,
	): GeneratedFile {
		return {
			path: `src/events/patterns/event-filtering.service.ts`,
			content: "// Event Filtering pattern implementation",
			type: "service",
		};
	}

	private generateFeatureImplementation(
		feature: EventProcessingFeature,
		options: EventProcessingOptions,
	): GeneratedFile[] {
		// Feature implementations would go here
		return [
			{
				path: `src/events/features/${feature.replace(/-/g, "-")}.service.ts`,
				content: `// ${feature} feature implementation`,
				type: "service",
			},
		];
	}

	private generateEventSourcingImplementation(
		options: EventProcessingOptions,
	): GeneratedFile[] {
		// Event sourcing specific implementations
		return [
			{
				path: `src/events/event-sourcing/aggregate-repository.service.ts`,
				content: "// Aggregate repository implementation",
				type: "service",
			},
		];
	}

	private generateRetryHandler(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * Event Retry Handler
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { DomainEvent, EventProcessingResult } from '../types/event-processing.types';

@Injectable()
export class EventRetryHandler {
  private readonly logger = new Logger(EventRetryHandler.name);
  private retryQueue = new Map<string, RetryItem>();

  public async handleRetry<T = any>(
    event: DomainEvent<T>,
    error: Error,
    attempt: number
  ): Promise<EventProcessingResult> {
    const retryKey = this.getRetryKey(event);
    
    if (attempt >= ${options.retry.maxAttempts}) {
      this.logger.error(\`Max retry attempts reached for event \${event.id}\`);
      return {
        success: false,
        error: error.message,
        finalAttempt: true
      };
    }

    const delay = this.calculateDelay(attempt);
    
    setTimeout(async () => {
      try {
        // Retry logic would be implemented here
        this.logger.debug(\`Retrying event \${event.id}, attempt \${attempt + 1}\`);
      } catch (retryError) {
        this.handleRetry(event, retryError, attempt + 1);
      }
    }, delay);

    return {
      success: false,
      error: error.message,
      retryAttempt: attempt,
      retryDelay: delay
    };
  }

  private calculateDelay(attempt: number): number {
    switch ('${options.retry.backoffStrategy}') {
      case 'exponential':
        return ${options.retry.baseDelay} * Math.pow(2, attempt);
      case 'linear':
        return ${options.retry.baseDelay} * (attempt + 1);
      case 'fixed':
      default:
        return ${options.retry.baseDelay};
    }
  }

  private getRetryKey(event: DomainEvent): string {
    return \`\${event.aggregateId}:\${event.id}\`;
  }
}

interface RetryItem {
  event: DomainEvent;
  attempts: number;
  lastAttempt: number;
  nextAttempt: number;
}`;

		return {
			path: `src/events/retry/event-retry.handler.ts`,
			content,
			type: "service",
		};
	}

	private generateValidationImplementation(
		options: EventProcessingOptions,
	): GeneratedFile[] {
		return [
			{
				path: `src/events/validation/event-validation.service.ts`,
				content: "// Event validation implementation",
				type: "service",
			},
		];
	}

	private generateMonitoringImplementation(
		options: EventProcessingOptions,
	): GeneratedFile[] {
		return [
			{
				path: `src/events/monitoring/event-monitoring.service.ts`,
				content: "// Event monitoring implementation",
				type: "service",
			},
		];
	}

	private generateTypes(options: EventProcessingOptions): GeneratedFile {
		const content = `/**
 * Event Processing Types
 * Generated by Xaheen CLI for ${options.projectName}
 */

// Core event types
export interface DomainEvent<T = any> {
  id: string;
  type: string;
  aggregateId: string;
  aggregateVersion: number;
  data: T;
  timestamp: number;
  sequence: number;
  metadata: EventMetadata;
}

export interface EventMetadata {
  correlationId?: string;
  causationId?: string;
  publisherId?: string;
  publishedAt?: number;
  [key: string]: any;
}

export interface EventHandler<T = any> {
  handle(event: DomainEvent<T>, context?: EventProcessingContext): Promise<any>;
}

export interface EventProcessingContext {
  isReplay?: boolean;
  correlationId?: string;
  causationId?: string;
  timestamp?: number;
  [key: string]: any;
}

export interface EventProcessingResult {
  success: boolean;
  result?: any;
  error?: string;
  processingTime?: number;
  handlerName?: string;
  retryAttempt?: number;
  retryDelay?: number;
  finalAttempt?: boolean;
}

export interface EventProcessor {
  processEvent<T>(event: DomainEvent<T>, context?: EventProcessingContext): Promise<EventProcessingResult>;
}

export interface EventProcessingStrategy {
  process<T>(event: DomainEvent<T>, context: EventProcessingContext): Promise<EventProcessingResult>;
}

// Event Store types
export interface EventStream {
  events: DomainEvent[];
  hasMore: boolean;
  totalCount: number;
}

export interface EventSnapshot {
  aggregateId: string;
  version: number;
  data: any;
  timestamp: number;
  type: string;
}

export interface EventStoreQuery {
  aggregateIds?: string[];
  eventTypes?: string[];
  fromSequence?: number;
  toSequence?: number;
  fromTimestamp?: number;
  toTimestamp?: number;
  limit?: number;
}

export interface EventStoreResult {
  events: DomainEvent[];
  totalCount: number;
  hasMore: boolean;
}

// CQRS types
export interface Command<T = any> {
  id: string;
  type: string;
  data: T;
  timestamp: number;
  metadata: Record<string, any>;
}

export interface Query<T = any> {
  id: string;
  type: string;
  parameters?: T;
  timestamp: number;
  metadata: Record<string, any>;
}

export interface CommandHandler<T = any> {
  handle(command: Command<T>): Promise<{ data?: any; events?: DomainEvent[] }>;
  validate?(command: Command<T>): Promise<{ isValid: boolean; errors: string[] }>;
}

export interface QueryHandler<T = any, R = any> {
  handle(query: Query<T>): Promise<R>;
}

export interface CommandResult {
  success: boolean;
  result?: any;
  error?: string;
  commandId: string;
  events?: DomainEvent[];
}

export interface QueryResult<T = any> {
  success: boolean;
  data?: T;
  error?: string;
  queryId: string;
}

// Saga types
export interface SagaDefinition {
  name: string;
  steps: SagaStep[];
  triggerEvents: string[];
}

export interface SagaStep {
  name: string;
  execute(context: Record<string, any>, triggerEvent?: DomainEvent): Promise<any>;
  compensationAction?: CompensationAction;
}

export interface CompensationAction {
  compensate(context: Record<string, any>): Promise<void>;
}

export interface SagaInstance {
  id: string;
  sagaName: string;
  status: SagaStatus;
  currentStep: number;
  context: Record<string, any>;
  startedAt: number;
  completedAt?: number;
  failedAt?: number;
  failureReason?: string;
  steps: SagaStepExecution[];
  compensationActions: SagaCompensationAction[];
}

export enum SagaStatus {
  Started = 'started',
  InProgress = 'in_progress',
  Completed = 'completed',
  Failed = 'failed',
  Compensating = 'compensating',
  Compensated = 'compensated'
}

export interface SagaStepExecution {
  stepIndex: number;
  stepName: string;
  executedAt: number;
  result?: any;
  error?: string;
  status: 'completed' | 'failed';
}

export interface SagaCompensationAction {
  stepIndex: number;
  action: CompensationAction;
  context: Record<string, any>;
}

// Event Sourcing types
export interface AggregateRoot {
  getId(): string;
  getVersion(): number;
  getUncommittedEvents(): DomainEvent[];
  markEventsAsCommitted(): void;
  applyEvent<T>(event: DomainEvent<T>, isNew: boolean): void;
  getSnapshotData(): any;
  loadFromSnapshot(snapshot: EventSnapshot): void;
}

export interface EventFilter {
  shouldProcess(event: DomainEvent): boolean;
}

// Configuration types
export type EventPattern = ${options.patterns.map((p) => `'${p}'`).join(" | ")};
export type EventProcessingFeature = ${options.features.map((f) => `'${f}'`).join(" | ")};

export interface EventProcessingConfiguration {
  patterns: EventPattern[];
  storage: '${options.storage}';
  features: EventProcessingFeature[];
  retry: {
    enabled: boolean;
    maxAttempts: number;
    backoffStrategy: 'exponential' | 'linear' | 'fixed';
    baseDelay: number;
  };
  eventSourcing: {
    enabled: boolean;
    snapshotInterval: number;
    replayFromSnapshot: boolean;
  };
  monitoring: boolean;
  validation: {
    enabled: boolean;
    schemaRegistry: boolean;
  };
}`;

		return {
			path: `src/events/types/event-processing.types.ts`,
			content,
			type: "types",
		};
	}

	private generateConfiguration(
		options: EventProcessingOptions,
	): GeneratedFile {
		const content = `/**
 * Event Processing Configuration
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { EventProcessingConfiguration } from './types/event-processing.types';

export const eventProcessingConfig: EventProcessingConfiguration = {
  patterns: [${options.patterns.map((p) => `'${p}'`).join(", ")}],
  storage: '${options.storage}',
  features: [${options.features.map((f) => `'${f}'`).join(", ")}],
  retry: {
    enabled: ${options.retry.enabled},
    maxAttempts: ${options.retry.maxAttempts},
    backoffStrategy: '${options.retry.backoffStrategy}',
    baseDelay: ${options.retry.baseDelay}
  },
  eventSourcing: {
    enabled: ${options.eventSourcing.enabled},
    snapshotInterval: ${options.eventSourcing.snapshotInterval},
    replayFromSnapshot: ${options.eventSourcing.replayFromSnapshot}
  },
  monitoring: ${options.monitoring},
  validation: {
    enabled: ${options.validation.enabled},
    schemaRegistry: ${options.validation.schemaRegistry}
  }
};

export const eventTypes = {
  ${options.features
		.map((feature) => {
			const eventName = feature.replace(/-/g, "_").toUpperCase();
			return `${eventName}: '${feature}'`;
		})
		.join(",\n  ")}
};

export const storageConfig = {
  memory: {
    maxEvents: 10000,
    maxSnapshots: 1000
  },
  redis: {
    host: process.env.REDIS_HOST || 'localhost',
    port: parseInt(process.env.REDIS_PORT || '6379'),
    password: process.env.REDIS_PASSWORD,
    keyPrefix: 'events:'
  },
  mongodb: {
    uri: process.env.MONGODB_URI || 'mongodb://localhost:27017/events',
    options: {
      useNewUrlParser: true,
      useUnifiedTopology: true
    }
  },
  postgresql: {
    host: process.env.POSTGRES_HOST || 'localhost',
    port: parseInt(process.env.POSTGRES_PORT || '5432'),
    database: process.env.POSTGRES_DB || 'events',
    username: process.env.POSTGRES_USER || 'postgres',
    password: process.env.POSTGRES_PASSWORD
  },
  eventstore: {
    connectionString: process.env.EVENTSTORE_CONNECTION_STRING || 'esdb://localhost:2113?tls=false'
  }
};`;

		return {
			path: `src/events/config/event-processing.config.ts`,
			content,
			type: "config",
		};
	}

	private generateTestFiles(options: EventProcessingOptions): GeneratedFile[] {
		return [
			{
				path: `src/events/__tests__/${options.projectName}-event-bus.service.spec.ts`,
				content: "// Event bus service tests",
				type: "test",
			},
			{
				path: `src/events/__tests__/${options.projectName}-event-store.service.spec.ts`,
				content: "// Event store service tests",
				type: "test",
			},
		];
	}

	private generateClientUtils(
		options: EventProcessingOptions,
	): GeneratedFile[] {
		return [
			{
				path: `src/events/utils/event-processing-client.ts`,
				content: "// Event processing client utilities",
				type: "utility",
			},
		];
	}

	// Helper methods
	private getPatternServiceName(pattern: EventPattern): string {
		return (
			pattern
				.split("-")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join("") + "Service"
		);
	}

	private getFeatureServiceName(feature: EventProcessingFeature): string {
		return (
			feature
				.split("-")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join("") + "Service"
		);
	}

	private getRetryLogic(options: EventProcessingOptions): string {
		return `
  private async retryHandler<T = any>(
    handler: EventHandler<T>,
    event: DomainEvent<T>,
    error: Error,
    isReplay: boolean,
    attempt = 1
  ): Promise<EventProcessingResult> {
    if (attempt > ${options.retry.maxAttempts}) {
      return {
        success: false,
        handlerName: handler.constructor.name,
        error: error.message,
        finalAttempt: true
      };
    }

    const delay = this.calculateRetryDelay(attempt);
    
    await new Promise(resolve => setTimeout(resolve, delay));

    try {
      const result = await handler.handle(event, { isReplay });
      
      return {
        success: true,
        handlerName: handler.constructor.name,
        processingTime: Date.now() - event.timestamp,
        result,
        retryAttempt: attempt
      };
    } catch (retryError) {
      return await this.retryHandler(handler, event, retryError, isReplay, attempt + 1);
    }
  }

  private calculateRetryDelay(attempt: number): number {
    switch ('${options.retry.backoffStrategy}') {
      case 'exponential':
        return ${options.retry.baseDelay} * Math.pow(2, attempt - 1);
      case 'linear':
        return ${options.retry.baseDelay} * attempt;
      case 'fixed':
      default:
        return ${options.retry.baseDelay};
    }
  }`;
	}

	private getEventProcessingRetryLogic(
		options: EventProcessingOptions,
	): string {
		return `
  private async handleEventProcessingRetry<T = any>(
    event: DomainEvent<T>,
    error: Error,
    context?: EventProcessingContext,
    attempt = 1
  ): Promise<EventProcessingResult> {
    if (attempt > ${options.retry.maxAttempts}) {
      return {
        success: false,
        error: error.message,
        finalAttempt: true
      };
    }

    const delay = this.calculateRetryDelay(attempt);
    
    setTimeout(async () => {
      try {
        await this.processEvent(event, { ...context, retryAttempt: attempt });
      } catch (retryError) {
        await this.handleEventProcessingRetry(event, retryError, context, attempt + 1);
      }
    }, delay);

    return {
      success: false,
      error: error.message,
      retryAttempt: attempt,
      retryDelay: delay
    };
  }

  private calculateRetryDelay(attempt: number): number {
    switch ('${options.retry.backoffStrategy}') {
      case 'exponential':
        return ${options.retry.baseDelay} * Math.pow(2, attempt - 1);
      case 'linear':
        return ${options.retry.baseDelay} * attempt;
      case 'fixed':
      default:
        return ${options.retry.baseDelay};
    }
  }`;
	}

	private getEventSourcingMethods(options: EventProcessingOptions): string {
		return `
  public async saveSnapshot(snapshot: EventSnapshot): Promise<void> {
    this.snapshots.set(snapshot.aggregateId, snapshot);
    ${options.storage !== "memory" ? "await this.persistSnapshot(snapshot);" : ""}
    
    this.logger.debug(\`Snapshot saved for aggregate: \${snapshot.aggregateId}\`);
  }

  public async getSnapshot(aggregateId: string): Promise<EventSnapshot | undefined> {
    return this.snapshots.get(aggregateId);
  }

  public async deleteSnapshot(aggregateId: string): Promise<void> {
    this.snapshots.delete(aggregateId);
    ${options.storage !== "memory" ? "await this.deleteSnapshotFromStorage(aggregateId);" : ""}
  }`;
	}

	private getStorageMethods(options: EventProcessingOptions): string {
		return `
  private async persistEvents(aggregateId: string, events: DomainEvent[]): Promise<void> {
    // Implement ${options.storage} persistence
    // This would be specific to the chosen storage provider
  }

  private async persistSnapshot(snapshot: EventSnapshot): Promise<void> {
    // Implement ${options.storage} snapshot persistence
  }

  private async deleteFromStorage(aggregateId: string): Promise<void> {
    // Implement ${options.storage} deletion
  }

  private async deleteSnapshotFromStorage(aggregateId: string): Promise<void> {
    // Implement ${options.storage} snapshot deletion
  }`;
	}
}
