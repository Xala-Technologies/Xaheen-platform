import { BaseGenerator } from "../base.generator";
import { GeneratedFile } from "../../types/generator.types";

export interface SSEOptions {
	projectName: string;
	framework: "nestjs" | "express" | "fastify" | "hono";
	features: SSEFeature[];
	authentication: "none" | "jwt" | "api-key" | "session";
	cors: boolean;
	rateLimit: {
		enabled: boolean;
		requests: number;
		window: string;
	};
	heartbeat: {
		enabled: boolean;
		interval: number;
	};
	compression: boolean;
	monitoring: boolean;
	cluster: boolean;
}

export type SSEFeature =
	| "live-dashboard"
	| "progress-tracking"
	| "notifications"
	| "metrics-stream"
	| "log-stream"
	| "stock-ticker"
	| "game-updates"
	| "system-status";

export class SSEGenerator extends BaseGenerator {
	async generate(options: SSEOptions): Promise<GeneratedFile[]> {
		const files: GeneratedFile[] = [];

		// Core SSE server
		files.push(this.generateSSEController(options));
		files.push(this.generateSSEService(options));
		files.push(this.generateSSEModule(options));

		// Feature-specific implementations
		for (const feature of options.features) {
			files.push(...this.generateFeatureImplementation(feature, options));
		}

		// Client reconnection logic
		files.push(this.generateClientReconnection(options));

		// Middleware and guards
		if (options.authentication !== "none") {
			files.push(...this.generateAuthMiddleware(options));
		}

		if (options.rateLimit.enabled) {
			files.push(this.generateRateLimitMiddleware(options));
		}

		// Configuration and types
		files.push(this.generateTypes(options));
		files.push(this.generateConfiguration(options));

		// Testing utilities
		files.push(...this.generateTestFiles(options));

		// Client utilities
		files.push(this.generateClientUtils(options));

		return files;
	}

	private generateSSEController(options: SSEOptions): GeneratedFile {
		const content = this.getSSEControllerTemplate(options);

		return {
			path: `src/realtime/sse/${options.projectName}-sse.controller.ts`,
			content,
			type: "controller",
		};
	}

	private generateSSEService(options: SSEOptions): GeneratedFile {
		const content = this.getSSEServiceTemplate(options);

		return {
			path: `src/realtime/sse/${options.projectName}-sse.service.ts`,
			content,
			type: "service",
		};
	}

	private generateSSEModule(options: SSEOptions): GeneratedFile {
		const content = this.getSSEModuleTemplate(options);

		return {
			path: `src/realtime/sse/${options.projectName}-sse.module.ts`,
			content,
			type: "module",
		};
	}

	private generateFeatureImplementation(
		feature: SSEFeature,
		options: SSEOptions,
	): GeneratedFile[] {
		const files: GeneratedFile[] = [];

		switch (feature) {
			case "live-dashboard":
				files.push(this.generateLiveDashboardFeature(options));
				break;
			case "progress-tracking":
				files.push(this.generateProgressTrackingFeature(options));
				break;
			case "notifications":
				files.push(this.generateNotificationsFeature(options));
				break;
			case "metrics-stream":
				files.push(this.generateMetricsStreamFeature(options));
				break;
			case "log-stream":
				files.push(this.generateLogStreamFeature(options));
				break;
			case "stock-ticker":
				files.push(this.generateStockTickerFeature(options));
				break;
			case "game-updates":
				files.push(this.generateGameUpdatesFeature(options));
				break;
			case "system-status":
				files.push(this.generateSystemStatusFeature(options));
				break;
		}

		return files;
	}

	private generateClientReconnection(options: SSEOptions): GeneratedFile {
		const content = `/**
 * SSE Client with automatic reconnection logic
 * Generated by Xaheen CLI for ${options.projectName}
 */

export interface SSEClientOptions {
  url: string;
  retry?: number;
  retryDelay?: number;
  maxRetries?: number;
  headers?: Record<string, string>;
  withCredentials?: boolean;
  onOpen?: (event: Event) => void;
  onMessage?: (data: any) => void;
  onError?: (error: Event) => void;
  onClose?: (event: CloseEvent) => void;
  onReconnect?: (attempt: number) => void;
}

export class SSEClient {
  private eventSource: EventSource | null = null;
  private reconnectAttempts = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private isConnecting = false;
  private isDestroyed = false;

  constructor(private options: SSEClientOptions) {
    this.connect();
  }

  private connect(): void {
    if (this.isConnecting || this.isDestroyed) return;

    this.isConnecting = true;
    
    try {
      const eventSourceInit: EventSourceInit = {};
      
      if (this.options.withCredentials) {
        eventSourceInit.withCredentials = this.options.withCredentials;
      }

      this.eventSource = new EventSource(this.options.url, eventSourceInit);

      this.eventSource.onopen = (event) => {
        this.isConnecting = false;
        this.reconnectAttempts = 0;
        this.options.onOpen?.(event);
      };

      this.eventSource.onmessage = (event) => {
        try {
          const data = JSON.parse(event.data);
          this.options.onMessage?.(data);
        } catch (error) {
          console.error('Error parsing SSE message:', error);
        }
      };

      this.eventSource.onerror = (event) => {
        this.isConnecting = false;
        this.options.onError?.(event);
        
        if (this.eventSource?.readyState === EventSource.CLOSED) {
          this.handleReconnect();
        }
      };

    } catch (error) {
      this.isConnecting = false;
      console.error('Error creating EventSource:', error);
      this.handleReconnect();
    }
  }

  private handleReconnect(): void {
    if (this.isDestroyed) return;

    const maxRetries = this.options.maxRetries ?? 10;
    if (this.reconnectAttempts >= maxRetries) {
      console.error('Max reconnection attempts reached');
      return;
    }

    this.reconnectAttempts++;
    const delay = this.calculateRetryDelay();

    this.options.onReconnect?.(this.reconnectAttempts);

    this.reconnectTimer = setTimeout(() => {
      if (!this.isDestroyed) {
        this.connect();
      }
    }, delay);
  }

  private calculateRetryDelay(): number {
    const baseDelay = this.options.retryDelay ?? 1000;
    const exponentialBackoff = Math.min(
      baseDelay * Math.pow(2, this.reconnectAttempts - 1),
      30000 // Max 30 seconds
    );
    
    // Add jitter to prevent thundering herd
    const jitter = Math.random() * 1000;
    return exponentialBackoff + jitter;
  }

  public addEventListener(type: string, listener: EventListener): void {
    this.eventSource?.addEventListener(type, listener);
  }

  public removeEventListener(type: string, listener: EventListener): void {
    this.eventSource?.removeEventListener(type, listener);
  }

  public close(): void {
    this.isDestroyed = true;
    
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.eventSource) {
      this.eventSource.close();
      this.eventSource = null;
    }
  }

  public get readyState(): number {
    return this.eventSource?.readyState ?? EventSource.CLOSED;
  }

  public get isConnected(): boolean {
    return this.readyState === EventSource.OPEN;
  }
}

// React Hook for SSE
export function useSSE(options: SSEClientOptions) {
  const [data, setData] = useState<any>(null);
  const [isConnected, setIsConnected] = useState(false);
  const [error, setError] = useState<Event | null>(null);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  
  const clientRef = useRef<SSEClient | null>(null);

  useEffect(() => {
    const client = new SSEClient({
      ...options,
      onOpen: (event) => {
        setIsConnected(true);
        setError(null);
        options.onOpen?.(event);
      },
      onMessage: (messageData) => {
        setData(messageData);
        options.onMessage?.(messageData);
      },
      onError: (errorEvent) => {
        setError(errorEvent);
        setIsConnected(false);
        options.onError?.(errorEvent);
      },
      onReconnect: (attempt) => {
        setReconnectAttempts(attempt);
        options.onReconnect?.(attempt);
      }
    });

    clientRef.current = client;

    return () => {
      client.close();
    };
  }, [options.url]);

  return {
    data,
    isConnected,
    error,
    reconnectAttempts,
    client: clientRef.current
  };
}
`;

		return {
			path: `src/realtime/sse/client/sse-client.ts`,
			content,
			type: "utility",
		};
	}

	private generateLiveDashboardFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Live Dashboard SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface DashboardMetrics {
  timestamp: number;
  activeUsers: number;
  requests: number;
  errors: number;
  responseTime: number;
  cpuUsage: number;
  memoryUsage: number;
  diskUsage: number;
}

@Injectable()
export class LiveDashboardService {
  constructor(private readonly sseService: SSEService) {
    this.startMetricsCollection();
  }

  private startMetricsCollection(): void {
    setInterval(() => {
      this.broadcastMetrics();
    }, 5000); // Send metrics every 5 seconds
  }

  private async broadcastMetrics(): Promise<void> {
    const metrics = await this.collectMetrics();
    
    this.sseService.broadcast({
      type: 'dashboard-metrics',
      data: metrics
    });
  }

  private async collectMetrics(): Promise<DashboardMetrics> {
    // In a real implementation, you would collect actual metrics
    return {
      timestamp: Date.now(),
      activeUsers: Math.floor(Math.random() * 1000),
      requests: Math.floor(Math.random() * 10000),
      errors: Math.floor(Math.random() * 100),
      responseTime: Math.floor(Math.random() * 500),
      cpuUsage: Math.random() * 100,
      memoryUsage: Math.random() * 100,
      diskUsage: Math.random() * 100
    };
  }

  public async sendCustomMetric(channelId: string, metric: any): Promise<void> {
    this.sseService.sendToChannel(channelId, {
      type: 'custom-metric',
      data: metric
    });
  }
}
`;

		return {
			path: `src/realtime/sse/features/live-dashboard.service.ts`,
			content,
			type: "service",
		};
	}

	private generateProgressTrackingFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Progress Tracking SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface ProgressUpdate {
  id: string;
  name: string;
  progress: number;
  status: 'pending' | 'running' | 'completed' | 'failed';
  message?: string;
  startTime: number;
  endTime?: number;
  details?: Record<string, any>;
}

@Injectable()
export class ProgressTrackingService {
  private activeOperations = new Map<string, ProgressUpdate>();

  constructor(private readonly sseService: SSEService) {}

  public startOperation(id: string, name: string, userId?: string): void {
    const operation: ProgressUpdate = {
      id,
      name,
      progress: 0,
      status: 'running',
      startTime: Date.now()
    };

    this.activeOperations.set(id, operation);
    this.broadcastUpdate(operation, userId);
  }

  public updateProgress(
    id: string, 
    progress: number, 
    message?: string, 
    details?: Record<string, any>,
    userId?: string
  ): void {
    const operation = this.activeOperations.get(id);
    if (!operation) return;

    operation.progress = Math.max(0, Math.min(100, progress));
    if (message) operation.message = message;
    if (details) operation.details = { ...operation.details, ...details };

    this.activeOperations.set(id, operation);
    this.broadcastUpdate(operation, userId);
  }

  public completeOperation(id: string, message?: string, userId?: string): void {
    const operation = this.activeOperations.get(id);
    if (!operation) return;

    operation.progress = 100;
    operation.status = 'completed';
    operation.endTime = Date.now();
    if (message) operation.message = message;

    this.broadcastUpdate(operation, userId);
    
    // Clean up after 5 minutes
    setTimeout(() => {
      this.activeOperations.delete(id);
    }, 5 * 60 * 1000);
  }

  public failOperation(id: string, message?: string, userId?: string): void {
    const operation = this.activeOperations.get(id);
    if (!operation) return;

    operation.status = 'failed';
    operation.endTime = Date.now();
    if (message) operation.message = message;

    this.broadcastUpdate(operation, userId);
    
    // Clean up after 5 minutes
    setTimeout(() => {
      this.activeOperations.delete(id);
    }, 5 * 60 * 1000);
  }

  private broadcastUpdate(operation: ProgressUpdate, userId?: string): void {
    const message = {
      type: 'progress-update',
      data: operation
    };

    if (userId) {
      this.sseService.sendToUser(userId, message);
    } else {
      this.sseService.sendToChannel(operation.id, message);
    }
  }

  public getActiveOperations(): ProgressUpdate[] {
    return Array.from(this.activeOperations.values());
  }

  public getOperation(id: string): ProgressUpdate | undefined {
    return this.activeOperations.get(id);
  }
}

// Client-side React Hook
export function useProgressTracking(operationId: string) {
  const [progress, setProgress] = useState<ProgressUpdate | null>(null);
  
  const { data } = useSSE({
    url: \`/api/sse/progress?operationId=\${operationId}\`,
    onMessage: (data) => {
      if (data.type === 'progress-update') {
        setProgress(data.data);
      }
    }
  });

  return progress;
}
`;

		return {
			path: `src/realtime/sse/features/progress-tracking.service.ts`,
			content,
			type: "service",
		};
	}

	private generateNotificationsFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Notifications SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface Notification {
  id: string;
  type: 'info' | 'success' | 'warning' | 'error';
  title: string;
  message: string;
  timestamp: number;
  userId?: string;
  channelId?: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  actions?: NotificationAction[];
  metadata?: Record<string, any>;
  expiresAt?: number;
}

export interface NotificationAction {
  id: string;
  label: string;
  url?: string;
  action?: string;
  style?: 'primary' | 'secondary' | 'danger';
}

@Injectable()
export class NotificationsService {
  private notifications = new Map<string, Notification>();

  constructor(private readonly sseService: SSEService) {}

  public async sendNotification(notification: Omit<Notification, 'id' | 'timestamp'>): Promise<string> {
    const id = this.generateId();
    const fullNotification: Notification = {
      ...notification,
      id,
      timestamp: Date.now()
    };

    this.notifications.set(id, fullNotification);

    // Send to specific user or channel
    if (notification.userId) {
      await this.sseService.sendToUser(notification.userId, {
        type: 'notification',
        data: fullNotification
      });
    } else if (notification.channelId) {
      await this.sseService.sendToChannel(notification.channelId, {
        type: 'notification',
        data: fullNotification
      });
    } else {
      // Broadcast to all connected clients
      await this.sseService.broadcast({
        type: 'notification',
        data: fullNotification
      });
    }

    // Auto-expire if specified
    if (notification.expiresAt) {
      setTimeout(() => {
        this.dismissNotification(id);
      }, notification.expiresAt - Date.now());
    }

    return id;
  }

  public async sendBulkNotifications(notifications: Array<Omit<Notification, 'id' | 'timestamp'>>): Promise<string[]> {
    const ids: string[] = [];
    
    for (const notification of notifications) {
      const id = await this.sendNotification(notification);
      ids.push(id);
    }

    return ids;
  }

  public dismissNotification(id: string): void {
    const notification = this.notifications.get(id);
    if (!notification) return;

    this.notifications.delete(id);

    const dismissMessage = {
      type: 'notification-dismissed',
      data: { id }
    };

    if (notification.userId) {
      this.sseService.sendToUser(notification.userId, dismissMessage);
    } else if (notification.channelId) {
      this.sseService.sendToChannel(notification.channelId, dismissMessage);
    } else {
      this.sseService.broadcast(dismissMessage);
    }
  }

  public getNotification(id: string): Notification | undefined {
    return this.notifications.get(id);
  }

  public getUserNotifications(userId: string): Notification[] {
    return Array.from(this.notifications.values())
      .filter(n => n.userId === userId)
      .sort((a, b) => b.timestamp - a.timestamp);
  }

  public getChannelNotifications(channelId: string): Notification[] {
    return Array.from(this.notifications.values())
      .filter(n => n.channelId === channelId)
      .sort((a, b) => b.timestamp - a.timestamp);
  }

  public async handleNotificationAction(notificationId: string, actionId: string, userId?: string): Promise<void> {
    const notification = this.notifications.get(notificationId);
    if (!notification) return;

    const action = notification.actions?.find(a => a.id === actionId);
    if (!action) return;

    // Send action response
    const actionMessage = {
      type: 'notification-action',
      data: {
        notificationId,
        actionId,
        action,
        userId
      }
    };

    if (notification.userId) {
      this.sseService.sendToUser(notification.userId, actionMessage);
    } else if (notification.channelId) {
      this.sseService.sendToChannel(notification.channelId, actionMessage);
    }

    // Auto-dismiss after action
    this.dismissNotification(notificationId);
  }

  private generateId(): string {
    return \`notification_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }
}

// Client-side React Hook
export function useNotifications(userId?: string) {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  
  const { data } = useSSE({
    url: userId ? \`/api/sse/notifications?userId=\${userId}\` : '/api/sse/notifications',
    onMessage: (data) => {
      switch (data.type) {
        case 'notification':
          setNotifications(prev => [data.data, ...prev]);
          break;
        case 'notification-dismissed':
          setNotifications(prev => prev.filter(n => n.id !== data.data.id));
          break;
      }
    }
  });

  const dismissNotification = (id: string) => {
    // Call API to dismiss
    fetch(\`/api/notifications/\${id}/dismiss\`, { method: 'POST' });
  };

  const executeAction = (notificationId: string, actionId: string) => {
    // Call API to execute action
    fetch(\`/api/notifications/\${notificationId}/actions/\${actionId}\`, { method: 'POST' });
  };

  return {
    notifications,
    dismissNotification,
    executeAction
  };
}
`;

		return {
			path: `src/realtime/sse/features/notifications.service.ts`,
			content,
			type: "service",
		};
	}

	private generateMetricsStreamFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Metrics Stream SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface MetricData {
  name: string;
  value: number;
  timestamp: number;
  labels?: Record<string, string>;
  unit?: string;
  type: 'counter' | 'gauge' | 'histogram' | 'summary';
}

export interface MetricAlert {
  id: string;
  metricName: string;
  condition: string;
  threshold: number;
  currentValue: number;
  severity: 'info' | 'warning' | 'critical';
  timestamp: number;
  message: string;
}

@Injectable()
export class MetricsStreamService {
  private metrics = new Map<string, MetricData[]>();
  private alerts = new Map<string, MetricAlert>();
  private thresholds = new Map<string, { warning: number; critical: number }>();

  constructor(private readonly sseService: SSEService) {
    this.startMetricsCollection();
  }

  private startMetricsCollection(): void {
    // Collect system metrics every second
    setInterval(() => {
      this.collectSystemMetrics();
    }, 1000);

    // Check alerts every 5 seconds
    setInterval(() => {
      this.checkAlerts();
    }, 5000);
  }

  private async collectSystemMetrics(): Promise<void> {
    const timestamp = Date.now();
    
    // CPU Usage
    const cpuUsage = await this.getCPUUsage();
    this.recordMetric({
      name: 'cpu_usage_percent',
      value: cpuUsage,
      timestamp,
      type: 'gauge',
      unit: 'percent'
    });

    // Memory Usage
    const memoryUsage = await this.getMemoryUsage();
    this.recordMetric({
      name: 'memory_usage_percent',
      value: memoryUsage,
      timestamp,
      type: 'gauge',
      unit: 'percent'
    });

    // Request rate
    const requestRate = await this.getRequestRate();
    this.recordMetric({
      name: 'http_requests_per_second',
      value: requestRate,
      timestamp,
      type: 'gauge',
      unit: 'requests/sec'
    });

    // Error rate
    const errorRate = await this.getErrorRate();
    this.recordMetric({
      name: 'error_rate_percent',
      value: errorRate,
      timestamp,
      type: 'gauge',
      unit: 'percent'
    });
  }

  public recordMetric(metric: MetricData): void {
    const key = this.getMetricKey(metric);
    
    if (!this.metrics.has(key)) {
      this.metrics.set(key, []);
    }

    const metrics = this.metrics.get(key)!;
    metrics.push(metric);

    // Keep only last 1000 data points
    if (metrics.length > 1000) {
      metrics.shift();
    }

    // Broadcast to subscribers
    this.sseService.sendToChannel(\`metrics:\${metric.name}\`, {
      type: 'metric-update',
      data: metric
    });

    // Broadcast to general metrics channel
    this.sseService.sendToChannel('metrics', {
      type: 'metric-update',
      data: metric
    });
  }

  public setThreshold(metricName: string, warning: number, critical: number): void {
    this.thresholds.set(metricName, { warning, critical });
  }

  private checkAlerts(): void {
    for (const [metricName, threshold] of this.thresholds) {
      const latestMetric = this.getLatestMetric(metricName);
      if (!latestMetric) continue;

      const alertId = \`\${metricName}_alert\`;
      const existingAlert = this.alerts.get(alertId);

      if (latestMetric.value >= threshold.critical) {
        if (!existingAlert || existingAlert.severity !== 'critical') {
          this.createAlert(alertId, metricName, latestMetric.value, threshold.critical, 'critical');
        }
      } else if (latestMetric.value >= threshold.warning) {
        if (!existingAlert || existingAlert.severity !== 'warning') {
          this.createAlert(alertId, metricName, latestMetric.value, threshold.warning, 'warning');
        }
      } else if (existingAlert) {
        // Clear alert
        this.clearAlert(alertId);
      }
    }
  }

  private createAlert(
    id: string, 
    metricName: string, 
    currentValue: number, 
    threshold: number, 
    severity: 'info' | 'warning' | 'critical'
  ): void {
    const alert: MetricAlert = {
      id,
      metricName,
      condition: severity === 'critical' ? '>= critical' : '>= warning',
      threshold,
      currentValue,
      severity,
      timestamp: Date.now(),
      message: \`\${metricName} is \${currentValue.toFixed(2)} (threshold: \${threshold})\`
    };

    this.alerts.set(id, alert);

    this.sseService.broadcast({
      type: 'metric-alert',
      data: alert
    });
  }

  private clearAlert(id: string): void {
    this.alerts.delete(id);

    this.sseService.broadcast({
      type: 'metric-alert-cleared',
      data: { id }
    });
  }

  private getLatestMetric(metricName: string): MetricData | undefined {
    const key = this.getMetricKey({ name: metricName } as MetricData);
    const metrics = this.metrics.get(key);
    return metrics?.[metrics.length - 1];
  }

  public getMetricHistory(metricName: string, timeRange?: number): MetricData[] {
    const key = this.getMetricKey({ name: metricName } as MetricData);
    const metrics = this.metrics.get(key) || [];
    
    if (!timeRange) return metrics;

    const cutoff = Date.now() - timeRange;
    return metrics.filter(m => m.timestamp >= cutoff);
  }

  private getMetricKey(metric: MetricData): string {
    const labels = metric.labels || {};
    const labelString = Object.entries(labels)
      .sort(([a], [b]) => a.localeCompare(b))
      .map(([k, v]) => \`\${k}=\${v}\`)
      .join(',');
    
    return labelString ? \`\${metric.name}{\${labelString}}\` : metric.name;
  }

  // Mock implementations - replace with actual system metrics
  private async getCPUUsage(): Promise<number> {
    return Math.random() * 100;
  }

  private async getMemoryUsage(): Promise<number> {
    return Math.random() * 100;
  }

  private async getRequestRate(): Promise<number> {
    return Math.floor(Math.random() * 1000);
  }

  private async getErrorRate(): Promise<number> {
    return Math.random() * 10;
  }
}

// Client-side React Hook
export function useMetricsStream(metricNames: string[]) {
  const [metrics, setMetrics] = useState<Record<string, MetricData[]>>({});
  const [alerts, setAlerts] = useState<MetricAlert[]>([]);
  
  const { data } = useSSE({
    url: \`/api/sse/metrics?metrics=\${metricNames.join(',')}\`,
    onMessage: (data) => {
      switch (data.type) {
        case 'metric-update':
          setMetrics(prev => ({
            ...prev,
            [data.data.name]: [...(prev[data.data.name] || []), data.data].slice(-100)
          }));
          break;
        case 'metric-alert':
          setAlerts(prev => [...prev.filter(a => a.id !== data.data.id), data.data]);
          break;
        case 'metric-alert-cleared':
          setAlerts(prev => prev.filter(a => a.id !== data.data.id));
          break;
      }
    }
  });

  return { metrics, alerts };
}
`;

		return {
			path: `src/realtime/sse/features/metrics-stream.service.ts`,
			content,
			type: "service",
		};
	}

	private generateLogStreamFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Log Stream SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface LogEntry {
  id: string;
  timestamp: number;
  level: 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  message: string;
  service: string;
  module?: string;
  userId?: string;
  requestId?: string;
  metadata?: Record<string, any>;
  stackTrace?: string;
  tags?: string[];
}

export interface LogFilter {
  levels?: string[];
  services?: string[];
  modules?: string[];
  timeRange?: { start: number; end: number };
  search?: string;
  tags?: string[];
  userId?: string;
}

@Injectable()
export class LogStreamService {
  private logs: LogEntry[] = [];
  private maxLogs = 10000;
  private filters = new Map<string, LogFilter>();

  constructor(private readonly sseService: SSEService) {}

  public addLog(log: Omit<LogEntry, 'id' | 'timestamp'>): void {
    const logEntry: LogEntry = {
      ...log,
      id: this.generateLogId(),
      timestamp: Date.now()
    };

    this.logs.push(logEntry);

    // Keep only recent logs
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }

    // Broadcast to all log stream subscribers
    this.broadcastLog(logEntry);
  }

  private broadcastLog(log: LogEntry): void {
    // Send to general log stream
    this.sseService.sendToChannel('logs', {
      type: 'log-entry',
      data: log
    });

    // Send to level-specific channels
    this.sseService.sendToChannel(\`logs:level:\${log.level}\`, {
      type: 'log-entry',
      data: log
    });

    // Send to service-specific channels
    this.sseService.sendToChannel(\`logs:service:\${log.service}\`, {
      type: 'log-entry',
      data: log
    });

    // Send to module-specific channels if available
    if (log.module) {
      this.sseService.sendToChannel(\`logs:module:\${log.module}\`, {
        type: 'log-entry',
        data: log
      });
    }

    // Send to user-specific channels if available
    if (log.userId) {
      this.sseService.sendToChannel(\`logs:user:\${log.userId}\`, {
        type: 'log-entry',
        data: log
      });
    }

    // Send to filtered streams
    for (const [channelId, filter] of this.filters) {
      if (this.matchesFilter(log, filter)) {
        this.sseService.sendToChannel(channelId, {
          type: 'log-entry',
          data: log
        });
      }
    }
  }

  public subscribeToFiltered(channelId: string, filter: LogFilter): void {
    this.filters.set(channelId, filter);

    // Send recent matching logs
    const matchingLogs = this.logs
      .filter(log => this.matchesFilter(log, filter))
      .slice(-100); // Last 100 matching logs

    for (const log of matchingLogs) {
      this.sseService.sendToChannel(channelId, {
        type: 'log-entry',
        data: log
      });
    }
  }

  public unsubscribeFromFiltered(channelId: string): void {
    this.filters.delete(channelId);
  }

  private matchesFilter(log: LogEntry, filter: LogFilter): boolean {
    // Level filter
    if (filter.levels && !filter.levels.includes(log.level)) {
      return false;
    }

    // Service filter
    if (filter.services && !filter.services.includes(log.service)) {
      return false;
    }

    // Module filter
    if (filter.modules && log.module && !filter.modules.includes(log.module)) {
      return false;
    }

    // Time range filter
    if (filter.timeRange) {
      if (log.timestamp < filter.timeRange.start || log.timestamp > filter.timeRange.end) {
        return false;
      }
    }

    // Search filter
    if (filter.search) {
      const searchLower = filter.search.toLowerCase();
      if (!log.message.toLowerCase().includes(searchLower)) {
        return false;
      }
    }

    // Tags filter
    if (filter.tags && filter.tags.length > 0) {
      if (!log.tags || !filter.tags.some(tag => log.tags!.includes(tag))) {
        return false;
      }
    }

    // User filter
    if (filter.userId && log.userId !== filter.userId) {
      return false;
    }

    return true;
  }

  public getLogs(filter?: LogFilter, limit = 100): LogEntry[] {
    let filteredLogs = this.logs;

    if (filter) {
      filteredLogs = this.logs.filter(log => this.matchesFilter(log, filter));
    }

    return filteredLogs.slice(-limit).reverse();
  }

  public getLogById(id: string): LogEntry | undefined {
    return this.logs.find(log => log.id === id);
  }

  public clearLogs(): void {
    this.logs = [];
    
    this.sseService.broadcast({
      type: 'logs-cleared',
      data: {}
    });
  }

  private generateLogId(): string {
    return \`log_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  // Helper methods for different log levels
  public debug(message: string, service: string, metadata?: Record<string, any>): void {
    this.addLog({ level: 'debug', message, service, metadata });
  }

  public info(message: string, service: string, metadata?: Record<string, any>): void {
    this.addLog({ level: 'info', message, service, metadata });
  }

  public warn(message: string, service: string, metadata?: Record<string, any>): void {
    this.addLog({ level: 'warn', message, service, metadata });
  }

  public error(message: string, service: string, error?: Error, metadata?: Record<string, any>): void {
    this.addLog({ 
      level: 'error', 
      message, 
      service, 
      stackTrace: error?.stack,
      metadata 
    });
  }

  public fatal(message: string, service: string, error?: Error, metadata?: Record<string, any>): void {
    this.addLog({ 
      level: 'fatal', 
      message, 
      service, 
      stackTrace: error?.stack,
      metadata 
    });
  }
}

// Client-side React Hook
export function useLogStream(filter?: LogFilter) {
  const [logs, setLogs] = useState<LogEntry[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  
  const { data, isConnected: connected } = useSSE({
    url: '/api/sse/logs' + (filter ? \`?filter=\${encodeURIComponent(JSON.stringify(filter))}\` : ''),
    onMessage: (data) => {
      switch (data.type) {
        case 'log-entry':
          setLogs(prev => [data.data, ...prev].slice(0, 1000)); // Keep last 1000 logs
          break;
        case 'logs-cleared':
          setLogs([]);
          break;
      }
    }
  });

  useEffect(() => {
    setIsConnected(connected);
  }, [connected]);

  const clearLogs = () => {
    setLogs([]);
  };

  return {
    logs,
    isConnected,
    clearLogs
  };
}
`;

		return {
			path: `src/realtime/sse/features/log-stream.service.ts`,
			content,
			type: "service",
		};
	}

	private generateStockTickerFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Stock Ticker SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface StockPrice {
  symbol: string;
  price: number;
  change: number;
  changePercent: number;
  volume: number;
  timestamp: number;
  high: number;
  low: number;
  open: number;
  previousClose: number;
}

export interface MarketData {
  marketStatus: 'open' | 'closed' | 'pre-market' | 'after-hours';
  indices: {
    [key: string]: {
      value: number;
      change: number;
      changePercent: number;
    };
  };
  topGainers: StockPrice[];
  topLosers: StockPrice[];
  mostActive: StockPrice[];
}

@Injectable()
export class StockTickerService {
  private stocks = new Map<string, StockPrice>();
  private subscribers = new Set<string>();
  private updateInterval: NodeJS.Timeout | null = null;

  constructor(private readonly sseService: SSEService) {
    this.initializeStocks();
    this.startRealTimeUpdates();
  }

  private initializeStocks(): void {
    // Initialize with some sample stocks
    const symbols = ['AAPL', 'GOOGL', 'MSFT', 'AMZN', 'TSLA', 'META', 'NVDA', 'NFLX'];
    
    for (const symbol of symbols) {
      const basePrice = Math.random() * 500 + 50;
      this.stocks.set(symbol, {
        symbol,
        price: basePrice,
        change: 0,
        changePercent: 0,
        volume: Math.floor(Math.random() * 10000000),
        timestamp: Date.now(),
        high: basePrice * 1.05,
        low: basePrice * 0.95,
        open: basePrice,
        previousClose: basePrice
      });
    }
  }

  private startRealTimeUpdates(): void {
    this.updateInterval = setInterval(() => {
      this.updateStockPrices();
    }, 1000); // Update every second
  }

  private updateStockPrices(): void {
    const now = Date.now();
    
    for (const [symbol, stock] of this.stocks) {
      // Simulate price movement
      const volatility = 0.02; // 2% volatility
      const change = (Math.random() - 0.5) * 2 * volatility;
      const newPrice = Math.max(0.01, stock.price * (1 + change));
      
      const updatedStock: StockPrice = {
        ...stock,
        price: Number(newPrice.toFixed(2)),
        change: Number((newPrice - stock.previousClose).toFixed(2)),
        changePercent: Number(((newPrice - stock.previousClose) / stock.previousClose * 100).toFixed(2)),
        volume: stock.volume + Math.floor(Math.random() * 1000),
        timestamp: now,
        high: Math.max(stock.high, newPrice),
        low: Math.min(stock.low, newPrice)
      };

      this.stocks.set(symbol, updatedStock);

      // Broadcast to subscribers
      this.broadcastStockUpdate(updatedStock);
    }

    // Broadcast market data summary
    this.broadcastMarketData();
  }

  private broadcastStockUpdate(stock: StockPrice): void {
    // Send to all stock subscribers
    this.sseService.sendToChannel('stocks', {
      type: 'stock-update',
      data: stock
    });

    // Send to symbol-specific subscribers
    this.sseService.sendToChannel(\`stock:\${stock.symbol}\`, {
      type: 'stock-update',
      data: stock
    });
  }

  private broadcastMarketData(): void {
    const stocks = Array.from(this.stocks.values());
    
    const marketData: MarketData = {
      marketStatus: this.getMarketStatus(),
      indices: {
        'S&P 500': {
          value: 4500 + (Math.random() - 0.5) * 100,
          change: (Math.random() - 0.5) * 50,
          changePercent: (Math.random() - 0.5) * 2
        },
        'NASDAQ': {
          value: 14000 + (Math.random() - 0.5) * 500,
          change: (Math.random() - 0.5) * 100,
          changePercent: (Math.random() - 0.5) * 3
        },
        'DOW': {
          value: 35000 + (Math.random() - 0.5) * 1000,
          change: (Math.random() - 0.5) * 200,
          changePercent: (Math.random() - 0.5) * 1.5
        }
      },
      topGainers: stocks
        .sort((a, b) => b.changePercent - a.changePercent)
        .slice(0, 3),
      topLosers: stocks
        .sort((a, b) => a.changePercent - b.changePercent)
        .slice(0, 3),
      mostActive: stocks
        .sort((a, b) => b.volume - a.volume)
        .slice(0, 3)
    };

    this.sseService.sendToChannel('market-data', {
      type: 'market-data',
      data: marketData
    });
  }

  private getMarketStatus(): 'open' | 'closed' | 'pre-market' | 'after-hours' {
    const now = new Date();
    const hour = now.getHours();
    const day = now.getDay();

    // Weekend
    if (day === 0 || day === 6) return 'closed';

    // Pre-market: 4:00 AM - 9:30 AM EST
    if (hour >= 4 && hour < 9) return 'pre-market';
    if (hour === 9 && now.getMinutes() < 30) return 'pre-market';

    // Market hours: 9:30 AM - 4:00 PM EST
    if (hour >= 9 && hour < 16) {
      if (hour === 9 && now.getMinutes() < 30) return 'pre-market';
      return 'open';
    }

    // After hours: 4:00 PM - 8:00 PM EST
    if (hour >= 16 && hour < 20) return 'after-hours';

    return 'closed';
  }

  public addStock(symbol: string): void {
    if (!this.stocks.has(symbol)) {
      const basePrice = Math.random() * 500 + 50;
      this.stocks.set(symbol, {
        symbol,
        price: basePrice,
        change: 0,
        changePercent: 0,
        volume: Math.floor(Math.random() * 10000000),
        timestamp: Date.now(),
        high: basePrice,
        low: basePrice,
        open: basePrice,
        previousClose: basePrice
      });
    }
  }

  public removeStock(symbol: string): void {
    this.stocks.delete(symbol);
  }

  public getStock(symbol: string): StockPrice | undefined {
    return this.stocks.get(symbol);
  }

  public getAllStocks(): StockPrice[] {
    return Array.from(this.stocks.values());
  }

  public getWatchlist(symbols: string[]): StockPrice[] {
    return symbols.map(symbol => this.stocks.get(symbol)).filter(Boolean) as StockPrice[];
  }

  onModuleDestroy(): void {
    if (this.updateInterval) {
      clearInterval(this.updateInterval);
    }
  }
}

// Client-side React Hook
export function useStockTicker(symbols?: string[]) {
  const [stocks, setStocks] = useState<Record<string, StockPrice>>({});
  const [marketData, setMarketData] = useState<MarketData | null>(null);
  
  const url = symbols 
    ? \`/api/sse/stocks?symbols=\${symbols.join(',')}\`
    : '/api/sse/stocks';

  const { data, isConnected } = useSSE({
    url,
    onMessage: (data) => {
      switch (data.type) {
        case 'stock-update':
          setStocks(prev => ({
            ...prev,
            [data.data.symbol]: data.data
          }));
          break;
        case 'market-data':
          setMarketData(data.data);
          break;
      }
    }
  });

  const getStock = (symbol: string) => stocks[symbol];
  const getWatchlist = (symbols: string[]) => 
    symbols.map(symbol => stocks[symbol]).filter(Boolean);

  return {
    stocks,
    marketData,
    isConnected,
    getStock,
    getWatchlist
  };
}
`;

		return {
			path: `src/realtime/sse/features/stock-ticker.service.ts`,
			content,
			type: "service",
		};
	}

	private generateGameUpdatesFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Game Updates SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface GameState {
  gameId: string;
  players: Player[];
  status: 'waiting' | 'starting' | 'active' | 'paused' | 'finished';
  currentTurn?: string;
  round: number;
  score: Record<string, number>;
  gameData: Record<string, any>;
  timestamp: number;
}

export interface Player {
  id: string;
  name: string;
  avatar?: string;
  isOnline: boolean;
  lastActivity: number;
  score: number;
  metadata?: Record<string, any>;
}

export interface GameEvent {
  id: string;
  gameId: string;
  type: string;
  playerId: string;
  data: any;
  timestamp: number;
}

export interface GameUpdate {
  type: 'state-change' | 'player-action' | 'turn-change' | 'score-update' | 'game-event';
  gameId: string;
  data: any;
  timestamp: number;
}

@Injectable()
export class GameUpdatesService {
  private games = new Map<string, GameState>();
  private gameEvents = new Map<string, GameEvent[]>();

  constructor(private readonly sseService: SSEService) {}

  public createGame(gameId: string, initialData?: Record<string, any>): GameState {
    const gameState: GameState = {
      gameId,
      players: [],
      status: 'waiting',
      round: 0,
      score: {},
      gameData: initialData || {},
      timestamp: Date.now()
    };

    this.games.set(gameId, gameState);
    this.gameEvents.set(gameId, []);

    this.broadcastGameUpdate(gameId, {
      type: 'state-change',
      gameId,
      data: gameState,
      timestamp: Date.now()
    });

    return gameState;
  }

  public joinGame(gameId: string, player: Omit<Player, 'isOnline' | 'lastActivity' | 'score'>): boolean {
    const game = this.games.get(gameId);
    if (!game || game.status !== 'waiting') return false;

    const fullPlayer: Player = {
      ...player,
      isOnline: true,
      lastActivity: Date.now(),
      score: 0
    };

    game.players.push(fullPlayer);
    game.score[player.id] = 0;
    game.timestamp = Date.now();

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'player-action',
      gameId,
      data: { action: 'join', player: fullPlayer },
      timestamp: Date.now()
    });

    return true;
  }

  public leaveGame(gameId: string, playerId: string): boolean {
    const game = this.games.get(gameId);
    if (!game) return false;

    game.players = game.players.filter(p => p.id !== playerId);
    delete game.score[playerId];
    game.timestamp = Date.now();

    // If no players left, end the game
    if (game.players.length === 0) {
      game.status = 'finished';
    }

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'player-action',
      gameId,
      data: { action: 'leave', playerId },
      timestamp: Date.now()
    });

    return true;
  }

  public startGame(gameId: string): boolean {
    const game = this.games.get(gameId);
    if (!game || game.status !== 'waiting' || game.players.length === 0) return false;

    game.status = 'starting';
    game.currentTurn = game.players[0].id;
    game.round = 1;
    game.timestamp = Date.now();

    this.games.set(gameId, game);

    // Start the game after a brief countdown
    setTimeout(() => {
      const updatedGame = this.games.get(gameId);
      if (updatedGame && updatedGame.status === 'starting') {
        updatedGame.status = 'active';
        updatedGame.timestamp = Date.now();
        this.games.set(gameId, updatedGame);

        this.broadcastGameUpdate(gameId, {
          type: 'state-change',
          gameId,
          data: updatedGame,
          timestamp: Date.now()
        });
      }
    }, 3000);

    this.broadcastGameUpdate(gameId, {
      type: 'state-change',
      gameId,
      data: game,
      timestamp: Date.now()
    });

    return true;
  }

  public updatePlayerScore(gameId: string, playerId: string, scoreChange: number): boolean {
    const game = this.games.get(gameId);
    if (!game) return false;

    const player = game.players.find(p => p.id === playerId);
    if (!player) return false;

    player.score += scoreChange;
    game.score[playerId] = player.score;
    game.timestamp = Date.now();

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'score-update',
      gameId,
      data: { playerId, score: player.score, change: scoreChange },
      timestamp: Date.now()
    });

    return true;
  }

  public nextTurn(gameId: string): boolean {
    const game = this.games.get(gameId);
    if (!game || game.status !== 'active') return false;

    const currentIndex = game.players.findIndex(p => p.id === game.currentTurn);
    const nextIndex = (currentIndex + 1) % game.players.length;
    
    // If we've gone through all players, increment round
    if (nextIndex === 0) {
      game.round++;
    }

    game.currentTurn = game.players[nextIndex].id;
    game.timestamp = Date.now();

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'turn-change',
      gameId,
      data: { currentTurn: game.currentTurn, round: game.round },
      timestamp: Date.now()
    });

    return true;
  }

  public sendGameEvent(gameId: string, playerId: string, eventType: string, eventData: any): void {
    const game = this.games.get(gameId);
    if (!game) return;

    const event: GameEvent = {
      id: this.generateEventId(),
      gameId,
      type: eventType,
      playerId,
      data: eventData,
      timestamp: Date.now()
    };

    const events = this.gameEvents.get(gameId) || [];
    events.push(event);
    
    // Keep only last 100 events per game
    if (events.length > 100) {
      events.shift();
    }
    
    this.gameEvents.set(gameId, events);

    this.broadcastGameUpdate(gameId, {
      type: 'game-event',
      gameId,
      data: event,
      timestamp: Date.now()
    });
  }

  public updateGameData(gameId: string, data: Record<string, any>): boolean {
    const game = this.games.get(gameId);
    if (!game) return false;

    game.gameData = { ...game.gameData, ...data };
    game.timestamp = Date.now();

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'state-change',
      gameId,
      data: game,
      timestamp: Date.now()
    });

    return true;
  }

  public endGame(gameId: string, results?: Record<string, any>): boolean {
    const game = this.games.get(gameId);
    if (!game) return false;

    game.status = 'finished';
    game.timestamp = Date.now();
    
    if (results) {
      game.gameData.results = results;
    }

    this.games.set(gameId, game);

    this.broadcastGameUpdate(gameId, {
      type: 'state-change',
      gameId,
      data: game,
      timestamp: Date.now()
    });

    // Clean up game data after 1 hour
    setTimeout(() => {
      this.games.delete(gameId);
      this.gameEvents.delete(gameId);
    }, 60 * 60 * 1000);

    return true;
  }

  private broadcastGameUpdate(gameId: string, update: GameUpdate): void {
    // Send to game-specific channel
    this.sseService.sendToChannel(\`game:\${gameId}\`, {
      type: 'game-update',
      data: update
    });

    // Send to general games channel
    this.sseService.sendToChannel('games', {
      type: 'game-update',
      data: update
    });

    // Send to player-specific channels
    const game = this.games.get(gameId);
    if (game) {
      for (const player of game.players) {
        this.sseService.sendToChannel(\`player:\${player.id}\`, {
          type: 'game-update',
          data: update
        });
      }
    }
  }

  public getGame(gameId: string): GameState | undefined {
    return this.games.get(gameId);
  }

  public getGameEvents(gameId: string): GameEvent[] {
    return this.gameEvents.get(gameId) || [];
  }

  public getActiveGames(): GameState[] {
    return Array.from(this.games.values()).filter(game => game.status === 'active');
  }

  public getPlayerGames(playerId: string): GameState[] {
    return Array.from(this.games.values()).filter(game => 
      game.players.some(player => player.id === playerId)
    );
  }

  private generateEventId(): string {
    return \`event_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }
}

// Client-side React Hook
export function useGameUpdates(gameId: string) {
  const [gameState, setGameState] = useState<GameState | null>(null);
  const [gameEvents, setGameEvents] = useState<GameEvent[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  
  const { data, isConnected: connected } = useSSE({
    url: \`/api/sse/games/\${gameId}\`,
    onMessage: (data) => {
      if (data.type === 'game-update') {
        const update = data.data as GameUpdate;
        
        switch (update.type) {
          case 'state-change':
            setGameState(update.data);
            break;
          case 'game-event':
            setGameEvents(prev => [...prev, update.data].slice(-100));
            break;
          case 'player-action':
          case 'turn-change':
          case 'score-update':
            // These updates should trigger a state refresh
            // In a real implementation, you might want to optimistically update
            break;
        }
      }
    }
  });

  useEffect(() => {
    setIsConnected(connected);
  }, [connected]);

  return {
    gameState,
    gameEvents,
    isConnected
  };
}
`;

		return {
			path: `src/realtime/sse/features/game-updates.service.ts`,
			content,
			type: "service",
		};
	}

	private generateSystemStatusFeature(options: SSEOptions): GeneratedFile {
		const content = `/**
 * System Status SSE Feature
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable } from '@nestjs/common';
import { SSEService } from '../${options.projectName}-sse.service';

export interface SystemStatus {
  overall: 'healthy' | 'degraded' | 'down';
  timestamp: number;
  services: ServiceStatus[];
  infrastructure: InfrastructureStatus;
  alerts: SystemAlert[];
}

export interface ServiceStatus {
  name: string;
  status: 'healthy' | 'degraded' | 'down';
  responseTime: number;
  uptime: number;
  lastCheck: number;
  version?: string;
  url?: string;
  metadata?: Record<string, any>;
}

export interface InfrastructureStatus {
  database: ComponentStatus;
  cache: ComponentStatus;
  messageQueue: ComponentStatus;
  storage: ComponentStatus;
  cdn: ComponentStatus;
}

export interface ComponentStatus {
  status: 'healthy' | 'degraded' | 'down';
  responseTime: number;
  connections?: number;
  usage?: number;
  lastCheck: number;
  details?: Record<string, any>;
}

export interface SystemAlert {
  id: string;
  severity: 'info' | 'warning' | 'error' | 'critical';
  title: string;
  message: string;
  component: string;
  timestamp: number;
  acknowledged: boolean;
  resolvedAt?: number;
}

@Injectable()
export class SystemStatusService {
  private currentStatus: SystemStatus;
  private healthCheckInterval: NodeJS.Timeout | null = null;
  private services: Array<{ name: string; url: string; timeout: number }> = [];

  constructor(private readonly sseService: SSEService) {
    this.currentStatus = this.getInitialStatus();
    this.startHealthChecks();
  }

  private getInitialStatus(): SystemStatus {
    return {
      overall: 'healthy',
      timestamp: Date.now(),
      services: [],
      infrastructure: {
        database: { status: 'healthy', responseTime: 0, lastCheck: Date.now() },
        cache: { status: 'healthy', responseTime: 0, lastCheck: Date.now() },
        messageQueue: { status: 'healthy', responseTime: 0, lastCheck: Date.now() },
        storage: { status: 'healthy', responseTime: 0, lastCheck: Date.now() },
        cdn: { status: 'healthy', responseTime: 0, lastCheck: Date.now() }
      },
      alerts: []
    };
  }

  private startHealthChecks(): void {
    this.healthCheckInterval = setInterval(() => {
      this.performHealthChecks();
    }, 30000); // Check every 30 seconds

    // Initial check
    this.performHealthChecks();
  }

  private async performHealthChecks(): Promise<void> {
    const timestamp = Date.now();
    
    // Check services
    const serviceStatuses = await Promise.all(
      this.services.map(service => this.checkService(service))
    );

    // Check infrastructure
    const infrastructureStatus = await this.checkInfrastructure();

    // Determine overall status
    const allStatuses = [
      ...serviceStatuses.map(s => s.status),
      ...Object.values(infrastructureStatus).map(c => c.status)
    ];

    let overallStatus: 'healthy' | 'degraded' | 'down' = 'healthy';
    if (allStatuses.some(s => s === 'down')) {
      overallStatus = 'down';
    } else if (allStatuses.some(s => s === 'degraded')) {
      overallStatus = 'degraded';
    }

    // Check for status changes and create alerts
    const newAlerts = this.detectStatusChanges(serviceStatuses, infrastructureStatus);

    this.currentStatus = {
      overall: overallStatus,
      timestamp,
      services: serviceStatuses,
      infrastructure: infrastructureStatus,
      alerts: [...this.currentStatus.alerts, ...newAlerts].slice(-50) // Keep last 50 alerts
    };

    // Broadcast status update
    this.broadcastStatusUpdate();
  }

  private async checkService(service: { name: string; url: string; timeout: number }): Promise<ServiceStatus> {
    const startTime = Date.now();
    
    try {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), service.timeout);

      const response = await fetch(service.url, {
        signal: controller.signal,
        method: 'GET'
      });

      clearTimeout(timeoutId);
      const responseTime = Date.now() - startTime;

      return {
        name: service.name,
        status: response.ok ? 'healthy' : 'degraded',
        responseTime,
        uptime: 99.9, // This would be calculated from historical data
        lastCheck: Date.now(),
        url: service.url
      };
    } catch (error) {
      const responseTime = Date.now() - startTime;
      
      return {
        name: service.name,
        status: 'down',
        responseTime,
        uptime: 99.9,
        lastCheck: Date.now(),
        url: service.url
      };
    }
  }

  private async checkInfrastructure(): Promise<InfrastructureStatus> {
    // These would be real health checks in a production system
    return {
      database: await this.checkDatabase(),
      cache: await this.checkCache(),
      messageQueue: await this.checkMessageQueue(),
      storage: await this.checkStorage(),
      cdn: await this.checkCDN()
    };
  }

  private async checkDatabase(): Promise<ComponentStatus> {
    const startTime = Date.now();
    
    try {
      // Mock database health check
      await new Promise(resolve => setTimeout(resolve, Math.random() * 100));
      
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime,
        connections: Math.floor(Math.random() * 100),
        usage: Math.random() * 80,
        lastCheck: Date.now()
      };
    } catch (error) {
      return {
        status: 'down',
        responseTime: Date.now() - startTime,
        lastCheck: Date.now()
      };
    }
  }

  private async checkCache(): Promise<ComponentStatus> {
    const startTime = Date.now();
    
    try {
      // Mock cache health check
      await new Promise(resolve => setTimeout(resolve, Math.random() * 50));
      
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime,
        usage: Math.random() * 60,
        lastCheck: Date.now()
      };
    } catch (error) {
      return {
        status: 'down',
        responseTime: Date.now() - startTime,
        lastCheck: Date.now()
      };
    }
  }

  private async checkMessageQueue(): Promise<ComponentStatus> {
    const startTime = Date.now();
    
    try {
      // Mock message queue health check
      await new Promise(resolve => setTimeout(resolve, Math.random() * 75));
      
      return {
        status: 'healthy',
        responseTime: Date.now() - startTime,
        connections: Math.floor(Math.random() * 50),
        lastCheck: Date.now()
      };
    } catch (error) {
      return {
        status: 'down',
        responseTime: Date.now() - startTime,
        lastCheck: Date.now()
      };
    }
  }

  private async checkStorage(): Promise<ComponentStatus> {
    const startTime = Date.now();
    
    return {
      status: 'healthy',
      responseTime: Date.now() - startTime,
      usage: Math.random() * 70,
      lastCheck: Date.now()
    };
  }

  private async checkCDN(): Promise<ComponentStatus> {
    const startTime = Date.now();
    
    return {
      status: 'healthy',
      responseTime: Date.now() - startTime,
      lastCheck: Date.now()
    };
  }

  private detectStatusChanges(
    services: ServiceStatus[], 
    infrastructure: InfrastructureStatus
  ): SystemAlert[] {
    const alerts: SystemAlert[] = [];
    
    // Check for service status changes
    for (const service of services) {
      const previousService = this.currentStatus.services.find(s => s.name === service.name);
      if (previousService && previousService.status !== service.status) {
        alerts.push({
          id: this.generateAlertId(),
          severity: service.status === 'down' ? 'critical' : 'warning',
          title: \`Service Status Change: \${service.name}\`,
          message: \`Service \${service.name} changed from \${previousService.status} to \${service.status}\`,
          component: service.name,
          timestamp: Date.now(),
          acknowledged: false
        });
      }
    }

    // Check for infrastructure status changes
    for (const [component, status] of Object.entries(infrastructure)) {
      const previousStatus = this.currentStatus.infrastructure[component as keyof InfrastructureStatus];
      if (previousStatus && previousStatus.status !== status.status) {
        alerts.push({
          id: this.generateAlertId(),
          severity: status.status === 'down' ? 'critical' : 'warning',
          title: \`Infrastructure Status Change: \${component}\`,
          message: \`\${component} changed from \${previousStatus.status} to \${status.status}\`,
          component,
          timestamp: Date.now(),
          acknowledged: false
        });
      }
    }

    return alerts;
  }

  private broadcastStatusUpdate(): void {
    this.sseService.broadcast({
      type: 'system-status',
      data: this.currentStatus
    });

    // Send to specific channels
    this.sseService.sendToChannel('system-status', {
      type: 'system-status',
      data: this.currentStatus
    });

    // Send alerts to alert channel
    const newAlerts = this.currentStatus.alerts.filter(a => !a.acknowledged);
    if (newAlerts.length > 0) {
      this.sseService.sendToChannel('alerts', {
        type: 'system-alerts',
        data: newAlerts
      });
    }
  }

  public registerService(name: string, url: string, timeout = 5000): void {
    this.services.push({ name, url, timeout });
  }

  public unregisterService(name: string): void {
    this.services = this.services.filter(s => s.name !== name);
  }

  public acknowledgeAlert(alertId: string): boolean {
    const alert = this.currentStatus.alerts.find(a => a.id === alertId);
    if (!alert) return false;

    alert.acknowledged = true;
    
    this.sseService.broadcast({
      type: 'alert-acknowledged',
      data: { alertId }
    });

    return true;
  }

  public resolveAlert(alertId: string): boolean {
    const alert = this.currentStatus.alerts.find(a => a.id === alertId);
    if (!alert) return false;

    alert.resolvedAt = Date.now();
    alert.acknowledged = true;
    
    this.sseService.broadcast({
      type: 'alert-resolved',
      data: { alertId }
    });

    return true;
  }

  public getCurrentStatus(): SystemStatus {
    return this.currentStatus;
  }

  public getServiceStatus(serviceName: string): ServiceStatus | undefined {
    return this.currentStatus.services.find(s => s.name === serviceName);
  }

  private generateAlertId(): string {
    return \`alert_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  onModuleDestroy(): void {
    if (this.healthCheckInterval) {
      clearInterval(this.healthCheckInterval);
    }
  }
}

// Client-side React Hook
export function useSystemStatus() {
  const [status, setStatus] = useState<SystemStatus | null>(null);
  const [alerts, setAlerts] = useState<SystemAlert[]>([]);
  const [isConnected, setIsConnected] = useState(false);
  
  const { data, isConnected: connected } = useSSE({
    url: '/api/sse/system-status',
    onMessage: (data) => {
      switch (data.type) {
        case 'system-status':
          setStatus(data.data);
          break;
        case 'system-alerts':
          setAlerts(data.data);
          break;
        case 'alert-acknowledged':
        case 'alert-resolved':
          // Update local alerts state
          setAlerts(prev => prev.map(alert => 
            alert.id === data.data.alertId 
              ? { ...alert, acknowledged: true, ...(data.type === 'alert-resolved' ? { resolvedAt: Date.now() } : {}) }
              : alert
          ));
          break;
      }
    }
  });

  useEffect(() => {
    setIsConnected(connected);
  }, [connected]);

  const acknowledgeAlert = (alertId: string) => {
    fetch(\`/api/system-status/alerts/\${alertId}/acknowledge\`, { method: 'POST' });
  };

  const resolveAlert = (alertId: string) => {
    fetch(\`/api/system-status/alerts/\${alertId}/resolve\`, { method: 'POST' });
  };

  return {
    status,
    alerts,
    isConnected,
    acknowledgeAlert,
    resolveAlert
  };
}
`;

		return {
			path: `src/realtime/sse/features/system-status.service.ts`,
			content,
			type: "service",
		};
	}

	private generateAuthMiddleware(options: SSEOptions): GeneratedFile[] {
		const files: GeneratedFile[] = [];

		if (options.authentication === "jwt") {
			files.push({
				path: `src/realtime/sse/middleware/jwt-auth.middleware.ts`,
				content: this.getJWTAuthMiddlewareTemplate(options),
				type: "middleware",
			});
		} else if (options.authentication === "api-key") {
			files.push({
				path: `src/realtime/sse/middleware/api-key-auth.middleware.ts`,
				content: this.getAPIKeyAuthMiddlewareTemplate(options),
				type: "middleware",
			});
		} else if (options.authentication === "session") {
			files.push({
				path: `src/realtime/sse/middleware/session-auth.middleware.ts`,
				content: this.getSessionAuthMiddlewareTemplate(options),
				type: "middleware",
			});
		}

		return files;
	}

	private generateRateLimitMiddleware(options: SSEOptions): GeneratedFile {
		const content = `/**
 * Rate Limit Middleware for SSE
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, NestMiddleware } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

interface RateLimitOptions {
  requests: number;
  window: string;
  skipSuccessfulRequests?: boolean;
  skipFailedRequests?: boolean;
  keyGenerator?: (req: Request) => string;
}

@Injectable()
export class SSERateLimitMiddleware implements NestMiddleware {
  private store = new Map<string, { count: number; resetTime: number }>();
  private options: RateLimitOptions = {
    requests: ${options.rateLimit.requests},
    window: '${options.rateLimit.window}',
    skipSuccessfulRequests: false,
    skipFailedRequests: false,
    keyGenerator: (req) => req.ip
  };

  constructor(options?: Partial<RateLimitOptions>) {
    if (options) {
      this.options = { ...this.options, ...options };
    }
  }

  use(req: Request, res: Response, next: NextFunction): void {
    const key = this.options.keyGenerator!(req);
    const now = Date.now();
    const windowMs = this.parseWindow(this.options.window);
    
    let record = this.store.get(key);
    
    if (!record || now >= record.resetTime) {
      record = {
        count: 0,
        resetTime: now + windowMs
      };
      this.store.set(key, record);
    }

    record.count++;

    if (record.count > this.options.requests) {
      res.status(429).json({
        error: 'Too Many Requests',
        message: \`Rate limit exceeded. Try again in \${Math.ceil((record.resetTime - now) / 1000)} seconds.\`,
        retryAfter: Math.ceil((record.resetTime - now) / 1000)
      });
      return;
    }

    // Set rate limit headers
    res.setHeader('X-RateLimit-Limit', this.options.requests);
    res.setHeader('X-RateLimit-Remaining', Math.max(0, this.options.requests - record.count));
    res.setHeader('X-RateLimit-Reset', new Date(record.resetTime).toISOString());

    next();
  }

  private parseWindow(window: string): number {
    const match = window.match(/^(\\d+)(ms|s|m|h|d)$/);
    if (!match) throw new Error(\`Invalid window format: \${window}\`);

    const value = parseInt(match[1], 10);
    const unit = match[2];

    switch (unit) {
      case 'ms': return value;
      case 's': return value * 1000;
      case 'm': return value * 60 * 1000;
      case 'h': return value * 60 * 60 * 1000;
      case 'd': return value * 24 * 60 * 60 * 1000;
      default: throw new Error(\`Invalid time unit: \${unit}\`);
    }
  }

  // Clean up expired entries periodically
  private cleanup(): void {
    const now = Date.now();
    for (const [key, record] of this.store.entries()) {
      if (now >= record.resetTime) {
        this.store.delete(key);
      }
    }
  }
}
`;

		return {
			path: `src/realtime/sse/middleware/rate-limit.middleware.ts`,
			content,
			type: "middleware",
		};
	}

	private generateTypes(options: SSEOptions): GeneratedFile {
		const content = `/**
 * SSE Types and Interfaces
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Request, Response } from 'express';

export interface SSEConnection {
  id: string;
  userId?: string;
  channels: Set<string>;
  req: Request;
  res: Response;
  createdAt: number;
  lastPing: number;
  isAlive: boolean;
}

export interface SSEMessage {
  id?: string;
  event?: string;
  data: any;
  retry?: number;
}

export interface SSEChannel {
  id: string;
  connections: Set<string>;
  metadata?: Record<string, any>;
}

export interface SSEEvent {
  type: string;
  data: any;
  timestamp: number;
  connectionId?: string;
  userId?: string;
  channelId?: string;
}

export interface SSESubscription {
  connectionId: string;
  channelId: string;
  filters?: Record<string, any>;
  subscribedAt: number;
}

export interface SSEMetrics {
  totalConnections: number;
  activeConnections: number;
  totalChannels: number;
  messagesSent: number;
  messagesPerSecond: number;
  averageConnectionDuration: number;
  connectionsPerUser: Record<string, number>;
  channelDistribution: Record<string, number>;
}

export interface SSEHealthCheck {
  status: 'healthy' | 'degraded' | 'unhealthy';
  connections: number;
  channels: number;
  uptime: number;
  lastCheck: number;
  errors: string[];
}

export type SSEFeature = ${options.features.map((f) => `'${f}'`).join(" | ")};

export interface SSEConfiguration {
  heartbeatInterval: number;
  connectionTimeout: number;
  maxConnections: number;
  maxChannelsPerConnection: number;
  compression: boolean;
  cors: {
    enabled: boolean;
    origin?: string | string[];
    credentials?: boolean;
  };
  rateLimit: {
    enabled: boolean;
    requests: number;
    window: string;
  };
  authentication: {
    type: '${options.authentication}';
    required: boolean;
  };
  monitoring: {
    enabled: boolean;
    metricsInterval: number;
  };
}

export interface SSEBroadcastOptions {
  channels?: string[];
  users?: string[];
  exclude?: {
    channels?: string[];
    users?: string[];
    connections?: string[];
  };
  filter?: (connection: SSEConnection) => boolean;
}

export interface SSEChannelOptions {
  maxConnections?: number;
  requireAuth?: boolean;
  permissions?: string[];
  metadata?: Record<string, any>;
}
`;

		return {
			path: `src/realtime/sse/types/sse.types.ts`,
			content,
			type: "types",
		};
	}

	private generateConfiguration(options: SSEOptions): GeneratedFile {
		const content = `/**
 * SSE Configuration
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { SSEConfiguration } from './types/sse.types';

export const sseConfig: SSEConfiguration = {
  heartbeatInterval: ${options.heartbeat.enabled ? options.heartbeat.interval : 30000},
  connectionTimeout: 60000, // 1 minute
  maxConnections: 10000,
  maxChannelsPerConnection: 50,
  compression: ${options.compression},
  cors: {
    enabled: ${options.cors},
    origin: process.env.SSE_CORS_ORIGIN || '*',
    credentials: true
  },
  rateLimit: {
    enabled: ${options.rateLimit.enabled},
    requests: ${options.rateLimit.requests},
    window: '${options.rateLimit.window}'
  },
  authentication: {
    type: '${options.authentication}',
    required: ${options.authentication !== "none"}
  },
  monitoring: {
    enabled: ${options.monitoring},
    metricsInterval: 10000 // 10 seconds
  }
};

export const sseEndpoints = {
  ${options.features
		.map((feature) => {
			switch (feature) {
				case "live-dashboard":
					return `'${feature}': '/api/sse/dashboard'`;
				case "progress-tracking":
					return `'${feature}': '/api/sse/progress'`;
				case "notifications":
					return `'${feature}': '/api/sse/notifications'`;
				case "metrics-stream":
					return `'${feature}': '/api/sse/metrics'`;
				case "log-stream":
					return `'${feature}': '/api/sse/logs'`;
				case "stock-ticker":
					return `'${feature}': '/api/sse/stocks'`;
				case "game-updates":
					return `'${feature}': '/api/sse/games'`;
				case "system-status":
					return `'${feature}': '/api/sse/system-status'`;
				default:
					return `'${feature}': '/api/sse/${feature}'`;
			}
		})
		.join(",\n  ")}
};

export const sseMessages = {
  connection: {
    established: 'SSE connection established',
    closed: 'SSE connection closed',
    error: 'SSE connection error',
    timeout: 'SSE connection timeout'
  },
  authentication: {
    required: 'Authentication required for SSE connection',
    invalid: 'Invalid authentication credentials',
    expired: 'Authentication token expired'
  },
  rateLimit: {
    exceeded: 'Rate limit exceeded for SSE connection',
    warning: 'Approaching rate limit threshold'
  },
  subscription: {
    success: 'Successfully subscribed to channel',
    failed: 'Failed to subscribe to channel',
    unauthorized: 'Unauthorized to subscribe to channel'
  }
};
`;

		return {
			path: `src/realtime/sse/config/sse.config.ts`,
			content,
			type: "config",
		};
	}

	private generateTestFiles(options: SSEOptions): GeneratedFile[] {
		return [
			{
				path: `src/realtime/sse/__tests__/${options.projectName}-sse.service.spec.ts`,
				content: this.getSSEServiceTestTemplate(options),
				type: "test",
			},
			{
				path: `src/realtime/sse/__tests__/${options.projectName}-sse.controller.spec.ts`,
				content: this.getSSEControllerTestTemplate(options),
				type: "test",
			},
		];
	}

	private generateClientUtils(options: SSEOptions): GeneratedFile {
		const content = `/**
 * SSE Client Utilities
 * Generated by Xaheen CLI for ${options.projectName}
 */

export class SSEClientManager {
  private clients = new Map<string, SSEClient>();

  public create(id: string, options: SSEClientOptions): SSEClient {
    const client = new SSEClient(options);
    this.clients.set(id, client);
    return client;
  }

  public get(id: string): SSEClient | undefined {
    return this.clients.get(id);
  }

  public remove(id: string): boolean {
    const client = this.clients.get(id);
    if (client) {
      client.close();
      this.clients.delete(id);
      return true;
    }
    return false;
  }

  public closeAll(): void {
    for (const [id, client] of this.clients) {
      client.close();
    }
    this.clients.clear();
  }

  public getActiveConnections(): string[] {
    return Array.from(this.clients.keys()).filter(id => {
      const client = this.clients.get(id);
      return client?.isConnected;
    });
  }
}

// Singleton instance
export const sseClientManager = new SSEClientManager();

// Helper functions
export function createSSEUrl(endpoint: string, params?: Record<string, string>): string {
  const url = new URL(endpoint, window.location.origin);
  
  if (params) {
    for (const [key, value] of Object.entries(params)) {
      url.searchParams.set(key, value);
    }
  }
  
  return url.toString();
}

export function parseSSEMessage(raw: string): { event?: string; data: any; id?: string; retry?: number } {
  const lines = raw.split('\\n');
  const result: any = {};
  
  for (const line of lines) {
    const colonIndex = line.indexOf(':');
    if (colonIndex === -1) continue;
    
    const field = line.substring(0, colonIndex).trim();
    const value = line.substring(colonIndex + 1).trim();
    
    switch (field) {
      case 'event':
        result.event = value;
        break;
      case 'data':
        try {
          result.data = JSON.parse(value);
        } catch {
          result.data = value;
        }
        break;
      case 'id':
        result.id = value;
        break;
      case 'retry':
        result.retry = parseInt(value, 10);
        break;
    }
  }
  
  return result;
}

// React utilities
export function useSSEMultiple(connections: Array<{ id: string; options: SSEClientOptions }>) {
  const [clients, setClients] = useState<Record<string, SSEClient>>({});
  const [data, setData] = useState<Record<string, any>>({});
  const [connectionStates, setConnectionStates] = useState<Record<string, boolean>>({});

  useEffect(() => {
    const newClients: Record<string, SSEClient> = {};
    
    for (const { id, options } of connections) {
      const client = new SSEClient({
        ...options,
        onOpen: (event) => {
          setConnectionStates(prev => ({ ...prev, [id]: true }));
          options.onOpen?.(event);
        },
        onMessage: (messageData) => {
          setData(prev => ({ ...prev, [id]: messageData }));
          options.onMessage?.(messageData);
        },
        onError: (error) => {
          setConnectionStates(prev => ({ ...prev, [id]: false }));
          options.onError?.(error);
        },
        onClose: (event) => {
          setConnectionStates(prev => ({ ...prev, [id]: false }));
          options.onClose?.(event);
        }
      });
      
      newClients[id] = client;
    }
    
    setClients(newClients);
    
    return () => {
      for (const client of Object.values(newClients)) {
        client.close();
      }
    };
  }, [connections]);

  return {
    clients,
    data,
    connectionStates,
    isAllConnected: Object.values(connectionStates).every(Boolean),
    connectedCount: Object.values(connectionStates).filter(Boolean).length
  };
}
`;

		return {
			path: `src/realtime/sse/client/sse-client-utils.ts`,
			content,
			type: "utility",
		};
	}

	// Template methods
	private getSSEControllerTemplate(options: SSEOptions): string {
		return `/**
 * SSE Controller
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Controller, Get, Req, Res, Query, UseGuards } from '@nestjs/common';
import { Request, Response } from 'express';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService } from './${options.projectName}-sse.service';
${options.authentication === "jwt" ? "import { JwtAuthGuard } from '../../auth/guards/jwt-auth.guard';" : ""}
${options.rateLimit.enabled ? "import { SSERateLimitMiddleware } from './middleware/rate-limit.middleware';" : ""}

@Controller('sse')
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController {
  constructor(
    private readonly sseService: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService
  ) {}

  ${options.features
		.map((feature) => {
			const methodName = feature.replace(/-/g, "");
			const routePath = feature.replace(/_/g, "-");

			return `
  @Get('${routePath}')
  ${options.authentication !== "none" ? "@UseGuards(JwtAuthGuard)" : ""}
  async ${methodName}(
    @Req() req: Request,
    @Res() res: Response,
    @Query() query: any
  ): Promise<void> {
    await this.sseService.handleConnection(req, res, '${feature}', query);
  }`;
		})
		.join("")}

  @Get('health')
  async health(): Promise<{ status: string; connections: number }> {
    return this.sseService.getHealthStatus();
  }

  @Get('metrics')
  async metrics(): Promise<any> {
    return this.sseService.getMetrics();
  }
}`;
	}

	private getSSEServiceTemplate(options: SSEOptions): string {
		return `/**
 * SSE Service
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, Logger } from '@nestjs/common';
import { Request, Response } from 'express';
import { SSEConnection, SSEMessage, SSEChannel, SSEMetrics } from './types/sse.types';
import { sseConfig } from './config/sse.config';

@Injectable()
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService {
  private readonly logger = new Logger(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService.name);
  private connections = new Map<string, SSEConnection>();
  private channels = new Map<string, SSEChannel>();
  private metrics: SSEMetrics = {
    totalConnections: 0,
    activeConnections: 0,
    totalChannels: 0,
    messagesSent: 0,
    messagesPerSecond: 0,
    averageConnectionDuration: 0,
    connectionsPerUser: {},
    channelDistribution: {}
  };

  constructor() {
    this.startHeartbeat();
    this.startMetricsCollection();
  }

  async handleConnection(
    req: Request,
    res: Response,
    feature: string,
    query: any
  ): Promise<void> {
    const connectionId = this.generateConnectionId();
    const userId = this.extractUserId(req);

    // Set SSE headers
    res.writeHead(200, {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Headers': 'Cache-Control'
    });

    // Create connection
    const connection: SSEConnection = {
      id: connectionId,
      userId,
      channels: new Set(),
      req,
      res,
      createdAt: Date.now(),
      lastPing: Date.now(),
      isAlive: true
    };

    this.connections.set(connectionId, connection);
    this.metrics.totalConnections++;
    this.metrics.activeConnections++;

    if (userId) {
      this.metrics.connectionsPerUser[userId] = (this.metrics.connectionsPerUser[userId] || 0) + 1;
    }

    // Subscribe to feature channel
    this.subscribeToChannel(connectionId, feature);

    // Send initial connection message
    this.sendToConnection(connectionId, {
      event: 'connected',
      data: { connectionId, feature, timestamp: Date.now() }
    });

    // Handle connection close
    req.on('close', () => {
      this.handleDisconnection(connectionId);
    });

    req.on('error', (error) => {
      this.logger.error(\`SSE connection error: \${error.message}\`, error.stack);
      this.handleDisconnection(connectionId);
    });

    this.logger.log(\`New SSE connection established: \${connectionId} for feature: \${feature}\`);
  }

  private handleDisconnection(connectionId: string): void {
    const connection = this.connections.get(connectionId);
    if (!connection) return;

    // Remove from all channels
    for (const channelId of connection.channels) {
      this.unsubscribeFromChannel(connectionId, channelId);
    }

    // Update metrics
    this.metrics.activeConnections--;
    if (connection.userId) {
      this.metrics.connectionsPerUser[connection.userId]--;
      if (this.metrics.connectionsPerUser[connection.userId] <= 0) {
        delete this.metrics.connectionsPerUser[connection.userId];
      }
    }

    this.connections.delete(connectionId);
    this.logger.log(\`SSE connection closed: \${connectionId}\`);
  }

  public sendToConnection(connectionId: string, message: SSEMessage): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection || !connection.isAlive) return false;

    try {
      const formattedMessage = this.formatSSEMessage(message);
      connection.res.write(formattedMessage);
      this.metrics.messagesSent++;
      return true;
    } catch (error) {
      this.logger.error(\`Error sending message to connection \${connectionId}\`, error);
      this.handleDisconnection(connectionId);
      return false;
    }
  }

  public sendToChannel(channelId: string, message: SSEMessage): number {
    const channel = this.channels.get(channelId);
    if (!channel) return 0;

    let sentCount = 0;
    for (const connectionId of channel.connections) {
      if (this.sendToConnection(connectionId, message)) {
        sentCount++;
      }
    }

    return sentCount;
  }

  public sendToUser(userId: string, message: SSEMessage): number {
    let sentCount = 0;
    for (const connection of this.connections.values()) {
      if (connection.userId === userId && connection.isAlive) {
        if (this.sendToConnection(connection.id, message)) {
          sentCount++;
        }
      }
    }
    return sentCount;
  }

  public broadcast(message: SSEMessage): number {
    let sentCount = 0;
    for (const connection of this.connections.values()) {
      if (connection.isAlive) {
        if (this.sendToConnection(connection.id, message)) {
          sentCount++;
        }
      }
    }
    return sentCount;
  }

  public subscribeToChannel(connectionId: string, channelId: string): boolean {
    const connection = this.connections.get(connectionId);
    if (!connection) return false;

    // Create channel if it doesn't exist
    if (!this.channels.has(channelId)) {
      this.channels.set(channelId, {
        id: channelId,
        connections: new Set()
      });
      this.metrics.totalChannels++;
    }

    const channel = this.channels.get(channelId)!;
    channel.connections.add(connectionId);
    connection.channels.add(channelId);

    this.metrics.channelDistribution[channelId] = channel.connections.size;

    return true;
  }

  public unsubscribeFromChannel(connectionId: string, channelId: string): boolean {
    const connection = this.connections.get(connectionId);
    const channel = this.channels.get(channelId);

    if (!connection || !channel) return false;

    channel.connections.delete(connectionId);
    connection.channels.delete(channelId);

    // Remove empty channels
    if (channel.connections.size === 0) {
      this.channels.delete(channelId);
      this.metrics.totalChannels--;
      delete this.metrics.channelDistribution[channelId];
    } else {
      this.metrics.channelDistribution[channelId] = channel.connections.size;
    }

    return true;
  }

  private formatSSEMessage(message: SSEMessage): string {
    let formatted = '';

    if (message.id) {
      formatted += \`id: \${message.id}\\n\`;
    }

    if (message.event) {
      formatted += \`event: \${message.event}\\n\`;
    }

    if (message.retry) {
      formatted += \`retry: \${message.retry}\\n\`;
    }

    const data = typeof message.data === 'string' 
      ? message.data 
      : JSON.stringify(message.data);

    formatted += \`data: \${data}\\n\\n\`;

    return formatted;
  }

  private startHeartbeat(): void {
    if (!sseConfig.heartbeatInterval) return;

    setInterval(() => {
      const now = Date.now();
      for (const [connectionId, connection] of this.connections) {
        if (now - connection.lastPing > sseConfig.connectionTimeout) {
          this.handleDisconnection(connectionId);
        } else {
          this.sendToConnection(connectionId, {
            event: 'ping',
            data: { timestamp: now }
          });
        }
      }
    }, sseConfig.heartbeatInterval);
  }

  private startMetricsCollection(): void {
    if (!sseConfig.monitoring.enabled) return;

    setInterval(() => {
      this.updateMetrics();
    }, sseConfig.monitoring.metricsInterval);
  }

  private updateMetrics(): void {
    this.metrics.activeConnections = this.connections.size;
    this.metrics.totalChannels = this.channels.size;

    // Calculate messages per second (simplified)
    // In a real implementation, you'd track this over time
    this.metrics.messagesPerSecond = Math.random() * 100; // Mock value

    // Calculate average connection duration
    let totalDuration = 0;
    const now = Date.now();
    for (const connection of this.connections.values()) {
      totalDuration += now - connection.createdAt;
    }
    this.metrics.averageConnectionDuration = this.connections.size > 0 
      ? totalDuration / this.connections.size 
      : 0;
  }

  public getHealthStatus(): { status: string; connections: number } {
    return {
      status: this.connections.size > 0 ? 'healthy' : 'idle',
      connections: this.connections.size
    };
  }

  public getMetrics(): SSEMetrics {
    return { ...this.metrics };
  }

  private generateConnectionId(): string {
    return \`sse_\${Date.now()}_\${Math.random().toString(36).substr(2, 9)}\`;
  }

  private extractUserId(req: Request): string | undefined {
    // Extract user ID from JWT token, session, or other auth mechanism
    return (req as any).user?.id;
  }
}`;
	}

	private getSSEModuleTemplate(options: SSEOptions): string {
		return `/**
 * SSE Module
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Module } from '@nestjs/common';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController } from './${options.projectName}-sse.controller';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService } from './${options.projectName}-sse.service';

// Feature services
${options.features
	.map((feature) => {
		const serviceName =
			feature
				.split("-")
				.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
				.join("") + "Service";
		return `import { ${serviceName} } from './features/${feature}.service';`;
	})
	.join("\n")}

@Module({
  controllers: [${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController],
  providers: [
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService,
    ${options.features
			.map((feature) => {
				return (
					feature
						.split("-")
						.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
						.join("") + "Service"
				);
			})
			.join(",\n    ")}
  ],
  exports: [
    ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService,
    ${options.features
			.map((feature) => {
				return (
					feature
						.split("-")
						.map((word) => word.charAt(0).toUpperCase() + word.slice(1))
						.join("") + "Service"
				);
			})
			.join(",\n    ")}
  ]
})
export class ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEModule {}`;
	}

	private getJWTAuthMiddlewareTemplate(options: SSEOptions): string {
		return `/**
 * JWT Authentication Middleware for SSE
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';
import { JwtService } from '@nestjs/jwt';

@Injectable()
export class JWTSSEAuthMiddleware implements NestMiddleware {
  constructor(private readonly jwtService: JwtService) {}

  use(req: Request, res: Response, next: NextFunction): void {
    try {
      const token = this.extractTokenFromRequest(req);
      
      if (!token) {
        throw new UnauthorizedException('No token provided');
      }

      const payload = this.jwtService.verify(token);
      (req as any).user = payload;

      next();
    } catch (error) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Invalid or missing authentication token'
      });
    }
  }

  private extractTokenFromRequest(req: Request): string | null {
    // Try Authorization header first
    const authHeader = req.headers.authorization;
    if (authHeader && authHeader.startsWith('Bearer ')) {
      return authHeader.substring(7);
    }

    // Try query parameter
    const tokenQuery = req.query.token as string;
    if (tokenQuery) {
      return tokenQuery;
    }

    // Try cookie
    const tokenCookie = req.cookies?.token;
    if (tokenCookie) {
      return tokenCookie;
    }

    return null;
  }
}`;
	}

	private getAPIKeyAuthMiddlewareTemplate(options: SSEOptions): string {
		return `/**
 * API Key Authentication Middleware for SSE
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class APIKeySSEAuthMiddleware implements NestMiddleware {
  private readonly validApiKeys = new Set([
    process.env.SSE_API_KEY,
    // Add more API keys as needed
  ].filter(Boolean));

  use(req: Request, res: Response, next: NextFunction): void {
    try {
      const apiKey = this.extractApiKeyFromRequest(req);
      
      if (!apiKey) {
        throw new UnauthorizedException('No API key provided');
      }

      if (!this.validApiKeys.has(apiKey)) {
        throw new UnauthorizedException('Invalid API key');
      }

      // Set user context if needed
      (req as any).user = { apiKey };

      next();
    } catch (error) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Invalid or missing API key'
      });
    }
  }

  private extractApiKeyFromRequest(req: Request): string | null {
    // Try X-API-Key header
    const apiKeyHeader = req.headers['x-api-key'] as string;
    if (apiKeyHeader) {
      return apiKeyHeader;
    }

    // Try query parameter
    const apiKeyQuery = req.query.apiKey as string;
    if (apiKeyQuery) {
      return apiKeyQuery;
    }

    return null;
  }
}`;
	}

	private getSessionAuthMiddlewareTemplate(options: SSEOptions): string {
		return `/**
 * Session Authentication Middleware for SSE
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Injectable, NestMiddleware, UnauthorizedException } from '@nestjs/common';
import { Request, Response, NextFunction } from 'express';

@Injectable()
export class SessionSSEAuthMiddleware implements NestMiddleware {
  use(req: Request, res: Response, next: NextFunction): void {
    try {
      if (!req.session || !req.session.user) {
        throw new UnauthorizedException('No valid session');
      }

      // Session is valid, set user context
      (req as any).user = req.session.user;

      next();
    } catch (error) {
      res.status(401).json({
        error: 'Unauthorized',
        message: 'Invalid or missing session'
      });
    }
  }
}`;
	}

	private getSSEServiceTestTemplate(options: SSEOptions): string {
		return `/**
 * SSE Service Tests
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Test, TestingModule } from '@nestjs/testing';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService } from '../${options.projectName}-sse.service';

describe('${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService', () => {
  let service: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService],
    }).compile();

    service = module.get<${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService>(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });

  describe('connection management', () => {
    it('should handle new connections', () => {
      // Test connection handling
    });

    it('should handle disconnections', () => {
      // Test disconnection handling
    });
  });

  describe('messaging', () => {
    it('should send messages to connections', () => {
      // Test message sending
    });

    it('should broadcast messages', () => {
      // Test broadcasting
    });
  });

  describe('channels', () => {
    it('should manage channel subscriptions', () => {
      // Test channel management
    });
  });
});`;
	}

	private getSSEControllerTestTemplate(options: SSEOptions): string {
		return `/**
 * SSE Controller Tests
 * Generated by Xaheen CLI for ${options.projectName}
 */

import { Test, TestingModule } from '@nestjs/testing';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController } from '../${options.projectName}-sse.controller';
import { ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService } from '../${options.projectName}-sse.service';

describe('${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController', () => {
  let controller: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController;
  let service: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController],
      providers: [
        {
          provide: ${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService,
          useValue: {
            handleConnection: jest.fn(),
            getHealthStatus: jest.fn(),
            getMetrics: jest.fn(),
          },
        },
      ],
    }).compile();

    controller = module.get<${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController>(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEController);
    service = module.get<${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService>(${options.projectName.charAt(0).toUpperCase() + options.projectName.slice(1)}SSEService);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });

  describe('health endpoint', () => {
    it('should return health status', async () => {
      const healthStatus = { status: 'healthy', connections: 5 };
      jest.spyOn(service, 'getHealthStatus').mockResolvedValue(healthStatus);

      const result = await controller.health();
      expect(result).toEqual(healthStatus);
    });
  });

  describe('metrics endpoint', () => {
    it('should return metrics', async () => {
      const metrics = { totalConnections: 10, activeConnections: 5 };
      jest.spyOn(service, 'getMetrics').mockResolvedValue(metrics);

      const result = await controller.metrics();
      expect(result).toEqual(metrics);
    });
  });
});`;
	}
}
