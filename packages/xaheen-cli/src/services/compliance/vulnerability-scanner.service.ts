import * as fs from 'fs-extra';
import * as path from 'path';
import { z } from 'zod';
import chalk from 'chalk';
import { createHash } from 'crypto';
import { execSync } from 'child_process';

/**
 * Vulnerability Scanner Service
 * Implements automated vulnerability scanning with OWASP Top 10 and CVE database integration
 * Supports Norwegian enterprise security requirements and NSM compliance
 */

// OWASP Top 10 2021 Categories
export const OWASPTop10Schema = z.enum([
  'A01_BROKEN_ACCESS_CONTROL', // Broken Access Control
  'A02_CRYPTOGRAPHIC_FAILURES', // Cryptographic Failures
  'A03_INJECTION', // Injection
  'A04_INSECURE_DESIGN', // Insecure Design
  'A05_SECURITY_MISCONFIGURATION', // Security Misconfiguration
  'A06_VULNERABLE_COMPONENTS', // Vulnerable and Outdated Components
  'A07_IDENTIFICATION_FAILURES', // Identification and Authentication Failures
  'A08_SOFTWARE_INTEGRITY_FAILURES', // Software and Data Integrity Failures
  'A09_LOGGING_FAILURES', // Security Logging and Monitoring Failures
  'A10_SSRF', // Server-Side Request Forgery
]);

export const VulnerabilitySeveritySchema = z.enum([
  'CRITICAL', // 9.0-10.0 CVSS
  'HIGH', // 7.0-8.9 CVSS
  'MEDIUM', // 4.0-6.9 CVSS
  'LOW', // 0.1-3.9 CVSS
  'INFO', // 0.0 CVSS
]);

export const ScanTypeSchema = z.enum([
  'STATIC_CODE_ANALYSIS', // SAST
  'DYNAMIC_APPLICATION_TESTING', // DAST
  'INTERACTIVE_APPLICATION_TESTING', // IAST
  'DEPENDENCY_SCANNING', // SCA
  'CONTAINER_SCANNING', // Container image scanning
  'INFRASTRUCTURE_SCANNING', // Infrastructure as Code scanning
  'SECRET_SCANNING', // Secret and credential scanning
  'LICENSE_SCANNING', // Open source license scanning
]);

export type OWASPTop10 = z.infer<typeof OWASPTop10Schema>;
export type VulnerabilitySeverity = z.infer<typeof VulnerabilitySeveritySchema>;
export type ScanType = z.infer<typeof ScanTypeSchema>;

// Vulnerability Scanner Configuration
export const VulnerabilityScannerConfigSchema = z.object({
  organizationName: z.string(),
  projectPath: z.string(),
  scanTypes: z.array(ScanTypeSchema).default([
    'STATIC_CODE_ANALYSIS',
    'DEPENDENCY_SCANNING',
    'SECRET_SCANNING',
  ]),
  severity: z.object({
    failOnCritical: z.boolean().default(true),
    failOnHigh: z.boolean().default(false),
    reportAll: z.boolean().default(true),
  }),
  cveDatabase: z.object({
    enabled: z.boolean().default(true),
    updateInterval: z.string().default('daily'),
    sources: z.array(z.string()).default([
      'https://nvd.nist.gov/feeds/json/cve/1.1/',
      'https://api.github.com/advisories',
      'https://www.npmjs.com/advisories',
    ]),
  }),
  owaspIntegration: z.object({
    enabled: z.boolean().default(true),
    categories: z.array(OWASPTop10Schema).default([
      'A01_BROKEN_ACCESS_CONTROL',
      'A02_CRYPTOGRAPHIC_FAILURES',
      'A03_INJECTION',
      'A06_VULNERABLE_COMPONENTS',
    ]),
  }),
  norwegianCompliance: z.object({
    nsmReporting: z.boolean().default(true),
    gdprAssessment: z.boolean().default(true),
    norwegianLanguage: z.boolean().default(true),
  }),
  tools: z.object({
    staticAnalysis: z.object({
      sonarqube: z.boolean().default(false),
      eslint: z.boolean().default(true),
      semgrep: z.boolean().default(true),
      codeql: z.boolean().default(false),
    }),
    dependencyScanning: z.object({
      npm_audit: z.boolean().default(true),
      snyk: z.boolean().default(false),
      dependabot: z.boolean().default(true),
      retire_js: z.boolean().default(true),
    }),
    secretScanning: z.object({
      truffleHog: z.boolean().default(true),
      gitleaks: z.boolean().default(true),
      secretlint: z.boolean().default(true),
    }),
    containerScanning: z.object({
      trivy: z.boolean().default(true),
      clair: z.boolean().default(false),
      anchore: z.boolean().default(false),
    }),
  }),
  reporting: z.object({
    format: z.enum(['json', 'xml', 'sarif', 'pdf', 'html']).default('json'),
    outputPath: z.string().default('./security-reports'),
    includeRemediation: z.boolean().default(true),
    executiveSummary: z.boolean().default(true),
  }),
});

export type VulnerabilityScannerConfig = z.infer<typeof VulnerabilityScannerConfigSchema>;

// Vulnerability Interfaces
export interface Vulnerability {
  id: string;
  cveId?: string;
  title: string;
  description: string;
  severity: VulnerabilitySeverity;
  cvssScore: number;
  cvssVector?: string;
  owaspCategory?: OWASPTop10;
  cweId?: string;
  file?: string;
  line?: number;
  column?: number;
  function?: string;
  component?: string;
  version?: string;
  fixedVersion?: string;
  references: string[];
  discoveredAt: Date;
  source: 'SAST' | 'DAST' | 'SCA' | 'SECRET' | 'CONTAINER' | 'MANUAL';
  confidence: 'HIGH' | 'MEDIUM' | 'LOW';
  exploitability: 'FUNCTIONAL' | 'POC' | 'UNPROVEN' | 'NOT_DEFINED';
  remediation?: {
    description: string;
    effort: 'LOW' | 'MEDIUM' | 'HIGH';
    priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
    steps: string[];
    norwegianGuidance?: string;
  };
}

export interface ScanResult {
  scanId: string;
  scanDate: Date;
  projectPath: string;
  scanTypes: ScanType[];
  duration: number; // milliseconds
  
  summary: {
    totalVulnerabilities: number;
    criticalCount: number;
    highCount: number;
    mediumCount: number;
    lowCount: number;
    infoCount: number;
    fixableCount: number;
  };
  
  vulnerabilities: Vulnerability[];
  
  owaspBreakdown: {
    [key in OWASPTop10]?: {
      count: number;
      severity: VulnerabilitySeverity;
      vulnerabilities: string[]; // vulnerability IDs
    };
  };
  
  compliance: {
    nsmCompliant: boolean;
    gdprImpact: boolean;
    norwegianRequirements: {
      dataProtection: boolean;
      incidentReporting: boolean;
      securityMeasures: boolean;
    };
  };
  
  recommendations: SecurityRecommendation[];
  metrics: ScanMetrics;
}

export interface SecurityRecommendation {
  id: string;
  priority: 'CRITICAL' | 'HIGH' | 'MEDIUM' | 'LOW';
  category: 'VULNERABILITY' | 'CONFIGURATION' | 'PROCESS' | 'TRAINING';
  title: string;
  description: string;
  impact: string;
  effort: 'LOW' | 'MEDIUM' | 'HIGH';
  timeline: string;
  implementation: string[];
  norwegianContext?: string;
  nsmReference?: string;
}

export interface ScanMetrics {
  scanCoverage: {
    codebasePercentage: number;
    dependenciesScanned: number;
    secretsScanned: number;
    containersScanned: number;
  };
  
  performance: {
    scanDuration: number;
    filesProcessed: number;
    linesOfCode: number;
    processingRate: number; // files per second
  };
  
  accuracy: {
    falsePositiveRate: number;
    confidence: number;
    manualValidationRequired: number;
  };
  
  trends: {
    vulnerabilityTrend: 'IMPROVING' | 'STABLE' | 'DEGRADING';
    newVulnerabilities: number;
    fixedVulnerabilities: number;
    regressions: number;
  };
}

export class VulnerabilityScanner {
  private config: VulnerabilityScannerConfig;
  private scanHistory: ScanResult[] = [];

  constructor(config: VulnerabilityScannerConfig) {
    this.config = VulnerabilityScannerConfigSchema.parse(config);
  }

  /**
   * Perform comprehensive vulnerability scan
   */
  async performScan(options: {
    scanTypes?: ScanType[];
    severity?: VulnerabilitySeverity;
    quickScan?: boolean;
    outputPath?: string;
  } = {}): Promise<ScanResult> {
    const scanId = createHash('sha256')
      .update(`${Date.now()}-${this.config.organizationName}-VULN`)
      .digest('hex')
      .substring(0, 16);

    const startTime = Date.now();
    const scanTypes = options.scanTypes || this.config.scanTypes;

    console.log(chalk.cyan(`üîç Starting Vulnerability Scan (${scanId})`));
    console.log(chalk.gray(`Project: ${this.config.projectPath}`));
    console.log(chalk.gray(`Scan Types: ${scanTypes.join(', ')}`));
    console.log(chalk.gray(`Quick Scan: ${options.quickScan ? 'Yes' : 'No'}`));

    const vulnerabilities: Vulnerability[] = [];

    // 1. Static Code Analysis (SAST)
    if (scanTypes.includes('STATIC_CODE_ANALYSIS')) {
      console.log(chalk.blue('üîé Running Static Code Analysis...'));
      const sastVulns = await this.performStaticAnalysis(options.quickScan);
      vulnerabilities.push(...sastVulns);
    }

    // 2. Dependency Scanning (SCA)
    if (scanTypes.includes('DEPENDENCY_SCANNING')) {
      console.log(chalk.blue('üì¶ Scanning Dependencies...'));
      const depVulns = await this.performDependencyScanning();
      vulnerabilities.push(...depVulns);
    }

    // 3. Secret Scanning
    if (scanTypes.includes('SECRET_SCANNING')) {
      console.log(chalk.blue('üîê Scanning for Secrets...'));
      const secretVulns = await this.performSecretScanning();
      vulnerabilities.push(...secretVulns);
    }

    // 4. Container Scanning
    if (scanTypes.includes('CONTAINER_SCANNING')) {
      console.log(chalk.blue('üê≥ Scanning Containers...'));
      const containerVulns = await this.performContainerScanning();
      vulnerabilities.push(...containerVulns);
    }

    // 5. Infrastructure Scanning
    if (scanTypes.includes('INFRASTRUCTURE_SCANNING')) {
      console.log(chalk.blue('üèóÔ∏è  Scanning Infrastructure...'));
      const infraVulns = await this.performInfrastructureScanning();
      vulnerabilities.push(...infraVulns);
    }

    const duration = Date.now() - startTime;

    // Generate summary
    const summary = this.generateSummary(vulnerabilities);
    
    // OWASP breakdown
    const owaspBreakdown = this.generateOwaspBreakdown(vulnerabilities);
    
    // Compliance assessment
    const compliance = await this.assessCompliance(vulnerabilities);
    
    // Generate recommendations
    const recommendations = this.generateRecommendations(vulnerabilities, compliance);
    
    // Calculate metrics
    const metrics = await this.calculateMetrics(vulnerabilities, duration);

    const scanResult: ScanResult = {
      scanId,
      scanDate: new Date(),
      projectPath: this.config.projectPath,
      scanTypes,
      duration,
      summary,
      vulnerabilities,
      owaspBreakdown,
      compliance,
      recommendations,
      metrics,
    };

    this.scanHistory.push(scanResult);

    // Display results
    this.displayScanResults(scanResult);

    // Export results
    if (this.config.reporting.outputPath || options.outputPath) {
      await this.exportScanResults(scanResult, options.outputPath);
    }

    return scanResult;
  }

  /**
   * Perform static code analysis
   */
  private async performStaticAnalysis(quickScan?: boolean): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // ESLint Security Analysis
      if (this.config.tools.staticAnalysis.eslint) {
        const eslintVulns = await this.runEslintSecurity();
        vulnerabilities.push(...eslintVulns);
      }

      // Semgrep Analysis
      if (this.config.tools.staticAnalysis.semgrep && !quickScan) {
        const semgrepVulns = await this.runSemgrep();
        vulnerabilities.push(...semgrepVulns);
      }

      // Custom pattern matching for Norwegian-specific issues
      const norwegianVulns = await this.scanNorwegianSpecificIssues();
      vulnerabilities.push(...norwegianVulns);

    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Static analysis warning: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run ESLint with security rules
   */
  private async runEslintSecurity(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const eslintCommand = 'npx eslint --format json --ext .js,.ts,.jsx,.tsx . 2>/dev/null || true';
      const result = execSync(eslintCommand, { 
        cwd: this.config.projectPath,
        encoding: 'utf8',
        timeout: 60000,
      });

      if (result.trim()) {
        const eslintResults = JSON.parse(result);
        
        for (const fileResult of eslintResults) {
          for (const message of fileResult.messages) {
            if (this.isSecurityRule(message.ruleId)) {
              const vulnerability: Vulnerability = {
                id: `ESLINT-${createHash('md5').update(`${fileResult.filePath}-${message.line}-${message.ruleId}`).digest('hex').substring(0, 8)}`,
                title: `ESLint Security: ${message.ruleId}`,
                description: message.message,
                severity: this.mapEslintSeverity(message.severity),
                cvssScore: this.calculateCvssFromSeverity(this.mapEslintSeverity(message.severity)),
                file: path.relative(this.config.projectPath, fileResult.filePath),
                line: message.line,
                column: message.column,
                references: [`https://eslint.org/docs/rules/${message.ruleId}`],
                discoveredAt: new Date(),
                source: 'SAST',
                confidence: 'HIGH',
                exploitability: 'UNPROVEN',
                owaspCategory: this.mapToOwaspCategory(message.ruleId),
                remediation: {
                  description: `Fix ${message.ruleId} violation`,
                  effort: 'LOW',
                  priority: this.mapEslintSeverity(message.severity) === 'CRITICAL' ? 'CRITICAL' : 'MEDIUM',
                  steps: [
                    'Review the ESLint security rule documentation',
                    'Modify the code to comply with security best practices',
                    'Test the fix thoroughly',
                    'Run ESLint again to verify the fix',
                  ],
                },
              };

              vulnerabilities.push(vulnerability);
            }
          }
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  ESLint scan failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run Semgrep security analysis
   */
  private async runSemgrep(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const semgrepCommand = 'semgrep --config=auto --json --quiet';
      const result = execSync(semgrepCommand, {
        cwd: this.config.projectPath,
        encoding: 'utf8',
        timeout: 300000, // 5 minutes
      });

      const semgrepResults = JSON.parse(result);

      for (const finding of semgrepResults.results) {
        const vulnerability: Vulnerability = {
          id: `SEMGREP-${finding.check_id.replace(/[^a-zA-Z0-9]/g, '-')}-${createHash('md5').update(`${finding.path}-${finding.start.line}`).digest('hex').substring(0, 8)}`,
          title: `Semgrep: ${finding.check_id}`,
          description: finding.extra.message,
          severity: this.mapSemgrepSeverity(finding.extra.severity),
          cvssScore: this.calculateCvssFromSeverity(this.mapSemgrepSeverity(finding.extra.severity)),
          file: finding.path,
          line: finding.start.line,
          column: finding.start.col,
          references: finding.extra.references || [],
          discoveredAt: new Date(),
          source: 'SAST',
          confidence: 'HIGH',
          exploitability: 'UNPROVEN',
          owaspCategory: this.mapSemgrepToOwasp(finding.check_id),
          cweId: finding.extra.cwe?.toString(),
          remediation: {
            description: finding.extra.fix_regex ? 'Automated fix available' : 'Manual fix required',
            effort: 'MEDIUM',
            priority: this.mapSemgrepSeverity(finding.extra.severity) === 'CRITICAL' ? 'CRITICAL' : 'HIGH',
            steps: [
              'Review the Semgrep finding details',
              'Understand the security implication',
              'Apply the recommended fix',
              'Test the application thoroughly',
            ],
          },
        };

        vulnerabilities.push(vulnerability);
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Semgrep scan failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Perform dependency scanning
   */
  private async performDependencyScanning(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // npm audit
      if (this.config.tools.dependencyScanning.npm_audit) {
        const npmVulns = await this.runNpmAudit();
        vulnerabilities.push(...npmVulns);
      }

      // retire.js
      if (this.config.tools.dependencyScanning.retire_js) {
        const retireVulns = await this.runRetireJs();
        vulnerabilities.push(...retireVulns);
      }

    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Dependency scanning warning: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run npm audit
   */
  private async runNpmAudit(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const auditCommand = 'npm audit --json --audit-level=low 2>/dev/null || true';
      const result = execSync(auditCommand, {
        cwd: this.config.projectPath,
        encoding: 'utf8',
        timeout: 120000,
      });

      if (result.trim()) {
        const auditResults = JSON.parse(result);

        if (auditResults.vulnerabilities) {
          for (const [name, vuln] of Object.entries(auditResults.vulnerabilities)) {
            const vulnData = vuln as any;
            
            const vulnerability: Vulnerability = {
              id: `NPM-${name}-${vulnData.via[0]?.source || 'unknown'}`,
              cveId: vulnData.via[0]?.source,
              title: `npm: ${name} - ${vulnData.via[0]?.title || 'Vulnerability'}`,
              description: vulnData.via[0]?.title || 'Dependency vulnerability',
              severity: this.mapNpmSeverity(vulnData.severity),
              cvssScore: vulnData.via[0]?.cvss?.score || this.calculateCvssFromSeverity(this.mapNpmSeverity(vulnData.severity)),
              component: name,
              version: vulnData.via[0]?.range || 'unknown',
              fixedVersion: vulnData.fixAvailable ? 'available' : undefined,
              references: vulnData.via[0]?.url ? [vulnData.via[0].url] : [],
              discoveredAt: new Date(),
              source: 'SCA',
              confidence: 'HIGH',
              exploitability: 'UNPROVEN',
              owaspCategory: 'A06_VULNERABLE_COMPONENTS',
              remediation: {
                description: vulnData.fixAvailable ? 'Update dependency to fixed version' : 'No fix available - consider alternative',
                effort: vulnData.fixAvailable ? 'LOW' : 'HIGH',
                priority: this.mapNpmSeverity(vulnData.severity) === 'CRITICAL' ? 'CRITICAL' : 'HIGH',
                steps: vulnData.fixAvailable ? [
                  'Run npm audit fix to update dependencies',
                  'Test the application after update',
                  'Verify the vulnerability is resolved',
                ] : [
                  'Evaluate the risk of the vulnerability',
                  'Consider alternative dependencies',
                  'Implement compensating controls if necessary',
                ],
              },
            };

            vulnerabilities.push(vulnerability);
          }
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  npm audit failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run retire.js
   */
  private async runRetireJs(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const retireCommand = 'npx retire --outputformat json --outputpath /tmp/retire-output.json 2>/dev/null || true';
      execSync(retireCommand, {
        cwd: this.config.projectPath,
        timeout: 120000,
      });

      const retireResults = await fs.readJson('/tmp/retire-output.json').catch(() => ({ data: [] }));

      for (const result of retireResults.data || []) {
        for (const finding of result.results || []) {
          const vulnerability: Vulnerability = {
            id: `RETIRE-${finding.component}-${finding.version}`,
            title: `retire.js: ${finding.component} ${finding.version}`,
            description: finding.vulnerabilities?.[0]?.info?.join(', ') || 'Known vulnerable component',
            severity: 'HIGH',
            cvssScore: 7.5,
            component: finding.component,
            version: finding.version,
            references: finding.vulnerabilities?.[0]?.info || [],
            discoveredAt: new Date(),
            source: 'SCA',
            confidence: 'HIGH',
            exploitability: 'FUNCTIONAL',
            owaspCategory: 'A06_VULNERABLE_COMPONENTS',
            remediation: {
              description: 'Update to a non-vulnerable version',
              effort: 'MEDIUM',
              priority: 'HIGH',
              steps: [
                'Check for updated versions of the component',
                'Update the component to the latest version',
                'Test the application thoroughly',
              ],
            },
          };

          vulnerabilities.push(vulnerability);
        }
      }

      // Clean up temporary file
      await fs.remove('/tmp/retire-output.json').catch(() => {});
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  retire.js scan failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Perform secret scanning
   */
  private async performSecretScanning(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // TruffleHog
      if (this.config.tools.secretScanning.truffleHog) {
        const truffleVulns = await this.runTruffleHog();
        vulnerabilities.push(...truffleVulns);
      }

      // Pattern-based secret detection
      const patternVulns = await this.runPatternSecretDetection();
      vulnerabilities.push(...patternVulns);

    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Secret scanning warning: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run pattern-based secret detection
   */
  private async runPatternSecretDetection(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    const secretPatterns = [
      { name: 'AWS Access Key', pattern: /AKIA[0-9A-Z]{16}/, severity: 'CRITICAL' as VulnerabilitySeverity },
      { name: 'AWS Secret Key', pattern: /[0-9a-zA-Z/+]{40}/, severity: 'CRITICAL' as VulnerabilitySeverity },
      { name: 'GitHub Token', pattern: /gh[pousr]_[A-Za-z0-9_]{36}/, severity: 'HIGH' as VulnerabilitySeverity },
      { name: 'Private Key', pattern: /-----BEGIN [A-Z ]*PRIVATE KEY-----/, severity: 'CRITICAL' as VulnerabilitySeverity },
      { name: 'API Key', pattern: /api[_-]?key['":\s]*['"]\w+['"]/, severity: 'HIGH' as VulnerabilitySeverity },
      { name: 'Password', pattern: /password['":\s]*['"][^'"]{8,}['"]/, severity: 'MEDIUM' as VulnerabilitySeverity },
      { name: 'Norwegian Personal Number', pattern: /\b\d{11}\b/, severity: 'HIGH' as VulnerabilitySeverity },
    ];

    try {
      const files = await this.getSourceFiles();
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');
        const lines = content.split('\n');

        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          
          for (const { name, pattern, severity } of secretPatterns) {
            const matches = line.match(pattern);
            if (matches) {
              const vulnerability: Vulnerability = {
                id: `SECRET-${name.replace(/\s+/g, '-')}-${createHash('md5').update(`${file}-${lineIndex}`).digest('hex').substring(0, 8)}`,
                title: `Secret Detected: ${name}`,
                description: `Potential ${name} found in source code`,
                severity,
                cvssScore: this.calculateCvssFromSeverity(severity),
                file: path.relative(this.config.projectPath, file),
                line: lineIndex + 1,
                references: ['https://owasp.org/www-project-top-ten/2017/A3_2017-Sensitive_Data_Exposure'],
                discoveredAt: new Date(),
                source: 'SECRET',
                confidence: 'MEDIUM',
                exploitability: 'FUNCTIONAL',
                owaspCategory: 'A02_CRYPTOGRAPHIC_FAILURES',
                remediation: {
                  description: 'Remove hardcoded secrets and use secure storage',
                  effort: 'MEDIUM',
                  priority: severity === 'CRITICAL' ? 'CRITICAL' : 'HIGH',
                  steps: [
                    'Remove the hardcoded secret from source code',
                    'Use environment variables or secure key management',
                    'Rotate the exposed credential if applicable',
                    'Add the file to .gitignore if it contains secrets',
                  ],
                  norwegianGuidance: name === 'Norwegian Personal Number' ? 
                    'Personopplysninger m√• behandles i henhold til GDPR og norsk personopplysningslov' : undefined,
                },
              };

              vulnerabilities.push(vulnerability);
            }
          }
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Pattern secret detection failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run TruffleHog
   */
  private async runTruffleHog(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const truffleCommand = 'trufflehog filesystem --json .';
      const result = execSync(truffleCommand, {
        cwd: this.config.projectPath,
        encoding: 'utf8',
        timeout: 180000,
      });

      const lines = result.trim().split('\n').filter(line => line.trim());
      
      for (const line of lines) {
        try {
          const finding = JSON.parse(line);
          
          const vulnerability: Vulnerability = {
            id: `TRUFFLEHOG-${finding.DetectorName}-${createHash('md5').update(`${finding.SourceMetadata?.Data?.Filesystem?.file}-${finding.SourceMetadata?.Data?.Filesystem?.line}`).digest('hex').substring(0, 8)}`,
            title: `TruffleHog: ${finding.DetectorName}`,
            description: `Secret detected: ${finding.DetectorName}`,
            severity: finding.Verified ? 'CRITICAL' : 'HIGH',
            cvssScore: finding.Verified ? 9.0 : 7.0,
            file: finding.SourceMetadata?.Data?.Filesystem?.file,
            line: finding.SourceMetadata?.Data?.Filesystem?.line,
            references: ['https://github.com/trufflesecurity/trufflehog'],
            discoveredAt: new Date(),
            source: 'SECRET',
            confidence: finding.Verified ? 'HIGH' : 'MEDIUM',
            exploitability: finding.Verified ? 'FUNCTIONAL' : 'POC',
            owaspCategory: 'A02_CRYPTOGRAPHIC_FAILURES',
            remediation: {
              description: 'Remove secret and rotate if verified',
              effort: 'HIGH',
              priority: 'CRITICAL',
              steps: [
                'Immediately rotate the secret if verified',
                'Remove the secret from source code',
                'Use secure secret management',
                'Review git history for exposure',
              ],
            },
          };

          vulnerabilities.push(vulnerability);
        } catch (parseError) {
          // Skip invalid JSON lines
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  TruffleHog scan failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Perform container scanning
   */
  private async performContainerScanning(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      if (this.config.tools.containerScanning.trivy) {
        const trivyVulns = await this.runTrivy();
        vulnerabilities.push(...trivyVulns);
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Container scanning warning: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Run Trivy container scanning
   */
  private async runTrivy(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      // Look for Dockerfile
      const dockerfilePath = path.join(this.config.projectPath, 'Dockerfile');
      if (await fs.pathExists(dockerfilePath)) {
        const trivyCommand = 'trivy config --format json .';
        const result = execSync(trivyCommand, {
          cwd: this.config.projectPath,
          encoding: 'utf8',
          timeout: 300000,
        });

        const trivyResults = JSON.parse(result);

        for (const result of trivyResults.Results || []) {
          for (const misconfig of result.Misconfigurations || []) {
            const vulnerability: Vulnerability = {
              id: `TRIVY-${misconfig.ID}`,
              title: `Trivy: ${misconfig.Title}`,
              description: misconfig.Description,
              severity: this.mapTrivySeverity(misconfig.Severity),
              cvssScore: this.calculateCvssFromSeverity(this.mapTrivySeverity(misconfig.Severity)),
              file: result.Target,
              line: misconfig.CauseMetadata?.StartLine,
              references: misconfig.References || [],
              discoveredAt: new Date(),
              source: 'CONTAINER',
              confidence: 'HIGH',
              exploitability: 'UNPROVEN',
              remediation: {
                description: misconfig.Resolution || 'Fix container configuration',
                effort: 'MEDIUM',
                priority: this.mapTrivySeverity(misconfig.Severity) === 'CRITICAL' ? 'CRITICAL' : 'HIGH',
                steps: [
                  'Review the Dockerfile configuration',
                  'Apply the recommended fix',
                  'Rebuild and test the container',
                ],
              },
            };

            vulnerabilities.push(vulnerability);
          }
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Trivy scan failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Perform infrastructure scanning
   */
  private async performInfrastructureScanning(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    // Look for Infrastructure as Code files
    const iacFiles = await this.getIacFiles();
    
    for (const file of iacFiles) {
      const fileVulns = await this.scanIacFile(file);
      vulnerabilities.push(...fileVulns);
    }

    return vulnerabilities;
  }

  /**
   * Scan Norwegian-specific security issues
   */
  private async scanNorwegianSpecificIssues(): Promise<Vulnerability[]> {
    const vulnerabilities: Vulnerability[] = [];

    try {
      const files = await this.getSourceFiles();
      
      for (const file of files) {
        const content = await fs.readFile(file, 'utf8');
        const lines = content.split('\n');

        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          
          // Check for Norwegian personal data patterns
          if (/\b\d{11}\b/.test(line)) {
            const vulnerability: Vulnerability = {
              id: `NO-GDPR-${createHash('md5').update(`${file}-${lineIndex}`).digest('hex').substring(0, 8)}`,
              title: 'Norwegian Personal Data Detected',
              description: 'Potential Norwegian personal identification number (f√∏dselsnummer) found',
              severity: 'HIGH',
              cvssScore: 7.5,
              file: path.relative(this.config.projectPath, file),
              line: lineIndex + 1,
              references: ['https://www.datatilsynet.no/'],
              discoveredAt: new Date(),
              source: 'SAST',
              confidence: 'MEDIUM',
              exploitability: 'UNPROVEN',
              owaspCategory: 'A02_CRYPTOGRAPHIC_FAILURES',
              remediation: {
                description: 'Handle Norwegian personal data according to GDPR',
                effort: 'HIGH',
                priority: 'HIGH',
                steps: [
                  'Verify if this is actual personal data',
                  'Implement appropriate data protection measures',
                  'Ensure GDPR compliance for data processing',
                  'Consider data anonymization or pseudonymization',
                ],
                norwegianGuidance: 'M√• behandles i henhold til GDPR Art. 32 og norsk personopplysningslov',
              },
            };

            vulnerabilities.push(vulnerability);
          }
        }
      }
    } catch (error) {
      console.warn(chalk.yellow(`‚ö†Ô∏è  Norwegian-specific scanning failed: ${error}`));
    }

    return vulnerabilities;
  }

  /**
   * Helper Methods
   */
  private async getSourceFiles(): Promise<string[]> {
    const extensions = ['.js', '.ts', '.jsx', '.tsx', '.vue', '.py', '.java', '.cs', '.php', '.rb', '.go'];
    const files: string[] = [];

    const searchDir = async (dir: string) => {
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true });
        
        for (const entry of entries) {
          const fullPath = path.join(dir, entry.name);
          
          if (entry.isDirectory() && !entry.name.startsWith('.') && entry.name !== 'node_modules') {
            await searchDir(fullPath);
          } else if (entry.isFile() && extensions.some(ext => entry.name.endsWith(ext))) {
            files.push(fullPath);
          }
        }
      } catch (error) {
        // Skip directories we can't read
      }
    };

    await searchDir(this.config.projectPath);
    return files;
  }

  private async getIacFiles(): Promise<string[]> {
    const iacPatterns = ['*.tf', '*.yaml', '*.yml', 'Dockerfile*', '*.json'];
    const files: string[] = [];

    for (const pattern of iacPatterns) {
      try {
        const globFiles = await fs.readdir(this.config.projectPath);
        const matchingFiles = globFiles.filter(file => {
          const regex = new RegExp(pattern.replace('*', '.*'));
          return regex.test(file);
        });
        
        files.push(...matchingFiles.map(file => path.join(this.config.projectPath, file)));
      } catch (error) {
        // Continue with other patterns
      }
    }

    return files;
  }

  private async scanIacFile(file: string): Promise<Vulnerability[]> {
    // This would implement specific IaC scanning logic
    return [];
  }

  private isSecurityRule(ruleId: string | null): boolean {
    if (!ruleId) return false;
    
    const securityRules = [
      'security/',
      'no-eval',
      'no-implied-eval',
      'no-new-func',
      'no-script-url',
      'no-unsafe-innerHTML',
    ];

    return securityRules.some(rule => ruleId.includes(rule));
  }

  private mapEslintSeverity(severity: number): VulnerabilitySeverity {
    return severity === 2 ? 'HIGH' : 'MEDIUM';
  }

  private mapSemgrepSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toLowerCase()) {
      case 'error': return 'HIGH';
      case 'warning': return 'MEDIUM';
      case 'info': return 'LOW';
      default: return 'MEDIUM';
    }
  }

  private mapNpmSeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toLowerCase()) {
      case 'critical': return 'CRITICAL';
      case 'high': return 'HIGH';
      case 'moderate': return 'MEDIUM';
      case 'low': return 'LOW';
      default: return 'MEDIUM';
    }
  }

  private mapTrivySeverity(severity: string): VulnerabilitySeverity {
    switch (severity?.toUpperCase()) {
      case 'CRITICAL': return 'CRITICAL';
      case 'HIGH': return 'HIGH';
      case 'MEDIUM': return 'MEDIUM';
      case 'LOW': return 'LOW';
      default: return 'MEDIUM';
    }
  }

  private calculateCvssFromSeverity(severity: VulnerabilitySeverity): number {
    switch (severity) {
      case 'CRITICAL': return 9.5;
      case 'HIGH': return 7.5;
      case 'MEDIUM': return 5.0;
      case 'LOW': return 2.5;
      case 'INFO': return 0.0;
      default: return 5.0;
    }
  }

  private mapToOwaspCategory(ruleId: string): OWASPTop10 | undefined {
    const mappings: Record<string, OWASPTop10> = {
      'no-eval': 'A03_INJECTION',
      'no-implied-eval': 'A03_INJECTION',
      'security/detect-eval-with-expression': 'A03_INJECTION',
      'security/detect-unsafe-regex': 'A03_INJECTION',
      'security/detect-buffer-noassert': 'A06_VULNERABLE_COMPONENTS',
    };

    return mappings[ruleId];
  }

  private mapSemgrepToOwasp(checkId: string): OWASPTop10 | undefined {
    if (checkId.includes('injection')) return 'A03_INJECTION';
    if (checkId.includes('auth')) return 'A07_IDENTIFICATION_FAILURES';
    if (checkId.includes('crypto')) return 'A02_CRYPTOGRAPHIC_FAILURES';
    if (checkId.includes('access')) return 'A01_BROKEN_ACCESS_CONTROL';
    return undefined;
  }

  private generateSummary(vulnerabilities: Vulnerability[]): ScanResult['summary'] {
    const summary = {
      totalVulnerabilities: vulnerabilities.length,
      criticalCount: vulnerabilities.filter(v => v.severity === 'CRITICAL').length,
      highCount: vulnerabilities.filter(v => v.severity === 'HIGH').length,
      mediumCount: vulnerabilities.filter(v => v.severity === 'MEDIUM').length,
      lowCount: vulnerabilities.filter(v => v.severity === 'LOW').length,
      infoCount: vulnerabilities.filter(v => v.severity === 'INFO').length,
      fixableCount: vulnerabilities.filter(v => v.fixedVersion || v.remediation?.effort === 'LOW').length,
    };

    return summary;
  }

  private generateOwaspBreakdown(vulnerabilities: Vulnerability[]): ScanResult['owaspBreakdown'] {
    const breakdown: ScanResult['owaspBreakdown'] = {};

    for (const vuln of vulnerabilities) {
      if (vuln.owaspCategory) {
        if (!breakdown[vuln.owaspCategory]) {
          breakdown[vuln.owaspCategory] = {
            count: 0,
            severity: 'LOW',
            vulnerabilities: [],
          };
        }

        breakdown[vuln.owaspCategory].count++;
        breakdown[vuln.owaspCategory].vulnerabilities.push(vuln.id);
        
        // Update severity to highest found
        if (this.severityWeight(vuln.severity) > this.severityWeight(breakdown[vuln.owaspCategory].severity)) {
          breakdown[vuln.owaspCategory].severity = vuln.severity;
        }
      }
    }

    return breakdown;
  }

  private severityWeight(severity: VulnerabilitySeverity): number {
    switch (severity) {
      case 'CRITICAL': return 4;
      case 'HIGH': return 3;
      case 'MEDIUM': return 2;
      case 'LOW': return 1;
      case 'INFO': return 0;
      default: return 0;
    }
  }

  private async assessCompliance(vulnerabilities: Vulnerability[]): Promise<ScanResult['compliance']> {
    const criticalVulns = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    const highVulns = vulnerabilities.filter(v => v.severity === 'HIGH').length;
    
    const hasGdprImpact = vulnerabilities.some(v => 
      v.remediation?.norwegianGuidance?.includes('GDPR') || 
      v.description.includes('personal')
    );

    return {
      nsmCompliant: criticalVulns === 0 && highVulns <= 5,
      gdprImpact: hasGdprImpact,
      norwegianRequirements: {
        dataProtection: !hasGdprImpact,
        incidentReporting: criticalVulns === 0,
        securityMeasures: criticalVulns === 0 && highVulns <= 2,
      },
    };
  }

  private generateRecommendations(
    vulnerabilities: Vulnerability[],
    compliance: ScanResult['compliance']
  ): SecurityRecommendation[] {
    const recommendations: SecurityRecommendation[] = [];

    // Critical vulnerabilities
    const criticalCount = vulnerabilities.filter(v => v.severity === 'CRITICAL').length;
    if (criticalCount > 0) {
      recommendations.push({
        id: 'VULN-REC-001',
        priority: 'CRITICAL',
        category: 'VULNERABILITY',
        title: 'Address Critical Vulnerabilities Immediately',
        description: `${criticalCount} critical vulnerabilities require immediate attention.`,
        impact: 'High risk of security breach and data compromise',
        effort: 'HIGH',
        timeline: '1-3 days',
        implementation: [
          'Prioritize critical vulnerabilities by exploitability',
          'Apply security patches immediately',
          'Implement temporary mitigations if patches unavailable',
          'Verify fixes through re-scanning',
        ],
        norwegianContext: 'Kritiske s√•rbarheter kan kreve NSM-rapportering hvis de p√•virker nasjonal sikkerhet',
      });
    }

    // GDPR compliance
    if (compliance.gdprImpact) {
      recommendations.push({
        id: 'VULN-REC-002',
        priority: 'HIGH',
        category: 'PROCESS',
        title: 'Address GDPR Data Protection Issues',
        description: 'Personal data vulnerabilities identified that may violate GDPR requirements.',
        impact: 'Potential GDPR violations and regulatory fines',
        effort: 'MEDIUM',
        timeline: '1-2 weeks',
        implementation: [
          'Review all personal data handling processes',
          'Implement data protection by design',
          'Ensure encryption of personal data',
          'Update privacy notices and consent management',
        ],
        norwegianContext: 'M√• f√∏lge norsk personopplysningslov og GDPR Art. 32 krav til tekniske tiltak',
        nsmReference: 'NSM Grunnprinsipper for IKT-sikkerhet - Personvern',
      });
    }

    return recommendations;
  }

  private async calculateMetrics(vulnerabilities: Vulnerability[], duration: number): Promise<ScanMetrics> {
    const sourceFiles = await this.getSourceFiles();
    
    return {
      scanCoverage: {
        codebasePercentage: 85, // Estimated
        dependenciesScanned: vulnerabilities.filter(v => v.source === 'SCA').length,
        secretsScanned: vulnerabilities.filter(v => v.source === 'SECRET').length,
        containersScanned: vulnerabilities.filter(v => v.source === 'CONTAINER').length,
      },
      performance: {
        scanDuration: duration,
        filesProcessed: sourceFiles.length,
        linesOfCode: sourceFiles.length * 100, // Estimated
        processingRate: sourceFiles.length / (duration / 1000),
      },
      accuracy: {
        falsePositiveRate: 0.15, // Estimated 15%
        confidence: 0.85,
        manualValidationRequired: vulnerabilities.filter(v => v.confidence === 'LOW').length,
      },
      trends: {
        vulnerabilityTrend: this.calculateTrend(),
        newVulnerabilities: vulnerabilities.length,
        fixedVulnerabilities: 0,
        regressions: 0,
      },
    };
  }

  private calculateTrend(): 'IMPROVING' | 'STABLE' | 'DEGRADING' {
    if (this.scanHistory.length < 2) return 'STABLE';
    
    const current = this.scanHistory[this.scanHistory.length - 1];
    const previous = this.scanHistory[this.scanHistory.length - 2];
    
    const currentScore = current.summary.criticalCount * 4 + current.summary.highCount * 2 + current.summary.mediumCount;
    const previousScore = previous.summary.criticalCount * 4 + previous.summary.highCount * 2 + previous.summary.mediumCount;
    
    if (currentScore < previousScore * 0.9) return 'IMPROVING';
    if (currentScore > previousScore * 1.1) return 'DEGRADING';
    return 'STABLE';
  }

  private displayScanResults(result: ScanResult): void {
    console.log(chalk.cyan('\nüîç Vulnerability Scan Results\n'));

    // Summary
    console.log(chalk.cyan('üìä Summary:'));
    console.log(chalk.gray(`  Total Vulnerabilities: ${result.summary.totalVulnerabilities}`));
    console.log(chalk.red(`  Critical: ${result.summary.criticalCount}`));
    console.log(chalk.yellow(`  High: ${result.summary.highCount}`));
    console.log(chalk.blue(`  Medium: ${result.summary.mediumCount}`));
    console.log(chalk.green(`  Low: ${result.summary.lowCount}`));
    console.log(chalk.gray(`  Fixable: ${result.summary.fixableCount}`));

    // Compliance
    console.log(chalk.cyan('\nüõ°Ô∏è  Compliance Status:'));
    console.log(`  NSM Compliant: ${result.compliance.nsmCompliant ? chalk.green('Yes') : chalk.red('No')}`);
    console.log(`  GDPR Impact: ${result.compliance.gdprImpact ? chalk.red('Yes') : chalk.green('No')}`);

    // Performance
    console.log(chalk.cyan('\n‚ö° Performance:'));
    console.log(chalk.gray(`  Scan Duration: ${(result.duration / 1000).toFixed(1)}s`));
    console.log(chalk.gray(`  Files Processed: ${result.metrics.performance.filesProcessed}`));
    console.log(chalk.gray(`  Processing Rate: ${result.metrics.performance.processingRate.toFixed(1)} files/sec`));

    console.log(chalk.gray(`\nüìÑ Detailed report available at: ${this.config.reporting.outputPath}/vulnerability-scan-${result.scanId}.json`));
  }

  async exportScanResults(result: ScanResult, outputPath?: string): Promise<string> {
    const reportPath = outputPath || path.join(this.config.reporting.outputPath, `vulnerability-scan-${result.scanId}.json`);
    await fs.ensureDir(path.dirname(reportPath));
    await fs.writeJson(reportPath, result, { spaces: 2 });

    // Generate HTML report if requested
    if (this.config.reporting.format === 'html') {
      const htmlPath = reportPath.replace('.json', '.html');
      await this.generateHtmlReport(result, htmlPath);
    }

    console.log(chalk.green(`\nüìã Vulnerability scan report exported: ${reportPath}`));
    return reportPath;
  }

  private async generateHtmlReport(result: ScanResult, htmlPath: string): Promise<void> {
    const html = `
<!DOCTYPE html>
<html>
<head>
    <title>Vulnerability Scan Report - ${result.scanId}</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .critical { color: #d73a49; }
        .high { color: #f66a0a; }
        .medium { color: #e1a336; }
        .low { color: #28a745; }
        .vulnerability { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .summary { background: #f8f9fa; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
    </style>
</head>
<body>
    <h1>Vulnerability Scan Report</h1>
    <div class="summary">
        <h2>Summary</h2>
        <p><strong>Scan ID:</strong> ${result.scanId}</p>
        <p><strong>Date:</strong> ${result.scanDate.toISOString()}</p>
        <p><strong>Project:</strong> ${result.projectPath}</p>
        <p><strong>Duration:</strong> ${(result.duration / 1000).toFixed(1)}s</p>
        <p><strong>Total Vulnerabilities:</strong> ${result.summary.totalVulnerabilities}</p>
        <p><strong>Critical:</strong> <span class="critical">${result.summary.criticalCount}</span></p>
        <p><strong>High:</strong> <span class="high">${result.summary.highCount}</span></p>
        <p><strong>Medium:</strong> <span class="medium">${result.summary.mediumCount}</span></p>
        <p><strong>Low:</strong> <span class="low">${result.summary.lowCount}</span></p>
    </div>

    <h2>Vulnerabilities</h2>
    ${result.vulnerabilities.map(vuln => `
        <div class="vulnerability">
            <h3 class="${vuln.severity.toLowerCase()}">${vuln.title}</h3>
            <p><strong>ID:</strong> ${vuln.id}</p>
            <p><strong>Severity:</strong> <span class="${vuln.severity.toLowerCase()}">${vuln.severity}</span></p>
            <p><strong>CVSS Score:</strong> ${vuln.cvssScore}</p>
            <p><strong>Description:</strong> ${vuln.description}</p>
            ${vuln.file ? `<p><strong>File:</strong> ${vuln.file}:${vuln.line || 'unknown'}</p>` : ''}
            ${vuln.remediation ? `
                <div>
                    <strong>Remediation:</strong>
                    <p>${vuln.remediation.description}</p>
                    <ul>
                        ${vuln.remediation.steps.map(step => `<li>${step}</li>`).join('')}
                    </ul>
                </div>
            ` : ''}
        </div>
    `).join('')}

    <footer>
        <p><em>Generated by Xaheen Vulnerability Scanner - ${new Date().toISOString()}</em></p>
    </footer>
</body>
</html>
    `;

    await fs.writeFile(htmlPath, html);
  }
}