import * as fs from 'fs-extra';
import * as path from 'path';
import { z } from 'zod';
import { exec } from 'node:child_process';
import { promisify } from 'node:util';

const execAsync = promisify(exec);

// Schema for Docker configuration
const DockerConfigSchema = z.object({
  baseImage: z.object({
    node: z.string().default('node:20-alpine'),
    nodeSlim: z.string().default('node:20-slim'),
    distroless: z.string().default('gcr.io/distroless/nodejs20-debian12'),
    alpine: z.string().default('alpine:3.19'),
  }).default({}),
  multiStage: z.object({
    enabled: z.boolean().default(true),
    stages: z.array(z.string()).default(['dependencies', 'build', 'runtime']),
  }).default({}),
  security: z.object({
    nonRootUser: z.boolean().default(true),
    readOnlyRootFs: z.boolean().default(true),
    dropCapabilities: z.boolean().default(true),
    scanImage: z.boolean().default(true),
    minimizeAttackSurface: z.boolean().default(true),
  }).default({}),
  optimization: z.object({
    layerCaching: z.boolean().default(true),
    minimizeImageSize: z.boolean().default(true),
    useDockerignore: z.boolean().default(true),
    parallelBuilds: z.boolean().default(true),
  }).default({}),
  healthCheck: z.object({
    enabled: z.boolean().default(true),
    endpoint: z.string().default('/health'),
    interval: z.string().default('30s'),
    timeout: z.string().default('10s'),
    retries: z.number().default(3),
    startPeriod: z.string().default('60s'),
  }).default({}),
  environment: z.object({
    nodeEnv: z.string().default('production'),
    port: z.number().default(3000),
    customVars: z.record(z.string()).default({}),
  }).default({}),
  labels: z.record(z.string()).default({}),
});

export type DockerConfig = z.infer<typeof DockerConfigSchema>;

export interface DockerBuildOptions {
  context?: string;
  dockerfile?: string;
  tag?: string;
  platform?: string[];
  buildArgs?: Record<string, string>;
  target?: string;
  cache?: boolean;
  push?: boolean;
  registry?: string;
}

export interface DockerImageInfo {
  repository: string;
  tag: string;
  imageId: string;
  size: string;
  created: string;
  platform?: string;
  digest?: string;
}

export class DockerService {
  private config: DockerConfig;

  constructor(config?: Partial<DockerConfig>) {
    this.config = DockerConfigSchema.parse(config || {});
  }

  /**
   * Generate production-ready Dockerfile
   */
  generateDockerfile(options: {
    projectType: 'nodejs' | 'nextjs' | 'nestjs' | 'express';
    packageManager: 'npm' | 'yarn' | 'pnpm' | 'bun';
    distroless?: boolean;
    norwegianCompliance?: boolean;
  }): string {
    const { projectType, packageManager, distroless = false, norwegianCompliance = false } = options;

    // Choose base image
    const baseImage = distroless ? this.config.baseImage.distroless : this.config.baseImage.node;
    const buildImage = this.config.baseImage.node;

    let dockerfile = '';

    // Multi-stage build
    if (this.config.multiStage.enabled) {
      dockerfile += this.generateMultiStageDockerfile(projectType, packageManager, baseImage, buildImage, norwegianCompliance);
    } else {
      dockerfile += this.generateSingleStageDockerfile(projectType, packageManager, baseImage, norwegianCompliance);
    }

    return dockerfile;
  }

  /**
   * Generate multi-stage Dockerfile with security hardening
   */
  private generateMultiStageDockerfile(
    projectType: string,
    packageManager: string,
    baseImage: string,
    buildImage: string,
    norwegianCompliance: boolean
  ): string {
    const isDistroless = baseImage.includes('distroless');
    const nodeUser = this.config.security.nonRootUser;
    const port = this.config.environment.port;

    return `# ================================
# Production-Ready Multi-Stage Dockerfile
# Generated by Xaheen CLI v${process.env.npm_package_version || '5.0.0'}
# Norwegian Enterprise Compliance: ${norwegianCompliance ? 'Enabled' : 'Disabled'}
# ================================

# Stage 1: Dependencies
FROM ${buildImage} AS dependencies

# Set working directory
WORKDIR /app

# Install security updates and minimal dependencies
RUN apk update && apk upgrade && \\
    apk add --no-cache \\
    dumb-init \\
    ca-certificates && \\
    rm -rf /var/cache/apk/*

# Create non-root user for security
${nodeUser ? `RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nextjs -u 1001 -G nodejs` : ''}

# Copy package files
COPY package*.json ./
${packageManager === 'yarn' ? 'COPY yarn.lock ./' : ''}
${packageManager === 'pnpm' ? 'COPY pnpm-lock.yaml ./' : ''}
${packageManager === 'bun' ? 'COPY bun.lockb ./' : ''}

# Install dependencies with security and performance optimizations
RUN ${this.getInstallCommand(packageManager, 'dependencies')} && \\
    npm audit fix --force || true && \\
    ${packageManager === 'npm' ? 'npm cache clean --force' : ''} && \\
    rm -rf /tmp/* /var/tmp/*

# Stage 2: Build
FROM dependencies AS build

# Copy source code
COPY . .

# Build application
RUN ${this.getBuildCommand(projectType, packageManager)} && \\
    ${packageManager !== 'npm' ? `${packageManager} cache clean` : 'npm cache clean --force'} && \\
    rm -rf /tmp/* /var/tmp/*

# Stage 3: Runtime
FROM ${isDistroless ? baseImage : buildImage} AS runtime

# Security labels for Norwegian compliance
${norwegianCompliance ? this.generateNorwegianComplianceLabels() : ''}

# Set environment variables
ENV NODE_ENV=${this.config.environment.nodeEnv}
ENV PORT=${port}
ENV NODE_OPTIONS="--enable-source-maps --max-old-space-size=2048"
${Object.entries(this.config.environment.customVars).map(([key, value]) => `ENV ${key}=${value}`).join('\n')}

# Set working directory
WORKDIR /app

${!isDistroless ? `
# Install runtime dependencies and security updates
RUN apk update && apk upgrade && \\
    apk add --no-cache \\
    dumb-init \\
    ca-certificates \\
    tzdata && \\
    rm -rf /var/cache/apk/*

# Create non-root user
${nodeUser ? `RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nextjs -u 1001 -G nodejs` : ''}
` : ''}

# Copy built application from build stage
COPY --from=build --chown=${nodeUser ? 'nextjs:nodejs' : 'root:root'} /app/dist ./dist
COPY --from=build --chown=${nodeUser ? 'nextjs:nodejs' : 'root:root'} /app/package*.json ./
${projectType === 'nextjs' ? `COPY --from=build --chown=${nodeUser ? 'nextjs:nodejs' : 'root:root'} /app/.next ./.next` : ''}
${projectType === 'nextjs' ? `COPY --from=build --chown=${nodeUser ? 'nextjs:nodejs' : 'root:root'} /app/public ./public` : ''}

# Install only production dependencies
RUN ${this.getInstallCommand(packageManager, 'production')} && \\
    ${packageManager === 'npm' ? 'npm cache clean --force' : ''} && \\
    rm -rf /tmp/* /var/tmp/*

# Security: Change ownership and permissions
${nodeUser ? `RUN chown -R nextjs:nodejs /app && \\
    chmod -R 755 /app` : ''}

# Health check configuration
${this.config.healthCheck.enabled ? `HEALTHCHECK --interval=${this.config.healthCheck.interval} \\
            --timeout=${this.config.healthCheck.timeout} \\
            --retries=${this.config.healthCheck.retries} \\
            --start-period=${this.config.healthCheck.startPeriod} \\
            CMD ${this.getHealthCheckCommand(projectType, port)}` : ''}

# Security: Switch to non-root user
${nodeUser && !isDistroless ? 'USER nextjs:nodejs' : ''}

# Expose port
EXPOSE ${port}

# Security: Run with dumb-init for proper signal handling
${!isDistroless ? `ENTRYPOINT ["dumb-init", "--"]` : ''}

# Start application
CMD [${this.getStartCommand(projectType, packageManager)}]

# Security and compliance metadata
${this.generateSecurityLabels()}
`;
  }

  /**
   * Generate single-stage Dockerfile (for development)
   */
  private generateSingleStageDockerfile(
    projectType: string,
    packageManager: string,
    baseImage: string,
    norwegianCompliance: boolean
  ): string {
    const nodeUser = this.config.security.nonRootUser;
    const port = this.config.environment.port;

    return `# ================================
# Development Dockerfile
# Generated by Xaheen CLI v${process.env.npm_package_version || '5.0.0'}
# Norwegian Enterprise Compliance: ${norwegianCompliance ? 'Enabled' : 'Disabled'}
# ================================

FROM ${baseImage}

# Security labels for Norwegian compliance
${norwegianCompliance ? this.generateNorwegianComplianceLabels() : ''}

# Set working directory
WORKDIR /app

# Install system dependencies with security updates
RUN apk update && apk upgrade && \\
    apk add --no-cache \\
    dumb-init \\
    ca-certificates && \\
    rm -rf /var/cache/apk/*

# Create non-root user for security
${nodeUser ? `RUN addgroup -g 1001 -S nodejs && \\
    adduser -S nextjs -u 1001 -G nodejs` : ''}

# Copy package files
COPY package*.json ./
${packageManager === 'yarn' ? 'COPY yarn.lock ./' : ''}
${packageManager === 'pnpm' ? 'COPY pnpm-lock.yaml ./' : ''}
${packageManager === 'bun' ? 'COPY bun.lockb ./' : ''}

# Install dependencies
RUN ${this.getInstallCommand(packageManager, 'all')}

# Copy source code
COPY . .

# Build application
RUN ${this.getBuildCommand(projectType, packageManager)}

# Security: Change ownership and permissions
${nodeUser ? `RUN chown -R nextjs:nodejs /app && \\
    chmod -R 755 /app` : ''}

# Set environment variables
ENV NODE_ENV=${this.config.environment.nodeEnv}
ENV PORT=${port}

# Health check
${this.config.healthCheck.enabled ? `HEALTHCHECK --interval=${this.config.healthCheck.interval} \\
            --timeout=${this.config.healthCheck.timeout} \\
            --retries=${this.config.healthCheck.retries} \\
            CMD ${this.getHealthCheckCommand(projectType, port)}` : ''}

# Security: Switch to non-root user
${nodeUser ? 'USER nextjs:nodejs' : ''}

# Expose port
EXPOSE ${port}

# Start application
ENTRYPOINT ["dumb-init", "--"]
CMD [${this.getStartCommand(projectType, packageManager)}]

# Security metadata
${this.generateSecurityLabels()}
`;
  }

  /**
   * Generate .dockerignore file
   */
  generateDockerignore(): string {
    return `# ================================
# .dockerignore
# Generated by Xaheen CLI
# ================================

# Development files
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*
.npm
.yarn

# Build artifacts
dist
build
.next
.nuxt
.output
out

# Environment files
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# IDE files
.vscode
.idea
*.swp
*.swo

# OS files
.DS_Store
.DS_Store?
._*
.Spotlight-V100
.Trashes
ehthumbs.db
Thumbs.db

# Git
.git
.gitignore
.github

# Docker
Dockerfile*
docker-compose*.yml
.dockerignore

# Documentation
README.md
CHANGELOG.md
docs/
*.md

# Testing
coverage/
.nyc_output
*.lcov
test-results/
playwright-report/

# Logs
logs
*.log

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Temporary folders
tmp/
temp/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next

# Nuxt.js build / generate output
.nuxt
dist

# Storybook build outputs
.out
.storybook-out

# Temporary folders
.tmp
.cache
`;
  }

  /**
   * Build Docker image with optimizations
   */
  async buildImage(options: DockerBuildOptions): Promise<DockerImageInfo> {
    try {
      const {
        context = '.',
        dockerfile = 'Dockerfile',
        tag,
        platform = ['linux/amd64', 'linux/arm64'],
        buildArgs = {},
        target,
        cache = true,
        push = false,
        registry
      } = options;

      if (!tag) {
        throw new Error('Image tag is required');
      }

      // Build command
      let buildCmd = `docker buildx build`;
      
      // Context and dockerfile
      buildCmd += ` --file ${dockerfile} ${context}`;
      
      // Multi-platform build
      if (platform.length > 1) {
        buildCmd += ` --platform ${platform.join(',')}`;
      }
      
      // Build arguments
      Object.entries(buildArgs).forEach(([key, value]) => {
        buildCmd += ` --build-arg ${key}=${value}`;
      });
      
      // Target stage for multi-stage builds
      if (target) {
        buildCmd += ` --target ${target}`;
      }
      
      // Caching
      if (cache) {
        buildCmd += ` --cache-from type=local,src=/tmp/.buildx-cache --cache-to type=local,dest=/tmp/.buildx-cache-new,mode=max`;
      }
      
      // Tag
      buildCmd += ` --tag ${tag}`;
      
      // Push to registry
      if (push && registry) {
        buildCmd += ` --push`;
      } else {
        buildCmd += ` --load`;
      }

      console.log(`Building Docker image: ${tag}`);
      console.log(`Command: ${buildCmd}`);

      // Execute build
      const { stdout, stderr } = await execAsync(buildCmd);
      
      if (stderr && !stderr.includes('WARNING')) {
        throw new Error(`Build failed: ${stderr}`);
      }

      // Get image information
      const imageInfo = await this.getImageInfo(tag);
      
      console.log(`Successfully built image: ${tag}`);
      console.log(`Image size: ${imageInfo.size}`);

      return imageInfo;
    } catch (error) {
      throw new Error(`Failed to build Docker image: ${error}`);
    }
  }

  /**
   * Scan Docker image for vulnerabilities
   */
  async scanImage(imageTag: string): Promise<{
    vulnerabilities: any[];
    highSeverity: number;
    mediumSeverity: number;
    lowSeverity: number;
    passed: boolean;
  }> {
    try {
      // Try multiple scanners
      const scanners = ['trivy', 'grype', 'snyk'];
      let scanResult = null;

      for (const scanner of scanners) {
        try {
          scanResult = await this.runScanner(scanner, imageTag);
          break;
        } catch (error) {
          console.warn(`Scanner ${scanner} not available: ${error}`);
        }
      }

      if (!scanResult) {
        console.warn('No vulnerability scanners available, skipping scan');
        return {
          vulnerabilities: [],
          highSeverity: 0,
          mediumSeverity: 0,
          lowSeverity: 0,
          passed: true
        };
      }

      return scanResult;
    } catch (error) {
      throw new Error(`Failed to scan image: ${error}`);
    }
  }

  /**
   * Get Docker image information
   */
  async getImageInfo(imageTag: string): Promise<DockerImageInfo> {
    try {
      const { stdout } = await execAsync(`docker images ${imageTag} --format "table {{.Repository}}\\t{{.Tag}}\\t{{.ID}}\\t{{.Size}}\\t{{.CreatedAt}}" --no-trunc`);
      
      const lines = stdout.trim().split('\n');
      if (lines.length < 2) {
        throw new Error(`Image ${imageTag} not found`);
      }

      const [repository, tag, imageId, size, created] = lines[1].split('\t');

      return {
        repository,
        tag,
        imageId,
        size,
        created
      };
    } catch (error) {
      throw new Error(`Failed to get image info: ${error}`);
    }
  }

  // Private helper methods
  private getInstallCommand(packageManager: string, type: 'dependencies' | 'production' | 'all'): string {
    switch (packageManager) {
      case 'npm':
        return type === 'production' ? 'npm ci --only=production' : 'npm ci';
      case 'yarn':
        return type === 'production' ? 'yarn install --frozen-lockfile --production' : 'yarn install --frozen-lockfile';
      case 'pnpm':
        return type === 'production' ? 'pnpm install --frozen-lockfile --prod' : 'pnpm install --frozen-lockfile';
      case 'bun':
        return type === 'production' ? 'bun install --production' : 'bun install';
      default:
        return 'npm ci';
    }
  }

  private getBuildCommand(projectType: string, packageManager: string): string {
    const pm = packageManager === 'npm' ? 'npm run' : packageManager;
    
    switch (projectType) {
      case 'nextjs':
        return `${pm} build`;
      case 'nestjs':
        return `${pm} build`;
      case 'express':
      case 'nodejs':
      default:
        return `${pm} build`;
    }
  }

  private getStartCommand(projectType: string, packageManager: string): string {
    const pm = packageManager === 'npm' ? 'npm' : packageManager;
    
    switch (projectType) {
      case 'nextjs':
        return `"node", "server.js"`;
      case 'nestjs':
        return `"node", "dist/main.js"`;
      case 'express':
      case 'nodejs':
      default:
        return `"node", "dist/index.js"`;
    }
  }

  private getHealthCheckCommand(projectType: string, port: number): string {
    const endpoint = this.config.healthCheck.endpoint;
    return `curl -f http://localhost:${port}${endpoint} || exit 1`;
  }

  private generateSecurityLabels(): string {
    const labels = {
      'org.opencontainers.image.vendor': 'Xala Technologies',
      'org.opencontainers.image.title': 'Xaheen Application',
      'org.opencontainers.image.description': 'Production-ready containerized application',
      'org.opencontainers.image.version': '${VERSION}',
      'org.opencontainers.image.created': '${BUILD_DATE}',
      'org.opencontainers.image.revision': '${GIT_COMMIT}',
      'org.opencontainers.image.source': '${GIT_URL}',
      'security.scan.enabled': 'true',
      'security.non-root-user': this.config.security.nonRootUser.toString(),
      'security.read-only-root-fs': this.config.security.readOnlyRootFs.toString(),
      ...this.config.labels
    };

    return Object.entries(labels)
      .map(([key, value]) => `LABEL ${key}="${value}"`)
      .join('\n');
  }

  private generateNorwegianComplianceLabels(): string {
    return `# Norwegian Enterprise Compliance Labels
LABEL compliance.norway.enabled="true"
LABEL compliance.gdpr.enabled="true"
LABEL compliance.nsm.classification="OPEN"
LABEL compliance.audit.enabled="true"
LABEL compliance.logging.enabled="true"
LABEL compliance.encryption.at-rest="true"
LABEL compliance.encryption.in-transit="true"
`;
  }

  private async runScanner(scanner: string, imageTag: string): Promise<any> {
    switch (scanner) {
      case 'trivy':
        const { stdout } = await execAsync(`trivy image --format json ${imageTag}`);
        return this.parseTrivyOutput(stdout);
      case 'grype':
        const { stdout: grypeOutput } = await execAsync(`grype ${imageTag} -o json`);
        return this.parseGrypeOutput(grypeOutput);
      case 'snyk':
        const { stdout: snykOutput } = await execAsync(`snyk container test ${imageTag} --json`);
        return this.parseSnykOutput(snykOutput);
      default:
        throw new Error(`Unknown scanner: ${scanner}`);
    }
  }

  private parseTrivyOutput(output: string): any {
    const result = JSON.parse(output);
    const vulnerabilities = result.Results?.[0]?.Vulnerabilities || [];
    
    const counts = vulnerabilities.reduce((acc: any, vuln: any) => {
      const severity = vuln.Vulnerability?.Severity?.toLowerCase() || 'unknown';
      acc[severity] = (acc[severity] || 0) + 1;
      return acc;
    }, {});

    return {
      vulnerabilities,
      highSeverity: counts.critical + counts.high || 0,
      mediumSeverity: counts.medium || 0,
      lowSeverity: counts.low || 0,
      passed: (counts.critical || 0) === 0 && (counts.high || 0) < 5
    };
  }

  private parseGrypeOutput(output: string): any {
    const result = JSON.parse(output);
    const vulnerabilities = result.matches || [];
    
    const counts = vulnerabilities.reduce((acc: any, vuln: any) => {
      const severity = vuln.vulnerability?.severity?.toLowerCase() || 'unknown';
      acc[severity] = (acc[severity] || 0) + 1;
      return acc;
    }, {});

    return {
      vulnerabilities,
      highSeverity: counts.critical + counts.high || 0,
      mediumSeverity: counts.medium || 0,
      lowSeverity: counts.low || 0,
      passed: (counts.critical || 0) === 0 && (counts.high || 0) < 5
    };
  }

  private parseSnykOutput(output: string): any {
    const result = JSON.parse(output);
    const vulnerabilities = result.vulnerabilities || [];
    
    const counts = vulnerabilities.reduce((acc: any, vuln: any) => {
      const severity = vuln.severity?.toLowerCase() || 'unknown';
      acc[severity] = (acc[severity] || 0) + 1;
      return acc;
    }, {});

    return {
      vulnerabilities,
      highSeverity: counts.critical + counts.high || 0,
      mediumSeverity: counts.medium || 0,
      lowSeverity: counts.low || 0,
      passed: (counts.critical || 0) === 0 && (counts.high || 0) < 5
    };
  }
}

// Export default configuration
export const defaultDockerConfig: DockerConfig = DockerConfigSchema.parse({});