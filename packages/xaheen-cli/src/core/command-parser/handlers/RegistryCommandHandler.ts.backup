/**
 * Registry Command Handler
 * Handles registry-related commands
 */

import chalk from 'chalk';
import ora from 'ora';
import { join, resolve } from 'path';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import fetch from 'node-fetch';
import { z } from 'zod';
import { logger } from '../../../utils/logger.js';
import { CLIError, CLICommand } from '../../../types/index.js';
import { exec } from 'child_process';
import { promisify } from 'util';
import express from 'express';
import cors from 'cors';
import { ICommandHandler } from '../interfaces/ICommandHandler.js';

const execAsync = promisify(exec);

// Registry item schema
const RegistryItemSchema = z.object({
  $schema: z.string().optional(),
  name: z.string(),
  type: z.enum([
    'registry:component',
    'registry:block',
    'registry:style',
    'registry:hook',
    'registry:utils',
    'registry:theme'
  ]),
  title: z.string().optional(),
  description: z.string().optional(),
  category: z.string().optional(),
  nsm: z.object({
    classification: z.enum(['OPEN', 'RESTRICTED', 'CONFIDENTIAL', 'SECRET']).optional(),
    wcagLevel: z.enum(['AA', 'AAA']).optional(),
    norwegianOptimized: z.boolean().optional()
  }).optional(),
  platforms: z.array(z.string()).optional(),
  dependencies: z.array(z.string()).optional(),
  devDependencies: z.array(z.string()).optional(),
  registryDependencies: z.array(z.string()).optional(),
  files: z.array(z.object({
    path: z.string(),
    type: z.string(),
    target: z.string().optional(),
    content: z.string().optional(),
    platform: z.string().optional()
  })),
  cssVars: z.any().optional(),
  config: z.any().optional()
});

type RegistryItem = z.infer<typeof RegistryItemSchema>;

export class RegistryCommandHandler {
  private registryUrl: string = 'https://xaheen.io/registry';
  private localRegistryPath: string = '';

  constructor() {
    // Initialize if needed
  }

  public async handleAdd(components: string[], options: any): Promise<void> {
    const spinner = ora('Fetching registry information...').start();

    try {
      // Configure registry source
      this.configureRegistrySource(options);

      // Get project configuration
      const configPath = join(process.cwd(), 'xaheen.config.json');
      let config: any = {};
      if (existsSync(configPath)) {
        config = JSON.parse(readFileSync(configPath, 'utf-8'));
      }
      const projectType = config.framework || 'react';
      const platform = options.platform || projectType;

      // Installation path
      const basePath = options.path || config.paths?.components || 'src/components';
      const installPath = resolve(process.cwd(), basePath);

      // Ensure installation directory exists
      if (!existsSync(installPath)) {
        mkdirSync(installPath, { recursive: true });
      }

      // Process components
      const installedComponents: string[] = [];
      const dependencies = new Set<string>();
      const devDependencies = new Set<string>();

      for (const componentName of components) {
        spinner.text = `Installing ${componentName}...`;

        // Fetch registry item
        const item = await this.fetchRegistryItem(componentName);

        // Validate platform support
        if (item.platforms && !item.platforms.includes(platform)) {
          logger.warn(`${componentName} does not support platform: ${platform}`);
          continue;
        }

        // Check NSM classification
        if (item.nsm?.classification) {
          logger.info(chalk.yellow(`NSM Classification: ${item.nsm.classification}`));
        }

        // Install registry dependencies first
        if (item.registryDependencies) {
          for (const dep of item.registryDependencies) {
            if (!installedComponents.includes(dep) && !dep.startsWith('http')) {
              await this.handleAdd([dep], { ...options, platform });
              installedComponents.push(dep);
            }
          }
        }

        // Collect dependencies
        if (item.dependencies) {
          item.dependencies.forEach(dep => dependencies.add(dep));
        }
        if (item.devDependencies) {
          item.devDependencies.forEach(dep => devDependencies.add(dep));
        }

        // Install files
        await this.installFiles(item, installPath, platform, options, config);

        // Apply CSS variables
        if (item.cssVars) {
          await this.applyCssVariables(item.cssVars);
        }

        // Apply configuration
        if (item.config) {
          await this.applyConfiguration(item.config);
        }

        installedComponents.push(componentName);
      }

      spinner.succeed(`Installed ${installedComponents.length} components`);

      // Install dependencies
      if (!options.noDeps && (dependencies.size > 0 || devDependencies.size > 0)) {
        await this.installDependencies(
          Array.from(dependencies),
          Array.from(devDependencies),
          options
        );
      }

      // Success message
      console.log(chalk.green('\nâœ¨ Installation completed successfully!'));
      console.log(chalk.gray('\nInstalled components:'));
      installedComponents.forEach(comp => {
        console.log(chalk.gray(`  - ${comp}`));
      });

    } catch (error) {
      spinner.fail('Installation failed');
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  public async handleList(options: any): Promise<void> {
    const spinner = ora('Fetching registry index...').start();

    try {
      this.configureRegistrySource(options);
      const index = await this.fetchRegistryIndex();
      spinner.stop();

      // Filter items
      let items = index.items || [];
      
      if (options.category) {
        items = items.filter((item: any) => item.category === options.category);
      }
      
      if (options.platform) {
        items = items.filter((item: any) => 
          item.platforms?.includes(options.platform)
        );
      }

      if (options.nsm) {
        items = items.filter((item: any) => 
          item.nsm?.classification === options.nsm
        );
      }

      // Display items
      console.log(chalk.blue('\nðŸ“¦ Available Registry Items:\n'));

      const categories = [...new Set(items.map((item: any) => item.category || 'uncategorized'))];
      
      for (const category of categories) {
        const categoryItems = items.filter((item: any) => 
          (item.category || 'uncategorized') === category
        );

        if (categoryItems.length > 0) {
          console.log(chalk.yellow(`${category}:`));
          
          categoryItems.forEach((item: any) => {
            const platforms = item.platforms?.join(', ') || 'all';
            const nsm = item.nsm?.classification 
              ? chalk.red(`[${item.nsm.classification}]`) 
              : '';
            
            console.log(
              `  ${chalk.green(item.name.padEnd(20))} ${chalk.gray(item.title || '')} ${nsm}`
            );
            
            if (item.description) {
              console.log(chalk.gray(`    ${item.description}`));
            }
            
            console.log(chalk.gray(`    Platforms: ${platforms}`));
          });
          
          console.log();
        }
      }

    } catch (error) {
      spinner.fail('Failed to fetch registry');
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  public async handleInfo(component: string, options: any): Promise<void> {
    const spinner = ora(`Fetching info for ${component}...`).start();

    try {
      this.configureRegistrySource(options);
      const item = await this.fetchRegistryItem(component);
      spinner.stop();

      console.log(chalk.blue(`\nðŸ“¦ ${item.title || item.name}\n`));
      
      if (item.description) {
        console.log(item.description);
        console.log();
      }

      console.log(chalk.yellow('Details:'));
      console.log(`  Type: ${item.type}`);
      console.log(`  Category: ${item.category || 'uncategorized'}`);
      
      if (item.platforms) {
        console.log(`  Platforms: ${item.platforms.join(', ')}`);
      }

      if (item.nsm) {
        console.log(chalk.yellow('\nNorwegian Compliance:'));
        console.log(`  NSM Classification: ${item.nsm.classification || 'N/A'}`);
        console.log(`  WCAG Level: ${item.nsm.wcagLevel || 'N/A'}`);
        console.log(`  Norwegian Optimized: ${item.nsm.norwegianOptimized ? 'Yes' : 'No'}`);
      }

      if (item.dependencies && item.dependencies.length > 0) {
        console.log(chalk.yellow('\nDependencies:'));
        item.dependencies.forEach(dep => {
          console.log(`  - ${dep}`);
        });
      }

      if (item.registryDependencies && item.registryDependencies.length > 0) {
        console.log(chalk.yellow('\nRegistry Dependencies:'));
        item.registryDependencies.forEach(dep => {
          console.log(`  - ${dep}`);
        });
      }

      console.log(chalk.yellow('\nFiles:'));
      item.files.forEach(file => {
        console.log(`  - ${file.path} (${file.type})`);
      });

      console.log(chalk.gray(`\nTo install: xaheen registry add ${component}`));

    } catch (error) {
      spinner.fail('Failed to fetch component info');
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  public async handleSearch(query: string, options: any): Promise<void> {
    const spinner = ora('Searching registry...').start();

    try {
      this.configureRegistrySource(options);
      const index = await this.fetchRegistryIndex();
      spinner.stop();

      const results = index.items.filter((item: any) => 
        item.name.includes(query.toLowerCase()) ||
        item.title?.toLowerCase().includes(query.toLowerCase()) ||
        item.description?.toLowerCase().includes(query.toLowerCase())
      );

      if (results.length === 0) {
        console.log(chalk.yellow('\nNo results found.'));
        return;
      }

      console.log(chalk.blue(`\nðŸ” Search Results for "${query}":\n`));

      results.forEach((item: any) => {
        console.log(
          `${chalk.green(item.name.padEnd(20))} ${chalk.gray(item.title || '')}`
        );
        
        if (item.description) {
          console.log(chalk.gray(`  ${item.description}`));
        }
      });

    } catch (error) {
      spinner.fail('Search failed');
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  public async handleBuild(options: any): Promise<void> {
    const spinner = ora('Building registry...').start();

    try {
      // Check if we're in a design system package
      const packageJsonPath = join(process.cwd(), 'package.json');
      if (!existsSync(packageJsonPath)) {
        throw new Error('No package.json found. Are you in a design system package?');
      }

      const packageJson = JSON.parse(readFileSync(packageJsonPath, 'utf-8'));
      
      // Check for registry build script
      if (packageJson.scripts?.['build:registry']) {
        spinner.text = 'Running registry build script...';
        await execAsync('npm run build:registry');
      } else {
        // Manual build process
        const registryPath = join(process.cwd(), 'registry');
        if (!existsSync(registryPath)) {
          throw new Error('No registry directory found');
        }

        // Run the build script directly
        const buildScriptPath = join(process.cwd(), 'scripts/build-registry.ts');
        if (existsSync(buildScriptPath)) {
          await execAsync(`bun ${buildScriptPath}`);
        } else {
          throw new Error('No build script found');
        }
      }

      spinner.succeed('Registry built successfully');
      console.log(chalk.gray('\nRegistry files generated in dist/registry and public/r'));

    } catch (error) {
      spinner.fail('Registry build failed');
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  public async handleServe(options: any): Promise<void> {
    const port = options.port || 3333;
    const host = options.host || 'localhost';

    console.log(chalk.blue('ðŸš€ Starting registry server...\n'));

    try {
      const app = express();
      app.use(cors());

      // Find registry directory
      const registryPaths = [
        join(process.cwd(), 'public/r'),
        join(process.cwd(), 'dist/registry'),
        join(process.cwd(), 'registry')
      ];

      let registryPath: string | null = null;
      for (const path of registryPaths) {
        if (existsSync(path)) {
          registryPath = path;
          break;
        }
      }

      if (!registryPath) {
        throw new Error('No registry directory found. Run "xaheen registry build" first.');
      }

      // Serve registry files
      app.use('/r', express.static(registryPath));

      // Index endpoint
      app.get('/', (req, res) => {
        const indexPath = join(registryPath!, 'index.json');
        if (existsSync(indexPath)) {
          res.sendFile(indexPath);
        } else {
          res.status(404).json({ error: 'Registry index not found' });
        }
      });

      // Start server
      app.listen(port, host, () => {
        console.log(chalk.green(`âœ¨ Registry server running at http://${host}:${port}`));
        console.log(chalk.gray('\nEndpoints:'));
        console.log(chalk.gray(`  Index: http://${host}:${port}/`));
        console.log(chalk.gray(`  Items: http://${host}:${port}/r/[component].json`));
        console.log(chalk.gray('\nPress Ctrl+C to stop the server'));
      });

    } catch (error) {
      logger.error(error instanceof Error ? error.message : 'Unknown error');
      throw error;
    }
  }

  private configureRegistrySource(options: any): void {
    if (options.local) {
      this.localRegistryPath = resolve(options.local);
      if (!existsSync(this.localRegistryPath)) {
        throw new Error(`Local registry path not found: ${this.localRegistryPath}`);
      }
    } else if (options.url) {
      this.registryUrl = options.url;
    } else {
      // Check for local design system registry
      const localPaths = [
        join(process.cwd(), 'packages/design-system/dist/registry'),
        join(process.cwd(), 'packages/design-system/public/r'),
        join(process.cwd(), 'dist/registry'),
        join(process.cwd(), 'public/r')
      ];

      for (const path of localPaths) {
        if (existsSync(path)) {
          this.localRegistryPath = path;
          logger.info(chalk.gray(`Using local registry: ${path}`));
          break;
        }
      }
    }
  }

  private async fetchRegistryIndex(): Promise<any> {
    if (this.localRegistryPath) {
      const indexPath = join(this.localRegistryPath, 'index.json');
      return JSON.parse(readFileSync(indexPath, 'utf-8'));
    }

    const response = await fetch(`${this.registryUrl}/index.json`);
    if (!response.ok) {
      throw new Error(`Failed to fetch registry index: ${response.statusText}`);
    }

    return response.json();
  }

  private async fetchRegistryItem(name: string): Promise<RegistryItem> {
    let data: any;

    if (this.localRegistryPath) {
      const itemPath = join(this.localRegistryPath, `${name}.json`);
      if (!existsSync(itemPath)) {
        throw new Error(`Registry item not found: ${name}`);
      }
      data = JSON.parse(readFileSync(itemPath, 'utf-8'));
    } else {
      const response = await fetch(`${this.registryUrl}/${name}.json`);
      if (!response.ok) {
        throw new Error(`Registry item not found: ${name}`);
      }
      data = await response.json();
    }

    return RegistryItemSchema.parse(data);
  }

  private async installFiles(
    item: RegistryItem, 
    installPath: string, 
    platform: string, 
    options: any,
    config: any
  ): Promise<void> {

    for (const file of item.files) {
      // Skip platform-specific files
      if (file.platform && file.platform !== platform) {
        continue;
      }

      const targetPath = file.target 
        ? resolve(process.cwd(), file.target.replace('~/', ''))
        : resolve(installPath, item.name, file.path.split('/').pop()!);

      // Check if file exists
      if (existsSync(targetPath) && !options.overwrite) {
        logger.warn(`File already exists: ${targetPath}`);
        continue;
      }

      // Ensure directory exists
      const targetDir = targetPath.substring(0, targetPath.lastIndexOf('/'));
      if (!existsSync(targetDir)) {
        mkdirSync(targetDir, { recursive: true });
      }

      // Transform import paths
      let content = file.content || '';
      content = this.transformImports(content, config);

      // Write file
      writeFileSync(targetPath, content);
      logger.success(`Created: ${targetPath}`);
    }
  }

  private transformImports(content: string, config: any): string {
    // Transform @/ imports to configured paths
    const aliases = config.paths?.aliases || {
      '@/components': './components',
      '@/utils': './utils',
      '@/hooks': './hooks',
      '@/lib': './lib'
    };

    let transformed = content;
    
    for (const [alias, path] of Object.entries(aliases)) {
      const regex = new RegExp(`from ['"]${alias.replace('/', '\\/')}`, 'g');
      transformed = transformed.replace(regex, `from '${path}`);
    }

    return transformed;
  }

  private async applyCssVariables(cssVars: any): Promise<void> {
    // TODO: Implement CSS variable injection
    logger.info('CSS variables would be applied to your styles');
  }

  private async applyConfiguration(config: any): Promise<void> {
    // TODO: Implement configuration application
    logger.info('Configuration would be applied to your project');
  }

  private async installDependencies(
    deps: string[],
    devDeps: string[],
    options: any
  ): Promise<void> {
    const spinner = ora('Installing dependencies...').start();

    try {
      // Determine package manager
      let packageManager = 'bun';
      if (options.npm) packageManager = 'npm';
      else if (options.yarn) packageManager = 'yarn';
      else if (options.pnpm) packageManager = 'pnpm';

      // Install commands
      const commands: Record<string, { add: string; addDev: string }> = {
        npm: { add: 'npm install', addDev: 'npm install --save-dev' },
        yarn: { add: 'yarn add', addDev: 'yarn add --dev' },
        pnpm: { add: 'pnpm add', addDev: 'pnpm add --save-dev' },
        bun: { add: 'bun add', addDev: 'bun add --dev' }
      };

      const cmd = commands[packageManager];

      // Install production dependencies
      if (deps.length > 0) {
        spinner.text = `Installing dependencies with ${packageManager}...`;
        await execAsync(`${cmd.add} ${deps.join(' ')}`);
      }

      // Install dev dependencies
      if (devDeps.length > 0) {
        spinner.text = `Installing dev dependencies with ${packageManager}...`;
        await execAsync(`${cmd.addDev} ${devDeps.join(' ')}`);
      }

      spinner.succeed('Dependencies installed successfully');

    } catch (error) {
      spinner.fail('Failed to install dependencies');
      throw error;
    }
  }
}