/**
 * Simplified Stack Adapters
 *
 * Basic implementations that match our StackAdapter interface
 */

import * as fs from "fs/promises";
import * as path from "path";
import type {
	Field,
	GeneratedFile,
	GeneratorContext,
	StackAdapter,
	StackType,
} from "../../types/index.js";

export class NextJsAdapter implements StackAdapter {
	readonly name = "Next.js";
	readonly type: StackType = "nextjs";

	async detect(projectPath: string): Promise<boolean> {
		try {
			const packageJson = await fs.readFile(
				path.join(projectPath, "package.json"),
				"utf-8",
			);
			const pkg = JSON.parse(packageJson);
			return !!(pkg.dependencies?.next || pkg.devDependencies?.next);
		} catch {
			return false;
		}
	}

	async generateModel(context: GeneratorContext): Promise<GeneratedFile[]> {
		const modelName = this.toPascalCase(context.name);

		return [
			{
				path: `prisma/schema.prisma`,
				content: this.generatePrismaModel(modelName, context.fields),
				type: "create",
			},
		];
	}

	async generateController(
		context: GeneratorContext,
	): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/app/api/${this.toKebabCase(context.name)}/route.ts`,
				content: this.generateApiRoute(name, context.fields),
				type: "create",
			},
		];
	}

	async generateService(context: GeneratorContext): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/lib/services/${this.toKebabCase(context.name)}.service.ts`,
				content: this.generateService(name),
				type: "create",
			},
		];
	}

	async generateMigration(context: GeneratorContext): Promise<GeneratedFile[]> {
		return [
			{
				path: `prisma/migrations/${Date.now()}_add_${this.toKebabCase(context.name)}/migration.sql`,
				content: `-- Add ${context.name} table\n-- This will be generated by Prisma`,
				type: "create",
			},
		];
	}

	async generateRoute(context: GeneratorContext): Promise<GeneratedFile[]> {
		return this.generateController(context);
	}

	private generatePrismaModel(name: string, fields?: Field[]): string {
		const modelFields =
			fields
				?.map(
					(field) =>
						`  ${field.name} ${this.mapFieldTypeToPrisma(field.type)}${field.required ? "" : "?"}`,
				)
				.join("\n") || "  id String @id @default(cuid())";

		return `model ${name} {
${modelFields}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`;
	}

	private generateApiRoute(name: string, fields?: Field[]): string {
		return `import { NextRequest, NextResponse } from 'next/server';

export async function GET() {
  // Get all ${name.toLowerCase()}s
  return NextResponse.json({ message: 'Get ${name.toLowerCase()}s' });
}

export async function POST(request: NextRequest) {
  // Create new ${name.toLowerCase()}
  const body = await request.json();
  return NextResponse.json({ message: 'Create ${name.toLowerCase()}', data: body });
}`;
	}

	private generateService(name: string): string {
		return `export class ${name}Service {
  async findAll() {
    // Implementation here
    return [];
  }

  async findById(id: string) {
    // Implementation here
    return null;
  }

  async create(data: any) {
    // Implementation here
    return data;
  }

  async update(id: string, data: any) {
    // Implementation here
    return data;
  }

  async delete(id: string) {
    // Implementation here
    return true;
  }
}`;
	}

	private mapFieldTypeToPrisma(type: string): string {
		const typeMap: Record<string, string> = {
			string: "String",
			number: "Int",
			boolean: "Boolean",
			date: "DateTime",
		};
		return typeMap[type] || "String";
	}

	private toPascalCase(str: string): string {
		return str.replace(/(?:^|[\s_-])(\w)/g, (_, char) => char.toUpperCase());
	}

	private toKebabCase(str: string): string {
		return str
			.replace(/([A-Z])/g, "-$1")
			.toLowerCase()
			.replace(/^-/, "");
	}
}

export class NestJsAdapter implements StackAdapter {
	readonly name = "NestJS";
	readonly type: StackType = "nestjs";

	async detect(projectPath: string): Promise<boolean> {
		try {
			const packageJson = await fs.readFile(
				path.join(projectPath, "package.json"),
				"utf-8",
			);
			const pkg = JSON.parse(packageJson);
			return !!(
				pkg.dependencies?.["@nestjs/core"] ||
				pkg.devDependencies?.["@nestjs/core"]
			);
		} catch {
			return false;
		}
	}

	async generateModel(context: GeneratorContext): Promise<GeneratedFile[]> {
		const modelName = this.toPascalCase(context.name);

		return [
			{
				path: `src/modules/${this.toKebabCase(context.name)}/entities/${this.toKebabCase(context.name)}.entity.ts`,
				content: this.generateEntity(modelName, context.fields),
				type: "create",
			},
		];
	}

	async generateController(
		context: GeneratorContext,
	): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/modules/${this.toKebabCase(context.name)}/${this.toKebabCase(context.name)}.controller.ts`,
				content: this.generateController(name),
				type: "create",
			},
		];
	}

	async generateService(context: GeneratorContext): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/modules/${this.toKebabCase(context.name)}/${this.toKebabCase(context.name)}.service.ts`,
				content: this.generateServiceClass(name),
				type: "create",
			},
		];
	}

	async generateMigration(context: GeneratorContext): Promise<GeneratedFile[]> {
		return [
			{
				path: `prisma/migrations/${Date.now()}_add_${this.toKebabCase(context.name)}/migration.sql`,
				content: `-- Add ${context.name} table for NestJS\n-- This will be generated by Prisma`,
				type: "create",
			},
		];
	}

	async generateRoute(context: GeneratorContext): Promise<GeneratedFile[]> {
		return this.generateController(context);
	}

	private generateEntity(name: string, fields?: Field[]): string {
		const entityFields =
			fields
				?.map(
					(field) =>
						`  @Column()\n  ${field.name}: ${this.mapFieldTypeToTypeScript(field.type)};`,
				)
				.join("\n\n") || "  @Column()\n  name: string;";

		return `import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity()
export class ${name} {
  @PrimaryGeneratedColumn('uuid')
  id: string;

${entityFields}

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`;
	}

	private generateController(name: string): string {
		return `import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { ${name}Service } from './${this.toKebabCase(name)}.service';

@Controller('${this.toKebabCase(name)}')
export class ${name}Controller {
  constructor(private readonly ${this.toCamelCase(name)}Service: ${name}Service) {}

  @Get()
  findAll() {
    return this.${this.toCamelCase(name)}Service.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.${this.toCamelCase(name)}Service.findOne(id);
  }

  @Post()
  create(@Body() createDto: any) {
    return this.${this.toCamelCase(name)}Service.create(createDto);
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() updateDto: any) {
    return this.${this.toCamelCase(name)}Service.update(id, updateDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.${this.toCamelCase(name)}Service.remove(id);
  }
}`;
	}

	private generateServiceClass(name: string): string {
		return `import { Injectable } from '@nestjs/common';

@Injectable()
export class ${name}Service {
  findAll() {
    // Implementation here
    return [];
  }

  findOne(id: string) {
    // Implementation here
    return null;
  }

  create(createDto: any) {
    // Implementation here
    return createDto;
  }

  update(id: string, updateDto: any) {
    // Implementation here
    return updateDto;
  }

  remove(id: string) {
    // Implementation here
    return { deleted: true };
  }
}`;
	}

	private mapFieldTypeToTypeScript(type: string): string {
		const typeMap: Record<string, string> = {
			string: "string",
			number: "number",
			boolean: "boolean",
			date: "Date",
		};
		return typeMap[type] || "string";
	}

	private toPascalCase(str: string): string {
		return str.replace(/(?:^|[\s_-])(\w)/g, (_, char) => char.toUpperCase());
	}

	private toCamelCase(str: string): string {
		return str.replace(/(?:^|[\s_-])(\w)/g, (match, char, index) =>
			index === 0 ? char.toLowerCase() : char.toUpperCase(),
		);
	}

	private toKebabCase(str: string): string {
		return str
			.replace(/([A-Z])/g, "-$1")
			.toLowerCase()
			.replace(/^-/, "");
	}
}
