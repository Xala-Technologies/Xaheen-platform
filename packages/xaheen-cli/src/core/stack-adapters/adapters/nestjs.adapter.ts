/**
 * NestJS Stack Adapter
 * 
 * Generates code for NestJS microservices with TypeScript, Prisma, and best practices
 */

import type { StackAdapter, GeneratorContext, GeneratedFile, Field, StackType } from '../../types/index.js';
import * as fs from 'fs/promises';
import * as path from 'path';

export class NestJsAdapter implements StackAdapter {
  readonly name = 'NestJS';
  readonly type: StackType = 'nestjs';

  async detect(projectPath: string): Promise<boolean> {
    try {
      const packageJson = await fs.readFile(path.join(projectPath, 'package.json'), 'utf-8');
      const pkg = JSON.parse(packageJson);
      return !!(pkg.dependencies?.['@nestjs/core'] || pkg.devDependencies?.['@nestjs/core']);
    } catch {
      return false;
    }
  }

  async generateModel(context: GeneratorContext): Promise<GeneratedFile[]> {
    const modelName = this.toPascalCase(context.name);
    
    return [{
      path: `src/modules/${this.toKebabCase(context.name)}/entities/${this.toKebabCase(context.name)}.entity.ts`,
      content: this.generateEntity(modelName, context.fields),
      type: 'create'
    }];
  }

  async generateController(context: GeneratorContext): Promise<GeneratedFile[]> {
    const name = this.toPascalCase(context.name);
    
    return [{
      path: `src/modules/${this.toKebabCase(context.name)}/${this.toKebabCase(context.name)}.controller.ts`,
      content: this.generateControllerClass(name),
      type: 'create'
    }];
  }

  async generateService(context: GeneratorContext): Promise<GeneratedFile[]> {
    const name = this.toPascalCase(context.name);
    
    return [{
      path: `src/modules/${this.toKebabCase(context.name)}/${this.toKebabCase(context.name)}.service.ts`,
      content: this.generateServiceClass(name),
      type: 'create'
    }];
  }

  async generateMigration(context: GeneratorContext): Promise<GeneratedFile[]> {
    return [{
      path: `prisma/migrations/${Date.now()}_add_${this.toKebabCase(context.name)}/migration.sql`,
      content: `-- Add ${context.name} table for NestJS\n-- This will be generated by Prisma`,
      type: 'create'
    }];
  }

  async generateRoute(context: GeneratorContext): Promise<GeneratedFile[]> {
    return this.generateController(context);
  }

  private generateEntity(name: string, fields?: Field[]): string {
    const entityFields = fields?.map(field => 
      `  @Column()\n  ${field.name}: ${this.mapFieldTypeToTypeScript(field.type)};`
    ).join('\n\n') || '  @Column()\n  name: string;';

    return `import { Entity, Column, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn } from 'typeorm';

@Entity()
export class ${name} {
  @PrimaryGeneratedColumn('uuid')
  id: string;

${entityFields}

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;
}`;
  }

  private generateControllerClass(name: string): string {
    return `import { Controller, Get, Post, Body, Param, Put, Delete } from '@nestjs/common';
import { ${name}Service } from './${this.toKebabCase(name)}.service';

@Controller('${this.toKebabCase(name)}')
export class ${name}Controller {
  constructor(private readonly ${this.toCamelCase(name)}Service: ${name}Service) {}

  @Get()
  findAll() {
    return this.${this.toCamelCase(name)}Service.findAll();
  }

  @Get(':id')
  findOne(@Param('id') id: string) {
    return this.${this.toCamelCase(name)}Service.findOne(id);
  }

  @Post()
  create(@Body() createDto: any) {
    return this.${this.toCamelCase(name)}Service.create(createDto);
  }

  @Put(':id')
  update(@Param('id') id: string, @Body() updateDto: any) {
    return this.${this.toCamelCase(name)}Service.update(id, updateDto);
  }

  @Delete(':id')
  remove(@Param('id') id: string) {
    return this.${this.toCamelCase(name)}Service.remove(id);
  }
}`;
  }

  private generateServiceClass(name: string): string {
    return `import { Injectable } from '@nestjs/common';

@Injectable()
export class ${name}Service {
  findAll() {
    // Implementation here
    return [];
  }

  findOne(id: string) {
    // Implementation here
    return null;
  }

  create(createDto: any) {
    // Implementation here
    return createDto;
  }

  update(id: string, updateDto: any) {
    // Implementation here
    return updateDto;
  }

  remove(id: string) {
    // Implementation here
    return { deleted: true };
  }
}`;
  }

  private mapFieldTypeToTypeScript(type: string): string {
    const typeMap: Record<string, string> = {
      string: 'string',
      number: 'number',
      boolean: 'boolean',
      date: 'Date'
    };
    return typeMap[type] || 'string';
  }

  private toPascalCase(str: string): string {
    return str.replace(/(?:^|[\s_-])(\w)/g, (_, char) => char.toUpperCase());
  }

  private toCamelCase(str: string): string {
    return str.replace(/(?:^|[\s_-])(\w)/g, (match, char, index) => 
      index === 0 ? char.toLowerCase() : char.toUpperCase()
    );
  }

  private toKebabCase(str: string): string {
    return str.replace(/([A-Z])/g, '-$1').toLowerCase().replace(/^-/, '');
  }
}