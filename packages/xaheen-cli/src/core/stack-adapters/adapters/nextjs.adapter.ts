/**
 * Next.js Stack Adapter
 *
 * Generates code for Next.js 14+ with App Router, Prisma, and TypeScript
 */

import * as fs from "fs/promises";
import * as path from "path";
import type {
	Field,
	GeneratedFile,
	GeneratorContext,
	StackAdapter,
	StackType,
} from "../../types/index.js";

export class NextJsAdapter implements StackAdapter {
	readonly name = "Next.js";
	readonly type: StackType = "nextjs";

	async detect(projectPath: string): Promise<boolean> {
		try {
			const packageJson = await fs.readFile(
				path.join(projectPath, "package.json"),
				"utf-8",
			);
			const pkg = JSON.parse(packageJson);
			return !!(pkg.dependencies?.next || pkg.devDependencies?.next);
		} catch {
			return false;
		}
	}

	async generateModel(context: GeneratorContext): Promise<GeneratedFile[]> {
		const modelName = this.toPascalCase(context.name);

		return [
			{
				path: `prisma/schema.prisma`,
				content: this.generatePrismaModel(modelName, context.fields),
				type: "create",
			},
		];
	}

	async generateController(
		context: GeneratorContext,
	): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/app/api/${this.toKebabCase(context.name)}/route.ts`,
				content: this.generateApiRoute(name, context.fields),
				type: "create",
			},
		];
	}

	async generateService(context: GeneratorContext): Promise<GeneratedFile[]> {
		const name = this.toPascalCase(context.name);

		return [
			{
				path: `src/lib/services/${this.toKebabCase(context.name)}.service.ts`,
				content: this.generateServiceClass(name),
				type: "create",
			},
		];
	}

	async generateMigration(context: GeneratorContext): Promise<GeneratedFile[]> {
		return [
			{
				path: `prisma/migrations/${Date.now()}_add_${this.toKebabCase(context.name)}/migration.sql`,
				content: `-- Add ${context.name} table\n-- This will be generated by Prisma`,
				type: "create",
			},
		];
	}

	async generateRoute(context: GeneratorContext): Promise<GeneratedFile[]> {
		return this.generateController(context);
	}

	private generatePrismaModel(name: string, fields?: Field[]): string {
		const modelFields =
			fields
				?.map(
					(field) =>
						`  ${field.name} ${this.mapFieldTypeToPrisma(field.type)}${field.required ? "" : "?"}`,
				)
				.join("\n") || "  id String @id @default(cuid())";

		return `model ${name} {
${modelFields}
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}`;
	}

	private generateApiRoute(name: string, fields?: Field[]): string {
		return `import { NextRequest, NextResponse } from 'next/server';

export async function GET() {
  // Get all ${name.toLowerCase()}s
  return NextResponse.json({ message: 'Get ${name.toLowerCase()}s' });
}

export async function POST(request: NextRequest) {
  // Create new ${name.toLowerCase()}
  const body = await request.json();
  return NextResponse.json({ message: 'Create ${name.toLowerCase()}', data: body });
}`;
	}

	private generateServiceClass(name: string): string {
		return `export class ${name}Service {
  async findAll() {
    // Implementation here
    return [];
  }

  async findById(id: string) {
    // Implementation here
    return null;
  }

  async create(data: any) {
    // Implementation here
    return data;
  }

  async update(id: string, data: any) {
    // Implementation here
    return data;
  }

  async delete(id: string) {
    // Implementation here
    return true;
  }
}`;
	}

	private mapFieldTypeToPrisma(type: string): string {
		const typeMap: Record<string, string> = {
			string: "String",
			number: "Int",
			boolean: "Boolean",
			date: "DateTime",
		};
		return typeMap[type] || "String";
	}

	private toPascalCase(str: string): string {
		return str.replace(/(?:^|[\s_-])(\w)/g, (_, char) => char.toUpperCase());
	}

	private toKebabCase(str: string): string {
		return str
			.replace(/([A-Z])/g, "-$1")
			.toLowerCase()
			.replace(/^-/, "");
	}
}
