/**
 * Phase 7: Tenant Provisioning and Data Isolation Tests
 * 
 * Tests tenant creation, data isolation, and tenant management functionality
 * in multi-tenant SaaS applications generated by Xaheen CLI.
 */

import { describe, it, expect, beforeAll, afterAll, beforeEach, afterEach } from 'vitest';
import { MockTenantDatabase } from '../mocks/tenant-database.mock.js';
import { setupMockLicenseServer } from '../mocks/license-server.mock.js';
import { TEST_CONFIG, type TenantConfig } from '../config/test-config.js';
import { execSync } from 'node:child_process';
import path from 'node:path';
import fs from 'fs-extra';

interface TenantProvisioningResult {
  readonly success: boolean;
  readonly tenantId: string;
  readonly schemaName: string;
  readonly error?: string;
  readonly warnings: readonly string[];
}

interface DataIsolationTestResult {
  readonly isolated: boolean;
  readonly crossContamination: readonly string[];
  readonly testedOperations: readonly string[];
}

describe('Phase 7: Tenant Provisioning and Data Isolation', () => {
  let mockDatabase: MockTenantDatabase;
  let mockLicenseServer: ReturnType<typeof setupMockLicenseServer>;
  let testOutputDir: string;

  beforeAll(async () => {
    // Setup test environment
    testOutputDir = path.join(TEST_CONFIG.projects.outputDir, 'tenant-provisioning-tests');
    await fs.ensureDir(testOutputDir);

    // Setup mock services
    mockDatabase = new MockTenantDatabase();
    await mockDatabase.connect();

    mockLicenseServer = setupMockLicenseServer();
    mockLicenseServer.server.listen();
  });

  afterAll(async () => {
    // Cleanup
    await mockDatabase.disconnect();
    mockLicenseServer.server.close();
    await fs.remove(testOutputDir);
  });

  beforeEach(async () => {
    await mockDatabase.cleanup();
  });

  afterEach(async () => {
    await mockDatabase.cleanup();
  });

  describe('Tenant Schema Creation', () => {
    it('should create separate database schema for each tenant', async () => {
      const tenant = TEST_CONFIG.tenants[0];
      
      const success = await mockDatabase.createTenantSchema(tenant);
      expect(success).toBe(true);

      const schema = mockDatabase.getTenantSchema(tenant.id);
      expect(schema).toBeDefined();
      expect(schema?.name).toBe(tenant.database.schema);
      expect(schema?.tables).toContain('users');
      expect(schema?.tables).toContain('tenant_data');
      expect(schema?.tables).toContain('audit_logs');
    });

    it('should prevent duplicate schema creation', async () => {
      const tenant = TEST_CONFIG.tenants[0];
      
      // Create schema first time
      const firstResult = await mockDatabase.createTenantSchema(tenant);
      expect(firstResult).toBe(true);

      // Try to create same schema again
      const secondResult = await mockDatabase.createTenantSchema(tenant);
      expect(secondResult).toBe(false);
    });

    it('should create schemas for multiple tenants', async () => {
      const tenants = TEST_CONFIG.tenants.slice(0, 3);
      
      for (const tenant of tenants) {
        const success = await mockDatabase.createTenantSchema(tenant);
        expect(success).toBe(true);
      }

      const schemas = mockDatabase.listTenantSchemas();
      expect(schemas).toHaveLength(4); // 3 tenants + 1 public schema

      // Verify each tenant has its own schema
      for (const tenant of tenants) {
        const schema = mockDatabase.getTenantSchema(tenant.id);
        expect(schema?.name).toBe(tenant.database.schema);
      }
    });
  });

  describe('Tenant User Management', () => {
    beforeEach(async () => {
      // Setup tenant schemas for user tests
      for (const tenant of TEST_CONFIG.tenants) {
        await mockDatabase.createTenantSchema(tenant);
      }
    });

    it('should create users within tenant limits', async () => {
      const tenant = TEST_CONFIG.tenants[0]; // Basic tenant with limit of 10 users
      
      // Create users up to the limit
      for (let i = 0; i < tenant.limits.users; i++) {
        const user = await mockDatabase.createTenantUser(tenant.id, {
          email: `user${i}@${tenant.domain}`,
          name: `User ${i}`,
          role: 'viewer',
        });
        
        expect(user).toBeDefined();
        expect(user?.tenantId).toBe(tenant.id);
        expect(user?.email).toBe(`user${i}@${tenant.domain}`);
      }

      const users = mockDatabase.getTenantUsers(tenant.id);
      expect(users).toHaveLength(tenant.limits.users);
    });

    it('should enforce tenant user limits', async () => {
      const tenant = TEST_CONFIG.tenants[0]; // Basic tenant with limit of 10 users
      
      // Create users up to the limit
      for (let i = 0; i < tenant.limits.users; i++) {
        await mockDatabase.createTenantUser(tenant.id, {
          email: `user${i}@${tenant.domain}`,
          name: `User ${i}`,
          role: 'viewer',
        });
      }

      // Try to create one more user (should fail)
      await expect(
        mockDatabase.createTenantUser(tenant.id, {
          email: `overflow@${tenant.domain}`,
          name: 'Overflow User',
          role: 'viewer',
        })
      ).rejects.toThrow(/user limit exceeded/i);
    });

    it('should prevent duplicate emails within tenant', async () => {
      const tenant = TEST_CONFIG.tenants[0];
      
      // Create first user
      await mockDatabase.createTenantUser(tenant.id, {
        email: 'duplicate@example.com',
        name: 'First User',
        role: 'viewer',
      });

      // Try to create user with same email
      await expect(
        mockDatabase.createTenantUser(tenant.id, {
          email: 'duplicate@example.com',
          name: 'Second User',
          role: 'admin',
        })
      ).rejects.toThrow(/email already exists/i);
    });

    it('should allow same email across different tenants', async () => {
      const tenant1 = TEST_CONFIG.tenants[0];
      const tenant2 = TEST_CONFIG.tenants[1];
      const email = 'shared@example.com';

      // Create user in first tenant
      const user1 = await mockDatabase.createTenantUser(tenant1.id, {
        email,
        name: 'User in Tenant 1',
        role: 'admin',
      });

      // Create user with same email in second tenant
      const user2 = await mockDatabase.createTenantUser(tenant2.id, {
        email,
        name: 'User in Tenant 2', 
        role: 'viewer',
      });

      expect(user1).toBeDefined();
      expect(user2).toBeDefined();
      expect(user1?.tenantId).toBe(tenant1.id);
      expect(user2?.tenantId).toBe(tenant2.id);
      expect(user1?.email).toBe(email);
      expect(user2?.email).toBe(email);
    });
  });

  describe('Data Isolation Testing', () => {
    beforeEach(async () => {
      // Setup multiple tenants for isolation testing
      for (const tenant of TEST_CONFIG.tenants.slice(0, 2)) {
        await mockDatabase.createTenantSchema(tenant);
      }
    });

    it('should maintain strict data isolation between tenants', async () => {
      const tenant1 = TEST_CONFIG.tenants[0];
      const tenant2 = TEST_CONFIG.tenants[1];

      // Create users in each tenant
      await mockDatabase.createTenantUser(tenant1.id, {
        email: 'user1@tenant1.com',
        name: 'Tenant 1 User',
        role: 'admin',
      });

      await mockDatabase.createTenantUser(tenant2.id, {
        email: 'user1@tenant2.com',
        name: 'Tenant 2 User',
        role: 'viewer',
      });

      // Create data in each tenant
      await mockDatabase.createTenantData(tenant1.id, {
        name: 'Tenant 1 Data',
        data: { secret: 'tenant1-secret-data' },
      });

      await mockDatabase.createTenantData(tenant2.id, {
        name: 'Tenant 2 Data',
        data: { secret: 'tenant2-secret-data' },
      });

      // Test data isolation
      const isolationResult = await mockDatabase.testDataIsolation(tenant1.id, tenant2.id);
      
      expect(isolationResult.isolated).toBe(true);
      expect(isolationResult.crossContamination).toHaveLength(0);

      // Verify tenant-specific data access
      const tenant1Users = mockDatabase.getTenantUsers(tenant1.id);
      const tenant2Users = mockDatabase.getTenantUsers(tenant2.id);
      const tenant1Data = mockDatabase.getTenantData(tenant1.id);
      const tenant2Data = mockDatabase.getTenantData(tenant2.id);

      expect(tenant1Users).toHaveLength(1);
      expect(tenant2Users).toHaveLength(1);
      expect(tenant1Data).toHaveLength(1);
      expect(tenant2Data).toHaveLength(1);

      // Verify data belongs to correct tenants
      expect(tenant1Users[0].tenantId).toBe(tenant1.id);
      expect(tenant2Users[0].tenantId).toBe(tenant2.id);
      expect(tenant1Data[0].tenantId).toBe(tenant1.id);
      expect(tenant2Data[0].tenantId).toBe(tenant2.id);
    });

    it('should enforce storage limits per tenant', async () => {
      const tenant = TEST_CONFIG.tenants[0]; // Basic tenant with 100MB limit
      
      // Create data that approaches the limit
      const largeDataPayload = {
        name: 'Large Data',
        data: {
          content: 'x'.repeat(50 * 1024 * 1024), // 50MB of data
        },
      };

      await mockDatabase.createTenantData(tenant.id, largeDataPayload);

      // Try to create more data that would exceed the limit
      await expect(
        mockDatabase.createTenantData(tenant.id, {
          name: 'Overflow Data',
          data: {
            content: 'x'.repeat(60 * 1024 * 1024), // 60MB more (would exceed 100MB limit)
          },
        })
      ).rejects.toThrow(/storage limit exceeded/i);
    });
  });

  describe('Tenant Statistics and Monitoring', () => {
    beforeEach(async () => {
      // Setup tenant for stats testing
      await mockDatabase.createTenantSchema(TEST_CONFIG.tenants[0]);
    });

    it('should provide accurate tenant statistics', async () => {
      const tenant = TEST_CONFIG.tenants[0];

      // Create some users and data
      for (let i = 0; i < 3; i++) {
        await mockDatabase.createTenantUser(tenant.id, {
          email: `user${i}@stats.com`,
          name: `Stats User ${i}`,
          role: 'viewer',
        });
      }

      for (let i = 0; i < 2; i++) {
        await mockDatabase.createTenantData(tenant.id, {
          name: `Stats Data ${i}`,
          data: { index: i, content: `data-${i}` },
        });
      }

      const stats = mockDatabase.getTenantStats(tenant.id);
      
      expect(stats).toBeDefined();
      expect(stats?.userCount).toBe(3);
      expect(stats?.dataCount).toBe(2);
      expect(stats?.storageUsed).toBeGreaterThan(0);
      expect(stats?.lastActivity).toBeDefined();
    });

    it('should track tenant activity over time', async () => {
      const tenant = TEST_CONFIG.tenants[0];

      // Get initial stats
      const initialStats = mockDatabase.getTenantStats(tenant.id);
      expect(initialStats?.userCount).toBe(0);
      expect(initialStats?.dataCount).toBe(0);

      // Create some activity
      await mockDatabase.createTenantUser(tenant.id, {
        email: 'activity@test.com',
        name: 'Activity User',
        role: 'admin',
      });

      await mockDatabase.createTenantData(tenant.id, {
        name: 'Activity Data',
        data: { activity: 'user-generated-content' },
      });

      // Get updated stats
      const updatedStats = mockDatabase.getTenantStats(tenant.id);
      expect(updatedStats?.userCount).toBe(1);
      expect(updatedStats?.dataCount).toBe(1);
      expect(updatedStats?.storageUsed).toBeGreaterThan(initialStats?.storageUsed || 0);
    });
  });

  describe('Tenant Lifecycle Management', () => {
    it('should provision new tenant end-to-end', async () => {
      const newTenant: TenantConfig = {
        id: 'tenant-new-001',
        name: 'New Test Tenant',
        domain: 'newtest.localhost',
        subscriptionTier: 'professional',
        features: ['auth', 'dashboard', 'analytics'],
        database: {
          schema: 'tenant_new',
          connectionString: TEST_CONFIG.database.host,
        },
        limits: {
          users: 25,
          storage: 250,
          apiCalls: 5000,
        },
      };

      const result = await provisionTenant(newTenant);
      
      expect(result.success).toBe(true);
      expect(result.tenantId).toBe(newTenant.id);
      expect(result.schemaName).toBe(newTenant.database.schema);
      expect(result.warnings).toHaveLength(0);

      // Verify tenant was created properly
      const schema = mockDatabase.getTenantSchema(newTenant.id);
      expect(schema).toBeDefined();
      expect(schema?.name).toBe(newTenant.database.schema);

      const stats = mockDatabase.getTenantStats(newTenant.id);
      expect(stats).toBeDefined();
      expect(stats?.userCount).toBe(0);
      expect(stats?.dataCount).toBe(0);
    });

    it('should deprovision tenant and cleanup data', async () => {
      const tenant = TEST_CONFIG.tenants[0];
      
      // Create tenant with some data
      await mockDatabase.createTenantSchema(tenant);
      await mockDatabase.createTenantUser(tenant.id, {
        email: 'cleanup@test.com',
        name: 'Cleanup User',
        role: 'admin',
      });

      // Verify tenant exists
      expect(mockDatabase.getTenantSchema(tenant.id)).toBeDefined();
      expect(mockDatabase.getTenantUsers(tenant.id)).toHaveLength(1);

      // Deprovision tenant
      const success = await mockDatabase.dropTenantSchema(tenant.id);
      expect(success).toBe(true);

      // Verify tenant is gone
      expect(mockDatabase.getTenantSchema(tenant.id)).toBeNull();
      expect(mockDatabase.getTenantUsers(tenant.id)).toHaveLength(0);
      expect(mockDatabase.getTenantStats(tenant.id)).toBeNull();
    });
  });

  describe('Subscription Tier Integration', () => {
    beforeEach(async () => {
      // Setup tenants with different subscription tiers
      for (const tenant of TEST_CONFIG.tenants) {
        await mockDatabase.createTenantSchema(tenant);
      }
    });

    it('should enforce limits based on subscription tier', async () => {
      const basicTenant = TEST_CONFIG.tenants.find(t => t.subscriptionTier === 'basic')!;
      const enterpriseTenant = TEST_CONFIG.tenants.find(t => t.subscriptionTier === 'enterprise')!;

      // Basic tenant should have lower limits
      expect(basicTenant.limits.users).toBeLessThan(enterpriseTenant.limits.users);
      expect(basicTenant.limits.storage).toBeLessThan(enterpriseTenant.limits.storage);

      // Verify limits are enforced
      // Basic tenant: try to exceed user limit
      for (let i = 0; i < basicTenant.limits.users; i++) {
        await mockDatabase.createTenantUser(basicTenant.id, {
          email: `basic${i}@test.com`,
          name: `Basic User ${i}`,
          role: 'viewer',
        });
      }

      await expect(
        mockDatabase.createTenantUser(basicTenant.id, {
          email: 'overflow@test.com',
          name: 'Overflow User',
          role: 'viewer',
        })
      ).rejects.toThrow(/user limit exceeded/i);

      // Enterprise tenant: should handle more users
      for (let i = 0; i < Math.min(20, enterpriseTenant.limits.users); i++) {
        const user = await mockDatabase.createTenantUser(enterpriseTenant.id, {
          email: `enterprise${i}@test.com`,
          name: `Enterprise User ${i}`,
          role: 'viewer',
        });
        expect(user).toBeDefined();
      }
    });
  });

  // Helper functions
  async function provisionTenant(tenant: TenantConfig): Promise<TenantProvisioningResult> {
    try {
      const success = await mockDatabase.createTenantSchema(tenant);
      
      if (!success) {
        return {
          success: false,
          tenantId: tenant.id,
          schemaName: tenant.database.schema,
          error: 'Failed to create tenant schema',
          warnings: [],
        };
      }

      return {
        success: true,
        tenantId: tenant.id,
        schemaName: tenant.database.schema,
        warnings: [],
      };
    } catch (error) {
      return {
        success: false,
        tenantId: tenant.id,
        schemaName: tenant.database.schema,
        error: error instanceof Error ? error.message : 'Unknown error',
        warnings: [],
      };
    }
  }
});